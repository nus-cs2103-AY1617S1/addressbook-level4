# A0139817U
###### /java/seedu/address/logic/commands/AddTaskCommandTest.java
``` java
public class AddTaskCommandTest {

	// Initialized to support the tests
	InMemoryTaskList model;

	@Before
	public void setup() {
		model = new TaskManager();
	}
	
	@Test
	public void addTask_validDescription() throws IllegalValueException {
		/* CommandResult should return a string that denotes success in execution if description 
		 * given to AddTaskCommand constructor is a string with size > 0
		 */
		AddTaskCommand command = new AddTaskCommand("Meeting");
		command.setData(model);
		CommandResult result = command.execute();
		String feedback = result.feedbackToUser;
		assertTrue(feedback.equals(String.format(AddTaskCommand.MESSAGE_SUCCESS, "[Floating Task][Description: Meeting]")));

		Date deadline = new GregorianCalendar(2016, Calendar.OCTOBER, 31).getTime();
		command = new AddTaskCommand("Meeting", deadline);
		command.setData(model);
		result = command.execute();
		feedback = result.feedbackToUser;
		assertTrue(feedback.equals(String.format(AddTaskCommand.MESSAGE_SUCCESS, "[Deadline Task][Description: Meeting][Deadline: 31.10.2016]")));
		
		Date startDate = new GregorianCalendar(2016, Calendar.OCTOBER, 30).getTime();
		Date endDate = new GregorianCalendar(2016, Calendar.OCTOBER, 31).getTime();
		command = new AddTaskCommand("Meeting", startDate, endDate);
		command.setData(model);
		result = command.execute();
		feedback = result.feedbackToUser;
		assertTrue(feedback.equals(String.format(AddTaskCommand.MESSAGE_SUCCESS, "[Event Task][Description: Meeting][Start date: 30.10.2016][End date: 31.10.2016]")));
	}
	
	@Test(expected=IllegalValueException.class)
	public void addTask_emptyStringDescription() throws IllegalValueException {
		// Construction of the AddTaskCommand with an empty string should lead to an error
		new AddTaskCommand("");
	}
	
	@Test(expected=IllegalValueException.class)
	public void addTask_nullDescription() throws IllegalValueException {
		// Construction of the AddTaskCommand with null reference should lead to an error
		new AddTaskCommand(null);
	}

}
```
###### /java/seedu/address/logic/commands/DeleteTaskCommandTest.java
``` java
public class DeleteTaskCommandTest {
	
	// Initialized to support the tests
	InMemoryTaskList model;
	
	@Test
	public void deleteTask_noTasksAdded() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since
		 * there are no tasks that have been added).
		 */
		model = TestUtil.setupEmptyTaskList();
		
		CommandResult result = createAndExecuteDelete(1);
		String feedback = result.feedbackToUser;
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertEquals(feedback, expected);
	}
	
	@Test
	public void deleteTask_indexTooLarge() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since
		 * index is too large).
		 */
		model = TestUtil.setupFloatingTasks(3);
		
		CommandResult result = createAndExecuteDelete(4);
		String feedback = result.feedbackToUser;
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertEquals(feedback, expected);
	}
	
	@Test
	public void deleteTask_indexTooSmall() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since 
		 * index is too small).
		 */
		model = TestUtil.setupFloatingTasks(3);
		
		CommandResult result = createAndExecuteDelete(-1);
		String feedback = result.feedbackToUser;
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertEquals(feedback, expected);
	}
	
	@Test
	public void deleteTask_validIndex() throws IllegalValueException {
		/* 
		 * CommandResult should return a string that denotes success in execution if index given 
		 * to DeleteTaskCommand constructor is within the range of added tasks.
		 */
		model = TestUtil.setupFloatingTasks(3);
		
		CommandResult result = createAndExecuteDelete(2);
		String feedback = result.feedbackToUser;
		String expected = String.format(DeleteTaskCommand.MESSAGE_DELETE_TASK_SUCCESS, "[Floating Task][Description: Task 1]");
		assertEquals(feedback, expected);
	}


	/**
	 * Utility functions
	 */
	// Create and execute DeleteTaskCommand
	public CommandResult createAndExecuteDelete(int index) {
		DeleteTaskCommand command = new DeleteTaskCommand(index);
		command.setData(model);
		return command.execute();
	}
}
```
###### /java/seedu/address/logic/commands/UpdateTaskCommandTest.java
``` java
public class UpdateTaskCommandTest {

	// Initialized to support the tests
	InMemoryTaskList model;

	@Before
	public void setup() throws IllegalValueException {
		// Creates fresh copy of tasks
		model = TestUtil.setupMixedTasks(6);
	}

	/**
	 * Format of update command: update INDEX task/description/date(update type) UPDATED_VALUE
	 * 
	 * Testing correct handling of invalid indices 
	 */
	@Test
	public void execute_invalidIndex() throws IllegalValueException {
		/*
		 * Testing correct handling of invalid indices
		 */
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		Description description = new Description("Testing");
		
		// There are only 6 tasks in the list, 7 exceeds the limit
		CommandResult result = createAndExecuteUpdateDescription(7, description);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
		
		// The 1st task starts at 1, not 0
		result = createAndExecuteUpdateDescription(0, description);
		feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
	}
	
	/**
	 * Testing correct updating of tasks
	 */
	@Test
	public void execute_updateTask() throws IllegalValueException {
		Date firstDate = new GregorianCalendar(2016, Calendar.JANUARY, 1).getTime();
		Date secondDate = new GregorianCalendar(2016, Calendar.JANUARY, 2).getTime();		
				
		Task task = new FloatingTask("Hello");
		CommandResult result = createAndExecuteUpdateTask(2, task);
		String expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, task);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
		
		task = new DeadlineTask("Hello", firstDate);
		result = createAndExecuteUpdateTask(3, task);
		expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, task);
		feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
		
		task = new EventTask("Hello", firstDate, secondDate);
		result = createAndExecuteUpdateTask(4, task);
		expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, task);
		feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
	}
	
	/**
	 * Testing correct updating of description of tasks (Floating, Deadline & Event)
	 */
	@Test
	public void execute_floatingTask_updateDescription() throws IllegalValueException {
		Description description = new Description("Hello");
		
		// Index 1 is a floating task
		CommandResult result = createAndExecuteUpdateDescription(1, description);
		String updatedTask = "[Floating Task][Description: Hello]";
		String expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
	}
	
	@Test
	public void execute_deadlineTask_updateDescription() throws IllegalValueException {
		Description description = new Description("Hello");
		
		// Index 2 is a deadline task
		CommandResult result = createAndExecuteUpdateDescription(2, description);
		String updatedTask = "[Deadline Task][Description: Hello][Deadline: 01.01.2016]";
		String expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
	}
	
	@Test
	public void execute_eventTask_updateDescription() throws IllegalValueException {
		Description description = new Description("Hello");
		
		// Index 3 is an event task
		CommandResult result = createAndExecuteUpdateDescription(3, description);
		String updatedTask = "[Event Task][Description: Hello][Start date: 01.01.2016][End date: 02.01.2016]";
		String expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
	}
	
	/**
	 * Testing correct updating of dates of tasks (Floating, Deadline & Event) 
	 * 
	 * Note: Floating tasks can be converted to Deadline/Event tasks if updated with a date.
	 * 		Deadline tasks can be converted to Event tasks and vice versa.
	 * 		Deadline/Event tasks cannot be converted back to Floating tasks with update date.
	 */
	@Test
	public void execute_floatingTask_updateDate() throws IllegalValueException {
		Date firstDate = new GregorianCalendar(2016, Calendar.AUGUST, 20).getTime();
		Date secondDate = new GregorianCalendar(2016, Calendar.AUGUST, 21).getTime();
		/*
		 * Adding a deadline to the floating task by changing it to a deadline task.
		 */
		// Index 1 is a floating task
		CommandResult result = createAndExecuteUpdateDeadline(1, firstDate);
		String updatedTask = "[Deadline Task][Description: Task 0][Deadline: 20.08.2016]";
		String expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
		
		/*
		 * Adding a start date and end date to the floating task by changing it to an event task.
		 */
		result = createAndExecuteUpdateStartEndDate(1, firstDate, secondDate);
		updatedTask = "[Event Task][Description: Task 0][Start date: 20.08.2016][End date: 21.08.2016]";
		expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
		
	}
	
	@Test
	public void execute_deadlineTask_updateDate() throws IllegalValueException {
		Date firstDate = new GregorianCalendar(2016, Calendar.AUGUST, 20).getTime();
		Date secondDate = new GregorianCalendar(2016, Calendar.AUGUST, 21).getTime();
		
		/*
		 * Updating the deadline of a deadline task
		 */
		// Index 2 is a deadline task
		CommandResult result = createAndExecuteUpdateDeadline(2, firstDate);
		String updatedTask = "[Deadline Task][Description: Task 1][Deadline: 20.08.2016]";
		String expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
		
		/*
		 * Giving a start and end date to the deadline task by changing it to an event task.
		 */
		result = createAndExecuteUpdateStartEndDate(2, firstDate, secondDate);
		updatedTask = "[Event Task][Description: Task 1][Start date: 20.08.2016][End date: 21.08.2016]";
		expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
	}
	
	@Test
	public void execute_eventTask_updateDate() throws IllegalValueException {
		Date firstDate = new GregorianCalendar(2016, Calendar.AUGUST, 20).getTime();
		Date secondDate = new GregorianCalendar(2016, Calendar.AUGUST, 21).getTime();
		
		/*
		 * Updating the start and end date of a event task
		 */
		// Index 3 is an event task
		CommandResult result = createAndExecuteUpdateDeadline(3, firstDate);
		String updatedTask = "[Deadline Task][Description: Task 2][Deadline: 20.08.2016]";
		String expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		String feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
		
		/*
		 * Updating the start and end date of a event task
		 */
		result = createAndExecuteUpdateStartEndDate(3, firstDate, secondDate);
		updatedTask = "[Event Task][Description: Task 2][Start date: 20.08.2016][End date: 21.08.2016]";
		expected = String.format(UpdateTaskCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask);
		feedback = result.feedbackToUser;
		assertEquals(feedback, expected);
	}
	
	/**
	 * Utility functions
	 */
	// Create and execute UpdateTaskCommand that updates the entire task of 'index' Task 
	public CommandResult createAndExecuteUpdateTask(int index, Task task) {
		UpdateTaskCommand command = new UpdateTaskCommand(index, task);
		command.setData(model);
		return command.execute();
	}
	
	// Create and execute UpdateTaskCommand that updates the description of 'index' Task
	public CommandResult createAndExecuteUpdateDescription(int index, Description description) {
		UpdateTaskCommand command = new UpdateTaskCommand(index, description);
		command.setData(model);
		return command.execute();
	}
	
	// Create and execute UpdateTaskCommand that updates the deadline of 'index' Task
	public CommandResult createAndExecuteUpdateDeadline(int index, Date deadline) {
		UpdateTaskCommand command = new UpdateTaskCommand(index, deadline);
		command.setData(model);
		return command.execute();
	}
	
	// Create and execute UpdateTaskCommand that updates the start date and the end date of 'index' Task
	public CommandResult createAndExecuteUpdateStartEndDate(int index, Date startDate, Date endDate) {
		UpdateTaskCommand command = new UpdateTaskCommand(index, startDate, endDate);
		command.setData(model);
		return command.execute();
	}
}
```
###### /java/seedu/address/parser/AddCommandParserTest.java
``` java
public class AddCommandParserTest {

	// Initialized to support the tests
	AddCommandParser parser = new AddCommandParser();
	
	/**
	 * Testing situations in which user intends to create Floating Tasks.
	 */
	@Test
	public void prepareCommand_floatingTask_successful() {
		/*
		 * Normal add Floating task command
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("meeting");
		String expectedTask = "[Floating Task][Description: meeting]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	/**
	 * Testing situations in which user intends to create Deadline Tasks.
	 */
	@Test
	public void prepareCommand_deadlineTask_successful() {
		/*
		 * Normal add Deadline task command
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("homework by Oct 12");
		String expectedTask = "[Deadline Task][Description: homework][Deadline: 12.10.2016]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("homework by 1 Jan 2016");
		expectedTask = "[Deadline Task][Description: homework][Deadline: 01.01.2016]";
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_deadlineTask_multipleKeywords() {
		/*
		 * Multiple "from" and "by" keywords should not affect the task command
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("from by from by Oct 12");
		String expectedTask = "[Deadline Task][Description: from by from][Deadline: 12.10.2016]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_deadlineTask_looksLikeEventTask() {
		/*
		 * DeadlineTask that looks like EventTask due to the presence of "from" and "to" keywords.
		 * If "by" comes after the "from" key word, it is a DeadlineTask.
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("Camp from May 11 to May 12 by May 1");
		String expectedTask = "[Deadline Task][Description: Camp from May 11 to May 12][Deadline: 01.05.2016]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_deadlineTask_unsuccessfulDueToIncorrectDate() {
		/*
		 * DeadlineTask becomes a FloatingTask because of incorrect date formats.
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("homework by Ot 12");
		String expectedTask = "[Floating Task][Description: homework by Ot 12]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("homework by Octo 12");
		expectedTask = "[Floating Task][Description: homework by Octo 12]";
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("homework by Oct 35");
		expectedTask = "[Floating Task][Description: homework by Oct 35]";
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_deadlineTask_unsuccessfulDueToIncorrectFormat() {
		/*
		 * DeadlineTask becomes a FloatingTask because of incorrect date formats.
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("passerby Oct 31");
		String expectedTask = "[Floating Task][Description: passerby Oct 31]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	/**
	 * Testing situations in which user intends to create Event Tasks.
	 */
	@Test
	public void prepareCommand_eventTask_successful() {
		/*
		 * Normal add Event task command
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("project from Oct 12 to Oct 13");
		String expectedTask = "[Event Task][Description: project][Start date: 12.10.2016][End date: 13.10.2016]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("project from Oct 12 - Oct 13");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("project from 12 October 2016 to 13 October 2016");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_eventTask_multipleKeywords() {
		/*
		 * Multiple "from" and "by" keywords should not affect the task command
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("from by from by from Oct 1 - Oct 2");
		String expectedTask = "[Event Task][Description: from by from by][Start date: 01.10.2016][End date: 02.10.2016]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_eventTask_looksLikeDeadlineTask() {
		/*
		 * EventTask that looks like DeadlineTask due to the presence of "by" keyword.
		 * If "from" comes after the "by" key word, it is an EventTask.
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("Concert by 1 December from May 1 to May 2");
		String expectedTask = "[Event Task][Description: Concert by 1 December][Start date: 01.05.2016][End date: 02.05.2016]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_eventTask_unsuccessfulDueToIncorrectDate() {
		/*
		 * EventTask becomes a FloatingTask because of incorrect date formats.
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("project from Octo 12 to Oct 13");
		String expectedTask = "[Floating Task][Description: project from Octo 12 to Oct 13]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("project from Oct 12 -- Oct 13");
		expectedTask = "[Floating Task][Description: project from Oct 12 -- Oct 13]";
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("project fr Oct 12 to Oct 13");
		expectedTask = "[Floating Task][Description: project fr Oct 12 to Oct 13]";
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("project from Oct 12 t Oct 13");
		expectedTask = "[Floating Task][Description: project from Oct 12 t Oct 13]";
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (AddTaskCommand) parser.prepareCommand("project by Oct 12 to Oct 13");
		expectedTask = "[Floating Task][Description: project by Oct 12 to Oct 13]";
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}

	@Test
	public void prepareCommand_eventTask_unsuccessfulDueToIncorrectFormat() {
		/*
		 * EventTask becomes a FloatingTask because of incorrect date formats.
		 */
		AddTaskCommand command = (AddTaskCommand) parser.prepareCommand("refrom Oct 30 to Oct 31");
		String expectedTask = "[Floating Task][Description: refrom Oct 30 to Oct 31]";
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
}
```
###### /java/seedu/address/parser/UpdateCommandParserTest.java
``` java
public class UpdateCommandParserTest {
	/**
	 * Format of update command: update INDEX task/description/date(update type) UPDATED_VALUE
	 */
	// Initialized to support the tests
	UpdateCommandParser parser = new UpdateCommandParser();


	/**
	 * Testing correct handling of invalid formats, indices, update types, or dates
	 * 
	 * Invalid EPs: Formats, Indices, Update types, Dates
	 */
	@Test
	public void prepareCommand_invalidFormat() {
		/*
		 * Testing correct handling of invalid formats
		 */
		String expectedTask = String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateTaskCommand.MESSAGE_USAGE);
		
		IncorrectTaskCommand command = (IncorrectTaskCommand) parser.prepareCommand("1taskworkshop");
		String actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("1task workshop");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_invalidIndex() {
		/*
		 * Testing correct handling of invalid indices
		 */
		String expectedTask = MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		
		IncorrectTaskCommand command = (IncorrectTaskCommand) parser.prepareCommand("-1 task workshop");
		String actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("a task workshop");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_invalidUpdateType() {
		/*
		 * Testing correct handling of invalid update types
		 */
		String expectedTask = UpdateCommandParser.MESSAGE_INVALID_UPDATE_TYPE;
		
		IncorrectTaskCommand command = (IncorrectTaskCommand) parser.prepareCommand("2 tasks workshop");
		String actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("3 descriptio workshop");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("3 dat oct 1 to oct 2");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("3 random oct 1 to oct 2");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_invalidDate() {
		/*
		 * Testing correct handling of invalid dates
		 */
		String expectedTask = MESSAGE_INVALID_DATE_FORMAT;
		
		IncorrectTaskCommand command = (IncorrectTaskCommand) parser.prepareCommand("2 date octo 1");
		String actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("3 date oct 1 t oct 2");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("3 date oct 1 to oct 32");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
		
		command = (IncorrectTaskCommand) parser.prepareCommand("3 date some words");
		actualTask = command.feedbackToUser;
		assertEquals(actualTask, expectedTask);
	}
	
	/**
	 * Testing correct updating of tasks, description or date
	 * 
	 * Valid EPs: Task, Description, Date
	 */
	
	/**
	 * Testing correct updating of tasks
	 */
	@Test
	public void prepareCommand_updateTask() {
		UpdateTaskCommand command = (UpdateTaskCommand) parser.prepareCommand("1 task workshop");
		String expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_TASK, 
				"[Floating Task][Description: workshop]");
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (UpdateTaskCommand) parser.prepareCommand("1 task homework by oct 1");
		expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_TASK, 
				"[Deadline Task][Description: homework][Deadline: 01.10.2016]");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (UpdateTaskCommand) parser.prepareCommand("1 task overseas from oct 1 to oct 2");
		expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_TASK, 
				"[Event Task][Description: overseas][Start date: 01.10.2016][End date: 02.10.2016]");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	/**
	 * Testing correct updating of description
	 */
	@Test
	public void prepareCommand_updateDescription() {
		UpdateTaskCommand command = (UpdateTaskCommand) parser.prepareCommand("1 description workshop");
		String expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_DESCRIPTION, 
				"workshop");
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (UpdateTaskCommand) parser.prepareCommand("1 description homework by oct 1");
		expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_DESCRIPTION, 
				"homework by oct 1");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (UpdateTaskCommand) parser.prepareCommand("1 description homework from oct 1 to oct 2");
		expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_DESCRIPTION, 
				"homework from oct 1 to oct 2");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	/**
	 * Testing correct updating of dates of tasks 
	 */
	@Test
	public void prepareCommand_updateDate_deadline() {
		/*
		 * Updating deadlines
		 */
		String expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_DEADLINE, 
				"01.10.2016");
		
		UpdateTaskCommand command = (UpdateTaskCommand) parser.prepareCommand("1 date oct 1");
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (UpdateTaskCommand) parser.prepareCommand("1 date OcTobeR 1 2016");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	@Test
	public void prepareCommand_updateDate_startEndDate() {
		/*
		 * Updating start dates and end dates
		 */
		String expectedTask = String.format(UpdateTaskCommand.TASK_DETAILS_UPDATE_START_END_DATE, 
				"01.10.2016", "02.10.2016");
		
		UpdateTaskCommand command = (UpdateTaskCommand) parser.prepareCommand("1 date oct 1 to oct 2");
		String actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
		
		command = (UpdateTaskCommand) parser.prepareCommand("1 date from oct 1 to oct 2");
		actualTask = command.getTaskDetails();
		assertEquals(actualTask, expectedTask);
	}
	
	
}
```
###### /java/seedu/address/testutil/TestUtil.java
``` java
public class TestUtil {
    
    /**
    * Folder used for temp files created during testing. Ignored by Git.
    */
    public static String SANDBOX_FOLDER = FileUtil.getPath("./src/test/data/sandbox/");

    public static InMemoryTaskList setupEmptyTaskList() {
        return new TaskManager();
    }

    // Setting up tasks in the TaskList in order to find them in the tests
    public static InMemoryTaskList setupSomeTasksInTaskList(int n) throws IllegalValueException {
        InMemoryTaskList newTaskList = new TaskManager();
        // Add 3 tasks into the task manager
        for (int i = 0; i < n; i++) {
            AddTaskCommand command = new AddTaskCommand(String.format("Task %d", i));
            command.setData(newTaskList);
            command.execute();
        }
        return newTaskList;
    }
	
	/**
	 * Setting up Floating tasks in the TaskList in order to find them in the tests
	 */
	public static InMemoryTaskList setupFloatingTasks(int n) throws IllegalValueException {
		InMemoryTaskList newTaskList = new TaskManager();
		// Add 3 tasks into the task manager
		for (int i = 0; i < n; i++) {
			newTaskList.addTask(new FloatingTask(String.format("Task %d", i)));
		}
		return newTaskList;
	}
	
	// Setting up completed tasks in the TaskList in order to find them in the tests
		public static InMemoryTaskList setupSomeCompletedTasksInTaskList(int n) throws IllegalValueException {
		InMemoryTaskList newTaskList = new TaskManager();
		// Add 3 tasks into the task manager
		for (int i = 0; i < n; i++) {
			AddTaskCommand command = new AddTaskCommand(String.format("Task %d", i));
			command.setData(newTaskList);
			command.execute();
		}
		UnmodifiableObservableList<Task> list= newTaskList.getCurrentFilteredTasks();
		for (int i = 0; i < n; i++) {
			list.get(i).setAsComplete();
		}
		return newTaskList;
	}
		
	// Setting up favorited tasks in the TaskList in order to find them in the tests
	public static InMemoryTaskList setupSomeFavoritedTasksInTaskList(int n) throws IllegalValueException {
		InMemoryTaskList newTaskList = new TaskManager();
		// Add 3 tasks into the task manager
		for (int i = 0; i < n; i++) {
			AddTaskCommand command = new AddTaskCommand(String.format("Task %d", i));
			command.setData(newTaskList);
			command.execute();
		}
		UnmodifiableObservableList<Task> list= newTaskList.getCurrentFilteredTasks();
		for (int i = 0; i < n; i++) {
			list.get(i).setAsFavorite();
		}
		return newTaskList;
	}
	/**
	 * Setting up interleaved Floating, Deadline and Event tasks.
	 * Dates for Deadline tasks are set to 1 January 2016.
	 * Date range for Event tasks are set from 1 January 2016 to 2 January 2016.
	 * 
	 * NOTE: Do not change the descriptions and dates because other tests depend on it.
	 */
	public static InMemoryTaskList setupMixedTasks(int n) throws IllegalValueException {
		InMemoryTaskList newTaskList = new TaskManager();
		int counter = 0;
		for (int i = 0; i < n; i++) {
			int k = counter % 3;
			if (k == 0) {
				// Add Floating task
				String description = String.format("Task %d", i);
				newTaskList.addTask(new FloatingTask(description));
				
			} else if (k == 1) {
				// Add Deadline task
				String description = String.format("Task %d", i);
				Date deadline = new GregorianCalendar(2016, Calendar.JANUARY, 1).getTime();
				newTaskList.addTask(new DeadlineTask(description, deadline));
				
			} else {
				// Add Event task
				String description = String.format("Task %d", i);
				Date startDate = new GregorianCalendar(2016, Calendar.JANUARY, 1).getTime();
				Date endDate = new GregorianCalendar(2016, Calendar.JANUARY, 2).getTime();
				newTaskList.addTask(new EventTask(description, startDate, endDate));
			}
			counter++;
		}
		return newTaskList;
	}
  /**
  * Appends the file name to the sandbox folder path.
  * Creates the sandbox folder if it doesn't exist.
  * @param fileName
  * @return
  */
 public static String getFilePathInSandboxFolder(String fileName) {
     try {
         FileUtil.createDirs(new File(SANDBOX_FOLDER));
     } catch (IOException e) {
         throw new RuntimeException(e);
     }
     return SANDBOX_FOLDER + fileName;
 }

 public static void createDataFileWithSampleData(String filePath) {
     createDataFileWithData(generateSampleStorageTaskManager(), filePath);
 }

 public static <T> void createDataFileWithData(T data, String filePath) {
     try {
         File saveFileForTesting = new File(filePath);
         FileUtil.createIfMissing(saveFileForTesting);
         XmlUtil.saveDataToFile(saveFileForTesting, data);
     } catch (Exception e) {
         throw new RuntimeException(e);
     }
 }
 public static XmlSerializableTaskManager generateSampleStorageTaskManager() {
     return new XmlSerializableTaskManager(generateEmptyTaskManager());
 }
 public static UniqueItemCollection<Task> generateEmptyTaskManager() {
     return new UniqueItemCollection<Task>();
 }
 
 public static AnchorPane generateAnchorPane() {
     return new AnchorPane();
 }

}
// TODO: DISABLED TESTUTIL
//    public static String LS = System.lineSeparator();
//
//    public static void assertThrows(Class<? extends Throwable> expected, Runnable executable) {
//        try {
//            executable.run();
//        }
//        catch (Throwable actualException) {
//            if (!actualException.getClass().isAssignableFrom(expected)) {
//                String message = String.format("Expected thrown: %s, actual: %s", expected.getName(),
//                        actualException.getClass().getName());
//                throw new AssertionFailedError(message);
//            } else return;
//        }
//        throw new AssertionFailedError(
//                String.format("Expected %s to be thrown, but nothing was thrown.", expected.getName()));
//    }
//
//    /**
//     * Folder used for temp files created during testing. Ignored by Git.
//     */
//    public static String SANDBOX_FOLDER = FileUtil.getPath("./src/test/data/sandbox/");
//
//    public static final Person[] samplePersonData = getSamplePersonData();
//
//    private static Person[] getSamplePersonData() {
//        try {
//            return new Person[]{
//                    new Person(new Name("Ali Muster"), new Phone("9482424"), new Email("hans@google.com"), new Address("4th street"), new UniqueTagList()),
//                    new Person(new Name("Boris Mueller"), new Phone("87249245"), new Email("ruth@google.com"), new Address("81th street"), new UniqueTagList()),
//                    new Person(new Name("Carl Kurz"), new Phone("95352563"), new Email("heinz@yahoo.com"), new Address("wall street"), new UniqueTagList()),
//                    new Person(new Name("Daniel Meier"), new Phone("87652533"), new Email("cornelia@google.com"), new Address("10th street"), new UniqueTagList()),
//                    new Person(new Name("Elle Meyer"), new Phone("9482224"), new Email("werner@gmail.com"), new Address("michegan ave"), new UniqueTagList()),
//                    new Person(new Name("Fiona Kunz"), new Phone("9482427"), new Email("lydia@gmail.com"), new Address("little tokyo"), new UniqueTagList()),
//                    new Person(new Name("George Best"), new Phone("9482442"), new Email("anna@google.com"), new Address("4th street"), new UniqueTagList()),
//                    new Person(new Name("Hoon Meier"), new Phone("8482424"), new Email("stefan@mail.com"), new Address("little india"), new UniqueTagList()),
//                    new Person(new Name("Ida Mueller"), new Phone("8482131"), new Email("hans@google.com"), new Address("chicago ave"), new UniqueTagList())
//            };
//        } catch (IllegalValueException e) {
//            assert false;
//            //not possible
//            return null;
//        }
//    }
//
//    public static final Tag[] sampleTagData = getSampleTagData();
//
//    private static Tag[] getSampleTagData() {
//        try {
//            return new Tag[]{
//                    new Tag("relatives"),
//                    new Tag("friends")
//            };
//        } catch (IllegalValueException e) {
//            assert false;
//            return null;
//            //not possible
//        }
//    }
//
//    public static List<Person> generateSamplePersonData() {
//        return Arrays.asList(samplePersonData);
//    }
//
//    /**
//     * Appends the file name to the sandbox folder path.
//     * Creates the sandbox folder if it doesn't exist.
//     * @param fileName
//     * @return
//     */
//    public static String getFilePathInSandboxFolder(String fileName) {
//        try {
//            FileUtil.createDirs(new File(SANDBOX_FOLDER));
//        } catch (IOException e) {
//            throw new RuntimeException(e);
//        }
//        return SANDBOX_FOLDER + fileName;
//    }
//
//    public static void createDataFileWithSampleData(String filePath) {
//        createDataFileWithData(generateSampleStorageAddressBook(), filePath);
//    }
//
//    public static <T> void createDataFileWithData(T data, String filePath) {
//        try {
//            File saveFileForTesting = new File(filePath);
//            FileUtil.createIfMissing(saveFileForTesting);
//            XmlUtil.saveDataToFile(saveFileForTesting, data);
//        } catch (Exception e) {
//            throw new RuntimeException(e);
//        }
//    }
//
//    public static void main(String... s) {
//        createDataFileWithSampleData(TestApp.SAVE_LOCATION_FOR_TESTING);
//    }
//
//    public static AddressBook generateEmptyAddressBook() {
//        return new AddressBook(new UniquePersonList(), new UniqueTagList());
//    }
//
//    public static XmlSerializableAddressBook generateSampleStorageAddressBook() {
//        return new XmlSerializableAddressBook(generateEmptyAddressBook());
//    }
//
//    /**
//     * Tweaks the {@code keyCodeCombination} to resolve the {@code KeyCode.SHORTCUT} to their
//     * respective platform-specific keycodes
//     */
//    public static KeyCode[] scrub(KeyCodeCombination keyCodeCombination) {
//        List<KeyCode> keys = new ArrayList<>();
//        if (keyCodeCombination.getAlt() == KeyCombination.ModifierValue.DOWN) {
//            keys.add(KeyCode.ALT);
//        }
//        if (keyCodeCombination.getShift() == KeyCombination.ModifierValue.DOWN) {
//            keys.add(KeyCode.SHIFT);
//        }
//        if (keyCodeCombination.getMeta() == KeyCombination.ModifierValue.DOWN) {
//            keys.add(KeyCode.META);
//        }
//        if (keyCodeCombination.getControl() == KeyCombination.ModifierValue.DOWN) {
//            keys.add(KeyCode.CONTROL);
//        }
//        keys.add(keyCodeCombination.getCode());
//        return keys.toArray(new KeyCode[]{});
//    }
//
//    public static boolean isHeadlessEnvironment() {
//        String headlessProperty = System.getProperty("testfx.headless");
//        return headlessProperty != null && headlessProperty.equals("true");
//    }
//
//    public static void captureScreenShot(String fileName) {
//        File file = GuiTest.captureScreenshot();
//        try {
//            Files.copy(file, new File(fileName + ".png"));
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//    }
//
//    public static String descOnFail(Object... comparedObjects) {
//        return "Comparison failed \n"
//                + Arrays.asList(comparedObjects).stream()
//                .map(Object::toString)
//                .collect(Collectors.joining("\n"));
//    }
//
//    public static void setFinalStatic(Field field, Object newValue) throws NoSuchFieldException, IllegalAccessException{
//        field.setAccessible(true);
//        // remove final modifier from field
//        Field modifiersField = Field.class.getDeclaredField("modifiers");
//        modifiersField.setAccessible(true);
//        // ~Modifier.FINAL is used to remove the final modifier from field so that its value is no longer
//        // final and can be changed
//        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
//        field.set(null, newValue);
//    }
//
//    public static void initRuntime() throws TimeoutException {
//        FxToolkit.registerPrimaryStage();
//        FxToolkit.hideStage();
//    }
//
//    public static void tearDownRuntime() throws Exception {
//        FxToolkit.cleanupStages();
//    }
//
//    /**
//     * Gets private method of a class
//     * Invoke the method using method.invoke(objectInstance, params...)
//     *
//     * Caveat: only find method declared in the current Class, not inherited from supertypes
//     */
//    public static Method getPrivateMethod(Class objectClass, String methodName) throws NoSuchMethodException {
//        Method method = objectClass.getDeclaredMethod(methodName);
//        method.setAccessible(true);
//        return method;
//    }
//
//    public static void renameFile(File file, String newFileName) {
//        try {
//            Files.copy(file, new File(newFileName));
//        } catch (IOException e1) {
//            e1.printStackTrace();
//        }
//    }
//
//    /**
//     * Gets mid point of a node relative to the screen.
//     * @param node
//     * @return
//     */
//    public static Point2D getScreenMidPoint(Node node) {
//        double x = getScreenPos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
//        double y = getScreenPos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
//        return new Point2D(x,y);
//    }
//
//    /**
//     * Gets mid point of a node relative to its scene.
//     * @param node
//     * @return
//     */
//    public static Point2D getSceneMidPoint(Node node) {
//        double x = getScenePos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
//        double y = getScenePos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
//        return new Point2D(x,y);
//    }
//
//    /**
//     * Gets the bound of the node relative to the parent scene.
//     * @param node
//     * @return
//     */
//    public static Bounds getScenePos(Node node) {
//        return node.localToScene(node.getBoundsInLocal());
//    }
//
//    public static Bounds getScreenPos(Node node) {
//        return node.localToScreen(node.getBoundsInLocal());
//    }
//
//    public static double getSceneMaxX(Scene scene) {
//        return scene.getX() + scene.getWidth();
//    }
//
//    public static double getSceneMaxY(Scene scene) {
//        return scene.getX() + scene.getHeight();
//    }
//
//    public static Object getLastElement(List<?> list) {
//        return list.get(list.size() - 1);
//    }
//
//    /**
//     * Removes a subset from the list of persons.
//     * @param persons The list of persons
//     * @param personsToRemove The subset of persons.
//     * @return The modified persons after removal of the subset from persons.
//     */
//    public static TestPerson[] removePersonsFromList(final TestPerson[] persons, TestPerson... personsToRemove) {
//        List<TestPerson> listOfPersons = asList(persons);
//        listOfPersons.removeAll(asList(personsToRemove));
//        return listOfPersons.toArray(new TestPerson[listOfPersons.size()]);
//    }
//
//
//    /**
//     * Returns a copy of the list with the person at specified index removed.
//     * @param list original list to copy from
//     * @param targetIndexInOneIndexedFormat e.g. if the first element to be removed, 1 should be given as index.
//     */
//    public static TestPerson[] removePersonFromList(final TestPerson[] list, int targetIndexInOneIndexedFormat) {
//        return removePersonsFromList(list, list[targetIndexInOneIndexedFormat-1]);
//    }
//
//    /**
//     * Replaces persons[i] with a person.
//     * @param persons The array of persons.
//     * @param person The replacement person
//     * @param index The index of the person to be replaced.
//     * @return
//     */
//    public static TestPerson[] replacePersonFromList(TestPerson[] persons, TestPerson person, int index) {
//        persons[index] = person;
//        return persons;
//    }
//
//    /**
//     * Appends persons to the array of persons.
//     * @param persons A array of persons.
//     * @param personsToAdd The persons that are to be appended behind the original array.
//     * @return The modified array of persons.
//     */
//    public static TestPerson[] addPersonsToList(final TestPerson[] persons, TestPerson... personsToAdd) {
//        List<TestPerson> listOfPersons = asList(persons);
//        listOfPersons.addAll(asList(personsToAdd));
//        return listOfPersons.toArray(new TestPerson[listOfPersons.size()]);
//    }
//
//    private static <T> List<T> asList(T[] objs) {
//        List<T> list = new ArrayList<>();
//        for(T obj : objs) {
//            list.add(obj);
//        }
//        return list;
//    }
//
//    public static boolean compareCardAndPerson(PersonCardHandle card, ReadOnlyPerson person) {
//        return card.isSamePerson(person);
//    }
//
//    public static Tag[] getTagList(String tags) {
//
//        if (tags.equals("")) {
//            return new Tag[]{};
//        }
//
//        final String[] split = tags.split(", ");
//
//        final List<Tag> collect = Arrays.asList(split).stream().map(e -> {
//            try {
//                return new Tag(e.replaceFirst("Tag: ", ""));
//            } catch (IllegalValueException e1) {
//                //not possible
//                assert false;
//                return null;
//            }
//        }).collect(Collectors.toList());
//
//        return collect.toArray(new Tag[split.length]);
//    }
```
