# A0139924W
###### /java/guitests/UndoCommandTest.java
``` java
 */
public class UndoCommandTest extends TarsGuiTest {
    
    @Test
    public void undo_add_successful() {
        // setup
        TestTask taskToUndo = td.taskH;
        commandBox.runCommand(taskToUndo.getAddCommand());
        
        commandBox.runCommand("undo");
        TestTask[] expectedList = {td.taskG};
        assertTrue(taskListPanel.isListMatching(expectedList));
        assertResultMessage(String.format(UndoCommand.MESSAGE_SUCCESS,
                String.format(AddCommand.MESSAGE_UNDO, taskToUndo)));
    }
    
    @Test
    public void undo_delete_successful() {
        // setup
        TestTask[] currentList = td.getTypicalTasks();
        TestTask taskToUndo = currentList[currentList.length - 1];
        commandBox.runCommand("del " + currentList.length);
        
        commandBox.runCommand("undo");
        currentList = td.getTypicalTasks();
        assertTrue(taskListPanel.isListMatching(currentList));
        assertResultMessage(String.format(UndoCommand.MESSAGE_SUCCESS,
                String.format(DeleteCommand.MESSAGE_UNDO, "1.\t" + taskToUndo+"\n")));
        
    }
}
```
###### /java/tars/commons/util/DateTimeUtilTest.java
``` java
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void parseStringToDateTime_invalidDate() {
        thrown.expect(DateTimeException.class);
        thrown.expectMessage(Messages.MESSAGE_INVALID_DATE);

        DateTimeUtil.parseStringToDateTime("abc");
        DateTimeUtil.parseStringToDateTime("hello world");

        DateTimeUtil.parseStringToDateTime("+1");
        DateTimeUtil.parseStringToDateTime("-1");
    }

    @Test
    public void parseStringToDateTime_emptyArgs() {
        String[] expected =
                new String[] {StringUtil.EMPTY_STRING, StringUtil.EMPTY_STRING};
        String[] actual = DateTimeUtil
                .parseStringToDateTime(StringUtil.STRING_WHITESPACE);

        assertEquals(expected[0], actual[0]);
        assertEquals(expected[1], actual[1]);

        actual = DateTimeUtil.parseStringToDateTime(StringUtil.EMPTY_STRING);
        assertEquals(expected[0], actual[0]);
        assertEquals(expected[1], actual[1]);
    }

    @Test
    public void parseStringToDateTime_singleDateSuccessful() {
        String[] expectedDateTime =
                {StringUtil.EMPTY_STRING, "01/01/2016 1500"};
        String[] actualDateTime =
                DateTimeUtil.parseStringToDateTime("1/1/2016 1500");

        assertArrayEquals(expectedDateTime, actualDateTime);
    }
    
    @Test
    public void parseStringToDateTime_dateRangeSuccessful() {
        String[] expectedDateTime = {"01/01/2016 1500", "02/01/2016 1600"};
        String[] actualDateTime = DateTimeUtil
                .parseStringToDateTime("1/1/2016 1500 to 2/1/2016 1600");

        assertArrayEquals(expectedDateTime, actualDateTime);
    }

```
###### /java/tars/logic/AddLogicCommandTest.java
``` java
 */
public class AddLogicCommandTest extends LogicCommandTest {

    @Test
    public void execute_add_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                AddCommand.MESSAGE_USAGE);
        assertCommandBehavior(
                "add /dt 22/04/2016 1400 to 23/04/2016 2200 /p h Valid Task Name",
                expectedMessage);
        assertCommandBehavior("add", expectedMessage);
    }

    @Test
    public void execute_add_invalidTaskData() throws Exception {
        assertCommandBehavior(
                "add []\\[;] /dt 05/09/2016 1400 to 06/09/2016 2200 /p m",
                Name.MESSAGE_NAME_CONSTRAINTS);
        assertCommandBehavior(
                "add name - hello world /dt 05/09/2016 1400 to 06/09/2016 2200 /p m",
                Name.MESSAGE_NAME_CONSTRAINTS);
        assertCommandBehavior(
                "add Valid Task Name /dt @@@notAValidDate@@@ -p m",
                MESSAGE_INVALID_DATE);
        assertCommandBehavior(
                "add Valid Task Name /dt 05/09/2016 1400 to 01/09/2016 2200 /p m",
                MESSAGE_INVALID_END_DATE);
        assertCommandBehavior(
                "add Valid Task Name /dt 05/09/2016 1400 to 06/09/2016 2200 /p medium",
                Priority.MESSAGE_PRIORITY_CONSTRAINTS);
        assertCommandBehavior(
                "add Valid Task Name /dt 05/09/2016 1400 to 06/09/2016 2200 /p m /t invalid_-[.tag",
                Tag.MESSAGE_TAG_CONSTRAINTS);

    }

    @Test
    public void execute_add_successful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_add_endDateSuccessful() throws Exception {
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.generateTaskWithEndDateOnly("Jane");
        Tars expectedTars = new Tars();
        expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_add_floatingTaskSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.floatingTask();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"),
                expectedTars, expectedTars.getTaskList());

    }

    @Test
    public void execute_add_emptyTaskNameInvalidFormat() throws Exception {
        assertCommandBehavior("add ",
                String.format(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        AddCommand.MESSAGE_USAGE)));
    }

```
###### /java/tars/logic/AddLogicCommandTest.java
``` java
    @Test
    public void execute_undoAndRedo_addSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute add command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeTask(toBeAdded);

        // execute undo command and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(AddCommand.MESSAGE_UNDO, toBeAdded)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.addTask(toBeAdded);

        // execute redo command and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(AddCommand.MESSAGE_SUCCESS,
                                toBeAdded + "\n")),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_undoAndRedo_addUnsuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        // execute add command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded + "\n"),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeTask(toBeAdded);
        model.deleteTask(toBeAdded);

        // execute undo command and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());

        model.addTask(toBeAdded);
        expectedTars.addTask(toBeAdded);

        // execute redo command and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_DUPLICATE_TASK),
                expectedTars, expectedTars.getTaskList());
    }
}
```
###### /java/tars/logic/ConfirmLogicCommandTest.java
``` java
    @Test
    public void execute_undoAndRedo_confirmSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        RsvTask taskToRsv =
                helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Task taskToConfirm = helper.generateTaskWithName("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addTask(taskToConfirm);

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "confirm 1 1 /p h /t tag";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(ConfirmCommand.MESSAGE_CONFIRM_SUCCESS,
                        taskToConfirm),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeTask(taskToConfirm);
        expectedTars.addRsvTask(taskToRsv);

        // execute undo command and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());

        expectedTars.addTask(taskToConfirm);
        expectedTars.removeRsvTask(taskToRsv);

        // execute redo command and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());

    }

    @Test
    public void execute_undoAndRedo_confirmUnsuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        RsvTask taskToRsv =
                helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Task taskToConfirm = helper.generateTaskWithName("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addTask(taskToConfirm);

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "confirm 1 1 /p h /t tag";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(ConfirmCommand.MESSAGE_CONFIRM_SUCCESS,
                        taskToConfirm),
                expectedTars, expectedTars.getTaskList());

        model.addRsvTask(taskToRsv);
        expectedTars.addRsvTask(taskToRsv);
        
        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_DUPLICATE_TASK),
                expectedTars, expectedTars.getTaskList());

        model.deleteRsvTask(taskToRsv);
        expectedTars.removeRsvTask(taskToRsv);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_RSV_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());
    }
}
```
###### /java/tars/logic/DeleteLogicCommandTest.java
``` java
    @Test
    public void execute_undoAndRedo_delSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeRemoved = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeRemoved);

        model.addTask(toBeRemoved);
        expectedTars.removeTask(toBeRemoved);

        // execute command and verify result
        assertCommandBehavior("del 1",
                String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS,
                        "1.\t" + toBeRemoved + "\n"),
                expectedTars, expectedTars.getTaskList());

        expectedTars.addTask(toBeRemoved);
        
        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(DeleteCommand.MESSAGE_UNDO,
                                "1.\t" + toBeRemoved + "\n")),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeTask(toBeRemoved);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(DeleteCommand.MESSAGE_REDO,
                                "1.\t" + toBeRemoved + "\n")),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_undoAndRedo_delUnsuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeRemoved = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeRemoved);

        model.addTask(toBeRemoved);
        expectedTars.removeTask(toBeRemoved);

        // execute command and verify result
        assertCommandBehavior("del 1",
                String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS,
                        "1.\t" + toBeRemoved + "\n"),
                expectedTars, expectedTars.getTaskList());

        expectedTars.addTask(toBeRemoved);
        model.addTask(toBeRemoved);

        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_DUPLICATE_TASK),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeTask(toBeRemoved);
        model.deleteTask(toBeRemoved);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());
    }

}
```
###### /java/tars/logic/EditLogicCommandTest.java
``` java
    @Test
    public void execute_undoAndRedo_editSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task taskToAdd = helper.meetAdam();
        Tars expectedTars = prepareExpectedTars();
        Task editedTask =
                expectedTars.getUniqueTaskList().getInternalList().get(0);

        model.addTask(taskToAdd);

        String inputCommand = "edit 1 /n Meet Betty Green /dt 20/09/2016 1800 "
                + "to 21/09/2016 1800 /p h /tr tag2 /ta tag3";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS,
                        expectedTars.getTaskList().get(0)),
                expectedTars, expectedTars.getTaskList());
        
        expectedTars.replaceTask(editedTask, taskToAdd);

        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(EditCommand.MESSAGE_UNDO, taskToAdd)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.replaceTask(taskToAdd, editedTask);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(EditCommand.MESSAGE_REDO, taskToAdd)),
                expectedTars, expectedTars.getTaskList());
    }

    private static Tars prepareExpectedTars() throws IllegalValueException {
        Tars expectedTars = new Tars();
        Name editedName = new Name("Meet Betty Green");
        DateTime editedDateTime =
                new DateTime("20/09/2016 1800", "21/09/2016 1800");
        Priority editedPriority = new Priority("h");
        Status editedStatus = new Status(false);
        Tag tag1 = new Tag("tag1");
        Tag tag2 = new Tag("tag3");
        UniqueTagList editedTags = new UniqueTagList(tag1, tag2);
        Task editedTask = new Task(editedName, editedDateTime, editedPriority,
                editedStatus, editedTags);
        expectedTars.addTask(editedTask);
        expectedTars.getUniqueTagList().add(new Tag("tag2"));

        return expectedTars;
    }
}
```
###### /java/tars/logic/parser/ArgumentTokenizerTest.java
``` java
 *
 */
public class ArgumentTokenizerTest {
    private static final Prefix unknownPrefix = new Prefix("/uuuuuu");
    private static final Prefix tagPrefix = new Prefix("/t");
    private static final Prefix dateTimePrefix = new Prefix("/dt");
    private static final Prefix namePrefix = new Prefix("/n");

    @Test
    public void accessors_notTokenizedYet() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(tagPrefix);

        assertPreambleAbsent(tokenizer);
        assertArgumentAbsent(tokenizer, tagPrefix);
    }

    @Test
    public void tokenize_emptyArgsString_noValues() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(tagPrefix);
        String argsString = " ";
        tokenizer.tokenize(argsString);

        assertPreambleAbsent(tokenizer);
        assertArgumentAbsent(tokenizer, tagPrefix);
    }

    @Test
    public void tokenize_noPrefixes_allTakenAsPreamble() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer();
        String argsString = "  some random string /t tag with leading and trailing spaces ";
        tokenizer.tokenize(argsString);

        // Same string expected as preamble, but leading/trailing spaces should be trimmed
        assertPreamblePresent(tokenizer, argsString.trim());

    }

    @Test
    public void tokenize_oneArgument() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(tagPrefix);

        // Preamble present
        tokenizer.tokenize("    Some preamble string /t Argument value ");
        assertPreamblePresent(tokenizer, "Some preamble string");
        assertArgumentPresent(tokenizer, tagPrefix, "Argument value");

        // No preamble
        tokenizer.tokenize(" /t   Argument value ");
        assertPreambleAbsent(tokenizer);
        assertArgumentPresent(tokenizer, tagPrefix, "Argument value");

    }
    
    @Test
    public void tokenize_multipleArguments() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(tagPrefix, dateTimePrefix, namePrefix);

        // Only two arguments are present
        tokenizer.tokenize("SomePreambleString /t dashT-Value /n slashP value");
        assertPreamblePresent(tokenizer, "SomePreambleString");
        assertArgumentPresent(tokenizer, namePrefix, "slashP value");
        assertArgumentPresent(tokenizer, tagPrefix, "dashT-Value");
        assertArgumentAbsent(tokenizer, dateTimePrefix);

        /* Also covers: Reusing of the tokenizer multiple times */

        // Reuse tokenizer on an empty string to ensure state is correctly reset
        //   (i.e. no stale values from the previous tokenizing remain in the state)
        tokenizer.tokenize("");
        assertPreambleAbsent(tokenizer);
        assertArgumentAbsent(tokenizer, tagPrefix);

        /** Also covers: testing for prefixes not specified as a prefix **/

        // Prefixes not previously given to the tokenizer should not return any values
        String stringWithUnknownPrefix = unknownPrefix.value + "some value";
        tokenizer.tokenize(stringWithUnknownPrefix);
        assertArgumentAbsent(tokenizer, unknownPrefix);
        assertPreamblePresent(tokenizer, stringWithUnknownPrefix); // Unknown prefix is taken as part of preamble
    }
    
    @Test
    public void tokenize_multipleArgumentsWithRepeats() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(tagPrefix, namePrefix);
        
        tokenizer.tokenize("SomePreambleString /n /t dashT-Value /t another");
        assertPreamblePresent(tokenizer, "SomePreambleString");
        assertArgumentPresent(tokenizer, tagPrefix, "dashT-Value", "another");
        assertArgumentPresent(tokenizer, namePrefix, "/n");
    }

    private void assertPreamblePresent(ArgumentTokenizer argsTokenizer, String expectedPreamble) {
        assertEquals(expectedPreamble, argsTokenizer.getPreamble().get());
    }

    private void assertPreambleAbsent(ArgumentTokenizer argsTokenizer) {
        assertFalse(argsTokenizer.getPreamble().isPresent());
    }

    private void assertArgumentAbsent(ArgumentTokenizer argsTokenizer, Prefix prefix) {
        assertFalse(argsTokenizer.getValue(prefix).isPresent());
    }

    private void assertArgumentPresent(ArgumentTokenizer argsTokenizer, Prefix prefix,
            String... expectedValues) {

        // Verify the first value is returned
        assertEquals(expectedValues[0], argsTokenizer.getValue(prefix).get());

        // Verify the number of values returned is as expected
        assertEquals(expectedValues.length, argsTokenizer.getMultipleValues(prefix).get().size());

        // Verify all values returned are as expected and in order
        final AtomicInteger count = new AtomicInteger();
        argsTokenizer.getMultipleValues(prefix).get().forEach((v) -> {
            assertEquals(expectedValues[count.getAndIncrement()], v);
        });
        
    }
}
```
###### /java/tars/logic/parser/PrefixTest.java
``` java
 *
 */
public class PrefixTest {
    
    @Test
    public void equalsMethod() {
        Prefix tagPrefix = new Prefix("/tag");

        assertEquals(tagPrefix, tagPrefix);
        assertEquals(tagPrefix, new Prefix("/tag"));

        assertNotEquals(tagPrefix, "/tag");
        assertNotEquals(tagPrefix, new Prefix("/nTag"));
    }
}
```
###### /java/tars/logic/RedoLogicCommandTest.java
``` java
 */
public class RedoLogicCommandTest extends LogicCommandTest {
    
    @Test
    public void execute_redo_emptyCmdHistStack() throws Exception {
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                RedoCommand.MESSAGE_EMPTY_REDO_CMD_HIST);
    }

    @Test
    public void execute_redo_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                RedoCommand.MESSAGE_USAGE);
        assertCommandBehavior("redo EXTRA ARGUMENTS", expectedMessage);
        assertCommandBehavior("redo 123", expectedMessage);
    }
}
```
###### /java/tars/logic/RsvLogicCommandTest.java
``` java
    @Test
    public void execute_undoAndRedo_rsvSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        RsvTask taskToRsv =
                helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addRsvTask(taskToRsv);

        String inputCommand =
                "rsv Reserved Task /dt 05/09/2016 1400 to 06/09/2016 2200";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(RsvCommand.MESSAGE_SUCCESS, taskToRsv),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeRsvTask(taskToRsv);

        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_UNDO_DELETE,
                                taskToRsv)),
                expectedTars, expectedTars.getTaskList());

        expectedTars.addRsvTask(taskToRsv);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_REDO_ADD, taskToRsv)),
                expectedTars, expectedTars.getTaskList());

    }

    @Test
    public void execute_undoAndRedo_rsvUnsuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        RsvTask taskToRsv =
                helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();
        expectedTars.addRsvTask(taskToRsv);

        String inputCommand =
                "rsv Reserved Task /dt 05/09/2016 1400 to 06/09/2016 2200";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(RsvCommand.MESSAGE_SUCCESS, taskToRsv),
                expectedTars, expectedTars.getTaskList());

        model.deleteRsvTask(taskToRsv);
        expectedTars.removeRsvTask(taskToRsv);

        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_RSV_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());

        model.addRsvTask(taskToRsv);
        expectedTars.addRsvTask(taskToRsv);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_DUPLICATE_TASK),
                expectedTars, expectedTars.getTaskList());

    }

    @Test
    public void execute_undoAndRedo_rsvDelSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        RsvTask taskToRsv =
                helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "rsv /del 1";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(RsvCommand.MESSAGE_SUCCESS_DEL,
                        "1.\t" + taskToRsv + "\n"),
                expectedTars, expectedTars.getTaskList());

        expectedTars.addRsvTask(taskToRsv);

        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_UNDO_ADD,
                                "1.\t" + taskToRsv + "\n")),
                expectedTars, expectedTars.getTaskList());

        expectedTars.removeRsvTask(taskToRsv);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS,
                        String.format(RsvCommand.MESSAGE_REDO_DELETE,
                                "1.\t" + taskToRsv + "\n")),
                expectedTars, expectedTars.getTaskList());

    }

    @Test
    public void execute_undoAndRedo_rsvDelUnsuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        RsvTask taskToRsv =
                helper.generateReservedTaskWithOneDateTimeOnly("Reserved Task");
        Tars expectedTars = new Tars();

        // setup model
        model.addRsvTask(taskToRsv);

        String inputCommand = "rsv /del 1";

        // execute command and verify result
        assertCommandBehavior(inputCommand,
                String.format(RsvCommand.MESSAGE_SUCCESS_DEL,
                        "1.\t" + taskToRsv + "\n"),
                expectedTars, expectedTars.getTaskList());

        model.addRsvTask(taskToRsv);
        expectedTars.addRsvTask(taskToRsv);

        // execute undo and verify result
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_DUPLICATE_TASK),
                expectedTars, expectedTars.getTaskList());

        model.deleteRsvTask(taskToRsv);
        expectedTars.removeRsvTask(taskToRsv);

        // execute redo and verify result
        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_UNSUCCESS,
                        MESSAGE_RSV_TASK_CANNOT_BE_FOUND),
                expectedTars, expectedTars.getTaskList());

    }
}
```
###### /java/tars/logic/TagLogicCommandTest.java
``` java
 */
public class TagLogicCommandTest extends LogicCommandTest {

    @Test
    public void execute_tag_invalidPrefix() throws Exception {
        assertCommandBehavior("tag /gg", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

    @Test
    public void execute_tag_invalidFormat() throws Exception {
        assertCommandBehavior("tag ", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag RANDOM_TEXT", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

    @Test
    public void execute_tag_invalidIndex() throws Exception {
        // EP: negative number
        assertCommandBehavior("tag /e -1 VALIDTASKNAME", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag /del -1",
                MESSAGE_INVALID_TAG_DISPLAYED_INDEX);

        // EP: zero
        assertCommandBehavior("tag /e 0 VALIDTASKNAME",
                MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        assertCommandBehavior("tag /del 0",
                MESSAGE_INVALID_TAG_DISPLAYED_INDEX);

        // EP: signed number
        assertCommandBehavior("tag /e +1 VALIDTASKNAME", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag /e -2 VALIDTASKNAME", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag /del +1",
                MESSAGE_INVALID_TAG_DISPLAYED_INDEX);
        assertCommandBehavior("tag /del -1",
                MESSAGE_INVALID_TAG_DISPLAYED_INDEX);

        // EP: invalid number
        assertCommandBehavior("tag /del aaa", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag /del bbb", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

    @Test
    public void execute_tag_emptyParameters() throws Exception {
        assertCommandBehavior("tag", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag  ", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag -e", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag -e  ", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag -del", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        assertCommandBehavior("tag -del  ", String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
    }

    @Test
    public void execute_tagList_emptyListSuccessful() throws Exception {
        // execute command and verify result
        assertCommandBehavior("tag /ls",
                new Formatter().formatTags(model.getUniqueTagList()));
    }

    @Test
    public void execute_tagList_filledListSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /ls",
                new Formatter().formatTags(model.getUniqueTagList()),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_tagRename_successful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        ReadOnlyTag toBeRenamed =
                expectedTars.getUniqueTagList().getInternalList().get(0);
        Tag newTag = new Tag("tag3");

        expectedTars.getUniqueTagList().update(toBeRenamed, newTag);
        expectedTars.renameTasksWithNewTag(toBeRenamed, newTag);

        // execute command and verify result
        assertCommandBehavior("tag /e 1 tag3",
                String.format(String.format(
                        TagCommand.MESSAGE_RENAME_TAG_SUCCESS, "tag1", "tag3")),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_tagRename_duplicate() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /e 1 tag2", MESSAGE_DUPLICATE_TAG,
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_tagRename_invalidIndex() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /e 3 VALIDTAGNAME",
                MESSAGE_INVALID_TAG_DISPLAYED_INDEX, expectedTars,
                expectedTars.getTaskList());

        assertCommandBehavior("tag /e 4 VALIDTAGNAME",
                MESSAGE_INVALID_TAG_DISPLAYED_INDEX, expectedTars,
                expectedTars.getTaskList());
    }

    @Test
    public void execute_tagRename_invalidTagName() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /e 1 INVALID_TAG_NAME",
                Tag.MESSAGE_TAG_CONSTRAINTS, expectedTars,
                expectedTars.getTaskList());
    }

    @Test
    public void execute_tagDel_successful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        ReadOnlyTag toBeDeleted =
                expectedTars.getUniqueTagList().getInternalList().get(0);

        expectedTars.getUniqueTagList().remove(new Tag(toBeDeleted));
        expectedTars.removeTagFromAllTasks(toBeDeleted);

        // execute command and verify result
        assertCommandBehavior("tag /del 1", String
                .format(TagCommand.MESSAGE_DELETE_TAG_SUCCESS, toBeDeleted),
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_tagDel_invalidIndex() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior("tag /del 3", MESSAGE_INVALID_TAG_DISPLAYED_INDEX,
                expectedTars, expectedTars.getTaskList());

        assertCommandBehavior("tag /del 4", MESSAGE_INVALID_TAG_DISPLAYED_INDEX,
                expectedTars, expectedTars.getTaskList());
    }

    @Test
    public void execute_undoAndRedo_tagEditSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        ReadOnlyTag toBeRenamed =
                expectedTars.getUniqueTagList().getInternalList().get(0);
        Tag newTag = new Tag("tag3");

        expectedTars.getUniqueTagList().update(toBeRenamed, newTag);
        expectedTars.renameTasksWithNewTag(toBeRenamed, newTag);

        assertCommandBehavior("tag /e 1 tag3",
                String.format(String.format(
                        TagCommand.MESSAGE_RENAME_TAG_SUCCESS, "tag1", "tag3")),
                expectedTars, expectedTars.getTaskList());

        toBeRenamed = expectedTars.getUniqueTagList().getInternalList().get(0);
        newTag = new Tag("tag1");

        expectedTars.getUniqueTagList().update(toBeRenamed, newTag);
        expectedTars.renameTasksWithNewTag(toBeRenamed, newTag);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());

        toBeRenamed = expectedTars.getUniqueTagList().getInternalList().get(0);
        newTag = new Tag("tag3");

        expectedTars.getUniqueTagList().update(toBeRenamed, newTag);
        expectedTars.renameTasksWithNewTag(toBeRenamed, newTag);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());
    }

    @Test
    public void execute_undoAndRedo_tagDelSuccessful() throws Exception {
        // setup expectations
        TypicalTestDataHelper helper = new TypicalTestDataHelper();
        Task toBeAdded = helper.meetAdam();
        Tars expectedTars = new Tars();
        expectedTars.addTask(toBeAdded);

        model.addTask(toBeAdded);

        ReadOnlyTag toBeDeleted =
                expectedTars.getUniqueTagList().getInternalList().get(0);

        expectedTars.getUniqueTagList().remove(new Tag(toBeDeleted));
        ArrayList<ReadOnlyTask> editedTaskList =
                expectedTars.removeTagFromAllTasks(toBeDeleted);

        // execute command and verify result
        assertCommandBehavior("tag /del 1", String
                .format(TagCommand.MESSAGE_DELETE_TAG_SUCCESS, toBeDeleted),
                expectedTars, expectedTars.getTaskList());

        expectedTars.getUniqueTagList().add(new Tag(toBeDeleted));
        expectedTars.addTagToAllTasks(toBeDeleted, editedTaskList);

        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                String.format(UndoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());

        expectedTars.getUniqueTagList().remove(new Tag(toBeDeleted));
        expectedTars.removeTagFromAllTasks(toBeDeleted);

        assertCommandBehavior(RedoCommand.COMMAND_WORD,
                String.format(RedoCommand.MESSAGE_SUCCESS, ""), expectedTars,
                expectedTars.getTaskList());
    }
}
```
###### /java/tars/logic/UndoLogicCommandTest.java
``` java
 */
public class UndoLogicCommandTest extends LogicCommandTest {

    @Test
    public void execute_undo_emptyCmdHistStack() throws Exception {
        assertCommandBehavior(UndoCommand.COMMAND_WORD,
                UndoCommand.MESSAGE_EMPTY_UNDO_CMD_HIST);
    }

    @Test
    public void execute_undo_invalidArgsFormat() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                UndoCommand.MESSAGE_USAGE);
        assertCommandBehavior("undo EXTRA ARGUMENTS", expectedMessage);
        assertCommandBehavior("undo 123", expectedMessage);
    }
    
}
```
###### /java/tars/ui/formatter/DateFormatterTest.java
``` java
 */
public class DateFormatterTest {

    @Test
    public void generateSingleDateFormat_todayCorrectFormat() {
        LocalDate testDate = LocalDate.now();
        LocalTime testTime = LocalTime.of(0, 0, 0);
        LocalDateTime testDateTime = LocalDateTime.of(testDate, testTime);

        assertEquals("Today at 12:00 AM",
                DateFormatter.generateSingleDateFormat(testDateTime));
    }
    
    @Test
    public void generateSingleDateFormat_tomorrowCorrectFormat() {
        LocalDate testDate = LocalDate.now().plusDays(1);
        LocalTime testTime = LocalTime.of(0, 0, 0);
        LocalDateTime testDateTime = LocalDateTime.of(testDate, testTime);

        assertEquals("Tomorrow at 12:00 AM",
                DateFormatter.generateSingleDateFormat(testDateTime));
    }
    
    @Test
    public void generateSingleDateFormat_otherDayCorrectFormat() {
        LocalDate testDate = LocalDate.of(2010, 10, 10);
        LocalTime testTime = LocalTime.of(0, 0, 0);
        LocalDateTime testDateTime = LocalDateTime.of(testDate, testTime);

        assertEquals("Sun, Oct 10 12:00 AM",
                DateFormatter.generateSingleDateFormat(testDateTime));
    }
    
    @Test
    public void generateDateRangeFormat_sameDayCorrectFormat() {
        LocalDate testDateA = LocalDate.of(2010, 10, 10);
        LocalTime testTimeA = LocalTime.of(0, 0, 0);
        LocalDate testDateB = LocalDate.of(2010, 10, 10);
        LocalTime testTimeB = LocalTime.of(1, 0, 0);
        LocalDateTime testDateTimeA = LocalDateTime.of(testDateA, testTimeA);
        LocalDateTime testDateTimeB = LocalDateTime.of(testDateB, testTimeB);

        assertEquals("Sun, Oct 10 12:00 AM - 01:00 AM", DateFormatter
                .generateDateRangeFormat(testDateTimeA, testDateTimeB));
    }
    
    @Test
    public void generateDateRangeFormat_diffDaySameYearCorrectFormat() {
        LocalDate testDateA = LocalDate.of(2010, 10, 10);
        LocalTime testTimeA = LocalTime.of(0, 0, 0);
        LocalDate testDateB = LocalDate.of(2010, 11, 10);
        LocalTime testTimeB = LocalTime.of(1, 0, 0);
        LocalDateTime testDateTimeA = LocalDateTime.of(testDateA, testTimeA);
        LocalDateTime testDateTimeB = LocalDateTime.of(testDateB, testTimeB);

        assertEquals("Sun, Oct 10 12:00 AM - Wed, Nov 10 01:00 AM", DateFormatter
                .generateDateRangeFormat(testDateTimeA, testDateTimeB));
    }
    
    @Test
    public void generateDateRangeFormat_diffDayYearCorrectFormat() {
        LocalDate testDateA = LocalDate.of(2010, 10, 10);
        LocalTime testTimeA = LocalTime.of(0, 0, 0);
        LocalDate testDateB = LocalDate.of(2011, 11, 10);
        LocalTime testTimeB = LocalTime.of(1, 0, 0);
        LocalDateTime testDateTimeA = LocalDateTime.of(testDateA, testTimeA);
        LocalDateTime testDateTimeB = LocalDateTime.of(testDateB, testTimeB);

        assertEquals("Sun, Oct 10 2010 12:00 AM - Thu, Nov 10 2011 01:00 AM", DateFormatter
                .generateDateRangeFormat(testDateTimeA, testDateTimeB));
    }
}
```
###### /java/tars/ui/formatter/FormatterTest.java
``` java
 */
public class FormatterTest {
    
    @Test
    public void formatTaskList_emptyList() {
        String actualFormattedText =
                new Formatter().formatTaskList(new ArrayList<ReadOnlyTask>());
        String expectedFormmatedText =
                String.format(Formatter.EMPTY_LIST_MESSAGE, "tasks");

        assertEquals(expectedFormmatedText, actualFormattedText);
    }
    
    @Test
    public void formatRsvTaskList_emptyList() {
        String actualFormattedText =
                new Formatter().formatRsvTaskList(new ArrayList<RsvTask>());
        String expectedFormmatedText =
                String.format(Formatter.EMPTY_LIST_MESSAGE, "tasks");

        assertEquals(expectedFormmatedText, actualFormattedText);
    }
}
```
