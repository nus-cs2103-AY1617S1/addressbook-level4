# A0147969E
###### \java\seedu\task\logic\commands\AddTagCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.LogicManager;
import seedu.task.model.tag.Tag;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.tag.UniqueTagList.DuplicateTagException;
import seedu.task.model.tag.UniqueTagList.NotExistTagException;
import seedu.task.model.task.*;

/**
 * Adds a tag to a task.
 */
public class AddTagCommand extends Command{

    public static final String COMMAND_WORD = "addtag";

    public static final String MESSAGE_USAGE = COMMAND_WORD
    		+ ": add a tag to the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1" + " Tired";

    public static final String MESSAGE_ADD_TAG_SUCCESS = "New tag added: %1$s";
    public static final String MESSAGE_DUPLICATE_TAG = "This Tag already exists";

    public final int targetIndex;
    public final Tag tag;

    public AddTagCommand(int targetIndex, String t) throws IllegalValueException {
        this.targetIndex = targetIndex;;
        this.tag = new Tag(t);
    }

	@Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(targetIndex - 1);

        Description description = taskToUpdate.getDescription();
        Time timeStart = taskToUpdate.getTimeStart();
        Time timeEnd = taskToUpdate.getTimeEnd();
        Priority priority = taskToUpdate.getPriority();
        UniqueTagList tags =taskToUpdate.getTags();
        boolean completeStatus = taskToUpdate.getCompleteStatus();

        try {
			tags.add(tag);
		} catch (DuplicateTagException e1) {
			return new CommandResult(String.format(MESSAGE_DUPLICATE_TAG));
		}
		DeleteCommand delete = new DeleteCommand(targetIndex);
        delete.model = model;
		delete.execute();
		AddCommand add;
		try {
			add = new AddCommand(new Task(description, priority, timeStart, timeEnd, tags, completeStatus), targetIndex-1);
			add.model = model;
			add.insert();
			undo = true;
			LogicManager.tasks.pop();
			try {
				tags.remove(tag);
			} catch (NotExistTagException e1) {
				return new CommandResult("Tag Does Not Exist");
			}
			LogicManager.tasks.push(new Task(description, priority, timeStart, timeEnd, tags, completeStatus));
		} catch (IllegalValueException e){
			 LogicManager.tasks.pop();
			return new CommandResult("re-adding failed");
		};

        return new CommandResult(String.format(MESSAGE_ADD_TAG_SUCCESS, lastShownList.get(targetIndex - 1)));
    }

	 @Override
	 public CommandResult undo() throws IllegalValueException{
		 Task task = LogicManager.tasks.pop();
		 int index = LogicManager.indexes.pop();

		 DeleteCommand delete = new DeleteCommand(index);
		 delete.model = model;
		 delete.execute();

		 AddCommand add = new AddCommand(task,index-1);
		 add.model = model;
		 add.insert();

		 LogicManager.tasks.pop();
		 LogicManager.indexes.pop();

		 return new CommandResult("Undo complete!");
	 }

}
```
###### \java\seedu\task\logic\commands\CompleteCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.LogicManager;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.task.Description;
import seedu.task.model.task.Priority;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.Time;

/**
 * Deletes a task identified using it's last displayed index from the task manager.
 */
public class CompleteCommand extends Command {

    public static final String COMMAND_WORD = "complete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Complete a task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_COMPLETE_TASK_SUCCESS = "Task Done!";

    public final int targetIndex;

    public CompleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToComplete = lastShownList.get(targetIndex - 1);

        Description description = taskToComplete.getDescription();
        Time timeStart = taskToComplete.getTimeStart();
        Time timeEnd = taskToComplete.getTimeEnd();
        Priority priority = taskToComplete.getPriority();
        UniqueTagList tags =taskToComplete.getTags();
        boolean completeStatus = taskToComplete.getCompleteStatus();

        LogicManager.tasks.push(new Task(description, priority, timeStart, timeEnd, tags, completeStatus));
        LogicManager.indexes.push(targetIndex);

        DeleteCommand delete = new DeleteCommand(targetIndex);
        delete.model = model;
		delete.execute();
		AddCommand add;
		try {
			add = new AddCommand(description.toString(), priority.toString(), timeStart, timeEnd, tags, true,targetIndex-1);
			add.model = model;
			add.insert();
			undo = true;
		} catch (IllegalValueException e) {
			LogicManager.tasks.pop();
	        LogicManager.indexes.pop();
			return new CommandResult("Completion failed.");
		}
		SelectCommand select = new SelectCommand(targetIndex);
		select.model = model;
		select.execute();
        return new CommandResult("Completion done!");
    }

    @Override
	 public CommandResult undo() throws IllegalValueException{
		 Task task = LogicManager.tasks.pop();
		 int index = LogicManager.indexes.pop();

		 task.undoTask();
		 DeleteCommand delete = new DeleteCommand(index);
		 delete.model = model;
		 delete.execute();

		 AddCommand add = new AddCommand(task,index-1);
		 add.model = model;
		 add.insert();

		 LogicManager.tasks.pop();
		 LogicManager.indexes.pop();

		 return new CommandResult("Undo complete!");
	 }

}
```
###### \java\seedu\task\logic\commands\UndoCommand.java
``` java
package seedu.task.logic.commands;


import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.LogicManager;

/**
 * Undo the last operation.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo the last add/delete/addTag/deleteTag/update Command.\n"
            + "Example: " + COMMAND_WORD;

    public UndoCommand() {}

    @Override
    public CommandResult execute() {
    	try {
            return LogicManager.undo();
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage());
        }
    }
}
```
###### \java\seedu\task\logic\commands\UpdateCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.LogicManager;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.task.Description;
import seedu.task.model.task.Time;
import seedu.task.model.task.Priority;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;

/**
 * Updates the details of a task.
 */
public class UpdateCommand extends Command{

    public static final String COMMAND_WORD = "update";

    public static final String MESSAGE_USAGE = COMMAND_WORD
    		+ ": update the details of an existing task.\n"
    		+ "Parameters: INDEX [des/DESCRIPTION] [pr/PRIORITY] [st/TIME] [ed/TIME]\n"
            + "Example: " + COMMAND_WORD
            + " des/Go to Tutorial pr/normal st/12:00 ed/14:00";

    public static final String MESSAGE_EDIT_SUCCESS = "Edit successfully: %1$s";
    public static final String MESSAGE_EDIT_FAIL = "Editing failed";

    private final Task toUpdate;
    private int index;

    private Time start;
    private Time end;
    private Description description;
    private Priority priority;
	public UpdateCommand(String index, String description, String priority, String start,
			String end) throws IllegalValueException {

		if(description.equals(""))
			description = "NODESCRIPTION";
		this.description = new Description(description);
		if(priority.equals(""))
			priority = "NOUPDATE";
		this.priority = new Priority(priority);
		this.start = new Time(start);
        this.end = new Time(end);

        this.toUpdate = new Task(
                this.description,
                this.priority,
                this.start,
                this.end,
                new UniqueTagList()
         );

        this.index = Integer.parseInt(index);
	}

	@Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedFilteredTaskList();

        if (lastShownList.size() < index) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(index - 1);

        if(toUpdate.getDescription().toString().equals("NODESCRIPTION"))
        	toUpdate.setDescription(taskToUpdate.getDescription());
        if(toUpdate.getTimeStart().toString().equals(""))
        	toUpdate.setTimeStart(taskToUpdate.getTimeStart());
        if(toUpdate.getTimeEnd().toString().equals(""))
        	toUpdate.setTimeEnd(taskToUpdate.getTimeEnd());
        if(toUpdate.getPriority().toString().equals("NOUPDATE"))
        	toUpdate.setPriority(taskToUpdate.getPriority());
        toUpdate.setTags(taskToUpdate.getTags());
        toUpdate.setCompleteStatus(taskToUpdate.getCompleteStatus());

        if(toUpdate.getTimeEnd().isBefore(toUpdate.getTimeStart()))
			return new CommandResult(MESSAGE_EDIT_FAIL + ": End is before start.");

        LogicManager.tasks.push(new Task(taskToUpdate.getDescription(),
        								 taskToUpdate.getPriority(),
        								 taskToUpdate.getTimeStart(),
        								 taskToUpdate.getTimeEnd(),
        								 taskToUpdate.getTags(),
        								 taskToUpdate.getCompleteStatus()));
        LogicManager.indexes.push(index);

		DeleteCommand delete = new DeleteCommand(index);
        delete.model = model;
		delete.execute();
		LogicManager.tasks.pop();
        LogicManager.indexes.pop();
		AddCommand add;
		try {
			add = new AddCommand(toUpdate,index-1);
			add.model = model;
			add.insert();
			undo = true;
		} catch (IllegalValueException e) {
			LogicManager.tasks.pop();
	        LogicManager.indexes.pop();
			return new CommandResult(String.format(MESSAGE_EDIT_FAIL));
		}
		SelectCommand select = new SelectCommand(index);
		select.model = model;
		select.execute();
        return new CommandResult(String.format(MESSAGE_EDIT_SUCCESS, lastShownList.get(index - 1)));
	}

	@Override
	 public CommandResult undo() throws IllegalValueException{
		 Task task = LogicManager.tasks.pop();
		 int index = LogicManager.indexes.pop();

		 DeleteCommand delete = new DeleteCommand(index);
		 delete.model = model;
		 delete.execute();

		 AddCommand add = new AddCommand(task,index-1);
		 add.model = model;
		 add.insert();

		 LogicManager.tasks.pop();
		 LogicManager.indexes.pop();

		 return new CommandResult("Undo complete!");
	 }
}
```
###### \java\seedu\task\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the complete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareComplete(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        return new CompleteCommand(index.get());
    }
    //@@ author

    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());
    }

    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSelect(String args) {
        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }

    /**
     * Returns the specified index in the {@code command} if it is a positive unsigned integer
     * Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = PERSON_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String operand = (matcher.group("operand") == null) ? "" : matcher.group("operand");
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(operand, keywordSet);
    }


```
###### \java\seedu\task\logic\parser\Parser.java
``` java
    private Command prepareAddTag(String args){
    	final Matcher matcher = TAG_ADD_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    AddTagCommand.MESSAGE_USAGE));
        }


		String[] command = args.trim().split(" ");
		if(command.length!=2)
			return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddTagCommand.MESSAGE_USAGE));

        Optional<Integer> index = parseIndex(command[0]);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddTagCommand.MESSAGE_USAGE));
        }

		try {
			return new AddTagCommand(index.get(),command[1]);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(e.getMessage());
		}
    }

    private Command prepareDeleteTag(String args){
    	final Matcher matcher = TAG_DELETE_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    DeleteTagCommand.MESSAGE_USAGE));
        }


		String[] command = args.trim().split(" ");
		if(command.length!=2)
			return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteTagCommand.MESSAGE_USAGE));

        Optional<Integer> index = parseIndex(command[0]);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteTagCommand.MESSAGE_USAGE));
        }

		try {
			return new DeleteTagCommand(index.get(),command[1]);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(e.getMessage());
		}
    }


    private Command prepareUpdate(String args) throws IllegalValueException{
        final Matcher matcher = TASK_UPDATE_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        try {
            return new UpdateCommand(
            		matcher.group("targetIndex"),
            		matcher.group("description"),
                    matcher.group("priority"),
                    matcher.group("timeStart"),
                    matcher.group("timeEnd")
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### \java\seedu\task\model\task\Description.java
``` java
package seedu.task.model.task;

import seedu.task.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's description in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDescription(String)}
 */
public class Description {

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS = "Task description should be spaces or a string";
    public static final String DESCRIPTION_VALIDATION_REGEX = "[\\p{Alnum} ]+";

    public final String fullDescription;

    /**
     * Validates given decription.
     *
     * @throws IllegalValueException if given description string is invalid.
     */
    public Description(String description) throws IllegalValueException {
        assert description != null;
        description = description.trim();
        if (!isValidDescription(description)) {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
        this.fullDescription = description;
    }

    /**
     * Returns true if a given string is a valid task description.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(DESCRIPTION_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return fullDescription;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                && this.fullDescription.equals(((Description) other).fullDescription)); // state check
    }

    @Override
    public int hashCode() {
        return fullDescription.hashCode();
    }

}
```
###### \java\seedu\task\model\task\Priority.java
``` java
package seedu.task.model.task;


import seedu.task.commons.exceptions.IllegalValueException;

/**
 * Represents a task's priority in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority {

```
###### \java\seedu\task\model\task\Task.java
``` java
    public void undoTask(){
    	completeStatus = false;
    }

    public boolean getCompleteStatus(){
		return completeStatus;
    }

    public void setCompleteStatus(boolean complete){
    	this.completeStatus = complete;
    }
  //@@ author
    @Override
    public Time getTimeStart() {
        return timeStart;
    }

    public void setTimeStart(Time time){
    	this.timeStart = time;
    }

    @Override
    public Time getTimeEnd() {
        return timeEnd;
    }

    public void setTimeEnd(Time time){
    	this.timeEnd = time;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setPriority(Priority priority){
    	this.priority = priority;
    }

    @Override
    public UniqueTagList getTags() {
        return this.tags;
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }
    
    public boolean hasHigherPriorityThan(Task task) {
        return priority.isRankedHigher(task.getPriority());
    }
    
    public boolean hasLowerPriorityThan(Task task) {
        return priority.isRankedLower(task.getPriority());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(description, priority, timeStart, timeEnd, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
