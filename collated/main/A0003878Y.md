# A0003878Y
###### /java/seedu/agendum/logic/commands/AddCommand.java
``` java
    /**
     * Convenience constructor using name
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name)
            throws IllegalValueException {
        this.toAdd = new Task(
                new Name(name)
        );
    }

    /**
     * Convenience constructor using name, end datetime
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, Optional<LocalDateTime> deadlineDate)
            throws IllegalValueException {
        this.toAdd = new Task(
                new Name(name),
                deadlineDate
        );
    }

    /**
     * Convenience constructor using name, start datetime, end datetime
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, Optional<LocalDateTime> startDateTime, Optional<LocalDateTime> endDateTime)
            throws IllegalValueException {
        if (startDateTime.isPresent() && endDateTime.isPresent()) {
            endDateTime = Optional.of(DateTimeUtils.balanceStartAndEndDateTime(startDateTime.get(), endDateTime.get()));
        }
        this.toAdd = new Task(
                new Name(name),
                startDateTime,
                endDateTime
        );
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }

```
###### /java/seedu/agendum/logic/commands/CommandLibrary.java
``` java
    private CommandLibrary() {
        allCommandWords = new Reflections("seedu.agendum").getSubTypesOf(Command.class)
                .stream()
                .map(s -> {
                    try {
                        return s.getMethod("getName").invoke(null).toString();
                    } catch (NullPointerException e) {
                        return null;
                    } catch (Exception e) {
                        logger.severe("Java reflection for Command class failed");
                        throw new RuntimeException();
                    }
                })
                .filter(p -> p != null) // remove nulls
                .collect(Collectors.toList());
    }

    public static CommandLibrary getInstance() {
        return commandLibrary;
    }

```
###### /java/seedu/agendum/logic/parser/DateTimeUtils.java
``` java

public class DateTimeUtils {

    public static Optional<LocalDateTime> parseNaturalLanguageDateTimeString(String input) {
        if(input == null || input.isEmpty()) {
            return Optional.empty();
        }
        // Referring to natty's Parser Class using its full path because of the namespace collision with our Parser class.
        com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser();
        List groups = parser.parse(input);

        if (groups.size() <= 0) {
            return Optional.empty();
        }

        DateGroup dateGroup = (DateGroup) groups.get(0);

        if (dateGroup.getDates().size() < 0) {
            return Optional.empty();
        }

        Date date = dateGroup.getDates().get(0);

        LocalDateTime localDateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
        return Optional.ofNullable(localDateTime);
    }

    public static LocalDateTime balanceStartAndEndDateTime(LocalDateTime startDateTime, LocalDateTime endDateTime) {
        LocalDateTime newEndDateTime = endDateTime;
        while (startDateTime.compareTo(newEndDateTime) >= 1) {
            newEndDateTime = newEndDateTime.plusDays(1);
        }
        return newEndDateTime;
    }

    public static boolean containsTime(String input) {
        return parseNaturalLanguageDateTimeString(input).isPresent();
    }
}
```
###### /java/seedu/agendum/logic/parser/EditDistanceCalculator.java
``` java
public class EditDistanceCalculator {

    private static final Logger logger = LogsCenter.getLogger(EditDistanceCalculator.class);
    private static final int EDIT_DISTANCE_THRESHOLD = 3;

    public static Optional<String> closestCommandMatch(String input) {
        Reflections reflections = new Reflections("seedu.agendum");
        Set<Class<? extends Command>> classes = reflections.getSubTypesOf(Command.class);

        final String[] bestCommand = {""};
        final int[] bestCommandDistance = {Integer.MAX_VALUE};

        Consumer<String> consumer = (commandWord) -> {
            int commandWordDistance = distance(input, commandWord);

            if (commandWordDistance < bestCommandDistance[0]) {
                bestCommand[0] = commandWord;
                bestCommandDistance[0] = commandWordDistance;
            }
        };

        executeOnAllCommands(consumer);

        if (bestCommandDistance[0] < EDIT_DISTANCE_THRESHOLD) {
            return Optional.of(bestCommand[0]);
        } else {
            return Optional.empty();
        }
    }

    public static Optional<String> commandCompletion(String input) {
        ArrayList<String> matchedCommands = new ArrayList<>();

        Consumer<String> consumer = (commandWord) -> {
            if (commandWord.startsWith(input)) {
                matchedCommands.add(commandWord);
            }
        };

        executeOnAllCommands(consumer);

        if (matchedCommands.size() == 1) {
            return Optional.of(matchedCommands.get(0));
        } else {
            return Optional.empty();
        }
    }

    private static void executeOnAllCommands(Consumer f) {
        new Reflections("seedu.agendum").getSubTypesOf(Command.class)
                .stream()
                .map(s -> {
                    try {
                        return s.getMethod("getName").invoke(null).toString();
                    } catch (NullPointerException e) {
                        return "";
                    } catch (Exception e) {
                        logger.severe("Java reflection for Command class failed");
                        throw new RuntimeException();
                    }
                })
                .filter(p -> p != "") // remove empty
                .forEach(f); // execute given lambda on each nonnull String.
    }


    // Code from https://rosettacode.org/wiki/Levenshtein_distance#Java
    private static int distance(String a, String b) {
        a = a.toLowerCase();
        b = b.toLowerCase();
        int [] costs = new int [b.length() + 1];
        for (int j = 0; j < costs.length; j++)
            costs[j] = j;
        for (int i = 1; i <= a.length(); i++) {
            costs[0] = i;
            int nw = i - 1;
            for (int j = 1; j <= b.length(); j++) {
                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);
                nw = costs[j];
                costs[j] = cj;
            }
        }
        return costs[b.length()];
    }

}
```
###### /java/seedu/agendum/logic/parser/Parser.java
``` java
    private static final Pattern ADD_ARGS_FORMAT = Pattern.compile("(?:.+?(?=(?:(?:by|from|to)\\s|$)))+?");

    private static final Pattern SCHEDULE_ARGS_FORMAT = Pattern.compile("(?:.+?(?=(?:(?:by|from|to)\\s|$)))+?");

    private static final Pattern ALIAS_ARGS_FORMAT = Pattern.compile(
            "(?<commandword>[\\p{Alnum}]+)\\s+(?<shorthand>[\\p{Alnum}]+)");

    private static final Pattern UNALIAS_ARGS_FORMAT = Pattern.compile("(?<shorthand>[\\p{Alnum}]+)");

    private static final String ARGS_FROM = "from";
    private static final String ARGS_BY = "by";
    private static final String ARGS_TO = "to";
    private static final String[] TIME_TOKENS = new String[] { ARGS_FROM, ARGS_TO, ARGS_BY };

    private CommandLibrary commandLibrary;
       	
```
###### /java/seedu/agendum/logic/parser/Parser.java
``` java
            Optional<String> alternativeCommand = EditDistanceCalculator.closestCommandMatch(commandWord);
            if (alternativeCommand.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_UNKNOWN_COMMAND_WITH_SUGGESTION, alternativeCommand.get()));
            } else {
                return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
            }
        }
    }

```
###### /java/seedu/agendum/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        Matcher matcher = ADD_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        try {
            matcher.reset();
            matcher.find();
            String taskTitle = matcher.group(0);
            HashMap<String, Optional<LocalDateTime>> dateTimeMap = new HashMap<>();

            while (matcher.find()) {
                for (String token : TIME_TOKENS) {
                    String s = matcher.group(0).toLowerCase();
                    if (s.startsWith(token)) {
                        String time = s.substring(token.length(), s.length());
                        if (DateTimeUtils.containsTime(time)) {
                            dateTimeMap.put(token, DateTimeUtils.parseNaturalLanguageDateTimeString(time));
                        } else {
                            taskTitle = taskTitle + s;
                        }
                    }
                }
            }

            if (dateTimeMap.containsKey(ARGS_BY)) {
                return new AddCommand(taskTitle, dateTimeMap.get(ARGS_BY));
            } else if (dateTimeMap.containsKey(ARGS_FROM) && dateTimeMap.containsKey(ARGS_TO)) {
                return new AddCommand(taskTitle, dateTimeMap.get(ARGS_FROM), dateTimeMap.get(ARGS_TO));
            } else if (!dateTimeMap.containsKey(ARGS_FROM) && !dateTimeMap.containsKey(ARGS_TO)
                    && !dateTimeMap.containsKey(ARGS_BY)) {
                return new AddCommand(taskTitle);
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        AddCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }


    /**
     * Parses arguments in the context of the schedule task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSchedule(String args) {
        Matcher matcher = ADD_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ScheduleCommand.MESSAGE_USAGE));
        }

        matcher.reset();
        matcher.find();
        Optional<Integer> taskIndex = parseIndex(matcher.group(0));
        int index = 0;
        if (taskIndex.isPresent()) {
            index = taskIndex.get();
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ScheduleCommand.MESSAGE_USAGE));
        }
        
        HashMap<String, Optional<LocalDateTime>> dateTimeMap = new HashMap<>();

        while (matcher.find()) {
            for (String token : TIME_TOKENS) {
                String s = matcher.group(0).toLowerCase();
                if (s.startsWith(token)) {
                    String time = s.substring(token.length(), s.length());
                    if (DateTimeUtils.containsTime(time)) {
                        dateTimeMap.put(token, DateTimeUtils.parseNaturalLanguageDateTimeString(time));
                    }
                }
            }
        }

        if (dateTimeMap.containsKey(ARGS_BY)) {
            return new ScheduleCommand(index, Optional.empty(), dateTimeMap.get(ARGS_BY));
        } else if (dateTimeMap.containsKey(ARGS_FROM) && dateTimeMap.containsKey(ARGS_TO)) {
            return new ScheduleCommand(index, dateTimeMap.get(ARGS_FROM), dateTimeMap.get(ARGS_TO));
        } else if (!dateTimeMap.containsKey(ARGS_FROM) && !dateTimeMap.containsKey(ARGS_TO)
                && !dateTimeMap.containsKey(ARGS_BY)) {
            return  new ScheduleCommand(index, Optional.empty(), Optional.empty());
        } else {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ScheduleCommand.MESSAGE_USAGE));
        }
    }
	

```
###### /java/seedu/agendum/ui/HelpWindow.java
``` java
    private void loadHelpList() {
        
        new Reflections("seedu.agendum").getSubTypesOf(Command.class)
                .stream()
                .map(s -> {
                    try {
                        Map<CommandColumns, String> map = new HashMap<>();
                        map.put(CommandColumns.COMMAND, s.getMethod("getName").invoke(null).toString());
                        map.put(CommandColumns.FORMAT, s.getMethod("getFormat").invoke(null).toString());
                        map.put(CommandColumns.DESCRIPTION, s.getMethod("getDescription").invoke(null).toString());
                        return map;
                    } catch (NullPointerException e) {
                        return null;
                    } catch (Exception e) {
                        logger.severe("Java reflection for Command class failed");
                        throw new RuntimeException();
                    }
                })
                .filter(p -> p != null) // remove nulls
                .sorted((lhs, rhs) -> lhs.get(CommandColumns.COMMAND).compareTo(rhs.get(CommandColumns.COMMAND)))
                .forEach(m -> commandList.add(m));
    }
}
```
