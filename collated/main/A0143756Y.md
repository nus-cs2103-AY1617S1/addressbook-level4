# A0143756Y
###### \java\seedu\address\commons\core\Config.java
``` java
    public String getAliasManagerFilePath() {
    	return aliasManagerFilePath;
    }
    
    public void setAliasManagerFilePath(String aliasManagerFilePath) {
    	this.aliasManagerFilePath = aliasManagerFilePath;
    }
```
###### \java\seedu\address\logic\commands\AddAliasCommand.java
``` java
/**
 * Sets alias for an existing command.
 * Command alias and corresponding command phrase will be saved to XML file, "aliasbook.xml" in ./data folder.
 */
public class AddAliasCommand extends Command {

    public static final String COMMAND_WORD = "add-alias";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
    		+ ": Sets alias for a phrase.\n"
    		+ "Parameters: ALIAS = ORIGINAL_PHRASE\n"
    		+ "Example: " + COMMAND_WORD + " add-dl = add deadline\n";
    
    public static final String MESSAGE_SUCCESS = "Alias '%s' set for phrase '%s'.\n";
    
    public static final String MESSAGE_DUPLICATE_ALIAS = "Alias already exists in the alias manager.\n";
    
    public static final String MESSAGE_INVALID_ALIAS = "Alias '%s' is invalid. Alias cannot be a sub-string or "
    		+ "a super-string of any previously set alias. Please re-enter command with a valid alias.\n";
    
    private final String alias; 
    
    private final String originalPhrase;
    
    public AddAliasCommand(String alias, String originalPhrase) {
    	this.alias = alias;
    	this.originalPhrase = originalPhrase;
    }

	@Override
    public CommandResult execute() {
    	EventsCenter.getInstance().post(new DisplayAliasListEvent(model.getFilteredAliasList()));

        assert model != null;
        model.saveState();
        
        try{
        	
        	if (!model.validateAliasforAddAliasCommand(alias)){
        		
        		model.undoSaveState();
        		return new CommandResult(String.format(MESSAGE_INVALID_ALIAS, alias));	
        		
        	}
        	
        	Alias aliasToAdd = new Alias(alias, originalPhrase);
        	model.addAlias(aliasToAdd); //Throws DuplicateAliasException
        	return new CommandResult(String.format(MESSAGE_SUCCESS, alias, originalPhrase));
        	
        } catch (DuplicateAliasException ex){
        	
        	model.loadPreviousState();
            return new CommandResult(String.format(MESSAGE_DUPLICATE_ALIAS));
            
        }
    }
}
```
###### \java\seedu\address\logic\commands\DeleteAliasCommand.java
``` java
/**
 * Deletes an alias identified using its displayed index from the last alias listing .
 */
public class DeleteAliasCommand extends Command {

    public static final String COMMAND_WORD = "del-alias";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the alias identified by the index number displayed in the last alias listing.\n"
            + "Parameters: INDEX [MORE_INDICES] ... \n"
            + "Example: " + COMMAND_WORD + " 1 3";
 
    public static final String MESSAGE_DELETE_ALIAS_SUCCESS = "Deleted aliases: %1$s";

    private final int[] targetIndices;

    public DeleteAliasCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }


    @Override
    public CommandResult execute() {
    	EventsCenter.getInstance().post(new DisplayAliasListEvent(model.getFilteredAliasList()));

    	model.saveState();
    	
        UnmodifiableObservableList<ReadOnlyAlias> lastShownList = model.getFilteredAliasList();

        ArrayList<ReadOnlyAlias> aliasesToDelete = new ArrayList<>();
        
        for (int i=0; i<targetIndices.length; i++) {
        	if (lastShownList.size() < targetIndices[i]) {
                indicateAttemptToExecuteIncorrectCommand();
                return new CommandResult(Messages.MESSAGE_INVALID_DISPLAYED_INDEX);
            }

            aliasesToDelete.add(lastShownList.get(targetIndices[i] - 1));
        }
        
        try {
            model.deleteAliases(aliasesToDelete);
        } catch (AliasNotFoundException pnfe) {
        	model.undoSaveState();
        	return new CommandResult(Messages.MESSAGE_INDEX_NOT_IN_LIST);
        }
        
        return new CommandResult(String.format(MESSAGE_DELETE_ALIAS_SUCCESS, aliasesToDelete));
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
	private void validateEndDateTimeAfterStartDateTime() throws IllegalArgumentException {
		
		if (newStartDateTime.isPresent() && newEndDateTime.isPresent()){
        	LocalDateTime startDateTime = newStartDateTime.get();
        	LocalDateTime endDateTime = newEndDateTime.get();
        	
        	Task.validateEndDateTimeAfterStartDateTime(startDateTime, endDateTime);
        }
        
        if (newStartDateTime.isPresent() && !newEndDateTime.isPresent()){
        	if (isRemoveEndDateTime){
        		throw new IllegalArgumentException(Task.MESSAGE_START_DATE_TIME_CANNOT_BE_SET_WITH_END_DATE_TIME_REMOVED);
        	}
        	
        	if (!taskToEdit.getEndDate().isPresent()){
        		throw new IllegalArgumentException(Task.MESSAGE_START_DATE_TIME_CANNOT_BE_SET_WITH_END_DATE_TIME_MISSING);
        	}
        	
        	LocalDateTime startDateTime = newStartDateTime.get();
    		LocalDateTime endDateTime = taskToEdit.getEndDate().get();
    		
    		Task.validateEndDateTimeAfterStartDateTime(startDateTime, endDateTime);
        }
        
        if (!newStartDateTime.isPresent() && newEndDateTime.isPresent()){           	
        	if ((!isRemoveStartDateTime) && taskToEdit.getStartDate().isPresent()){
        		LocalDateTime endDateTime = newEndDateTime.get();
        		LocalDateTime startDateTime = taskToEdit.getStartDate().get();
        		
        		Task.validateEndDateTimeAfterStartDateTime(startDateTime, endDateTime);
        	}
        }
	}
```
###### \java\seedu\address\logic\commands\ListAliasCommand.java
``` java
/**
 * Lists all aliases in the alias manager to the user.
 */
public class ListAliasCommand extends Command {

    public static final String COMMAND_WORD = "list-alias";
    public static final String MESSAGE_SUCCESS = "Listed all aliases.";

    public ListAliasCommand() {}

    @Override
    public CommandResult execute() {
        assert model != null;
        
        EventsCenter.getInstance().post(new DisplayAliasListEvent(model.getFilteredAliasList()));

        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\address\logic\commands\SetStorageCommand.java
``` java
/**
 * Sets task manager data storage location, according to user specifications.
 * Task manager data to be saved to user-specified folder, with user-specified file name.
 */
public class SetStorageCommand extends Command {

    public static final String COMMAND_WORD = "set-storage";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
    		+ ": Sets task manager data storage location, according to user specifications. "
    		+ "Task manager data to be saved to specified folder specified file name.\n"
    		+ "Parameters: FOLDER_PATH save-as FILE_NAME\n"
    		+ "Example: " + COMMAND_WORD + " C:\\Users\\Liang\\Desktop save-as TaskInformation\n";
    
    public static final String MESSAGE_SUCCESS = "Task manager data storage location set to: %s\n"
    		+ "Please exit and restart Amethyst for new storage settings to be registered.\n";
    
    public static final String MESSAGE_FOLDER_DOES_NOT_EXIST = "User-specified folder: %s does not exist.\n";
    
    public static final String MESSAGE_FOLDER_NOT_DIRECTORY = "User-specified folder: %s is not a folder.\n";
    
    public static final String MESSAGE_STORAGE_PREVIOUSLY_SET = "Task manager data storage location has previously been set to: %s\n";
    
    public static final String MESSAGE_FILE_WITH_IDENTICAL_NAME_EXISTS = "File with identical name %s exists in user-specified folder %s.\n"
    		+ "Program will not proceed to overwrite existing file.\n"
    		+ "Re-enter command with different file name.\n";
    
    public static final String MESSAGE_INVALID_PATH_EXCEPTION = "Invalid file path.\n";
    
    public static final String MESSAGE_IO_EXCEPTION = "Input/output operation failed/ interrupted.\n";
    
    public static final String MESSAGE_SECURITY_EXCEPTION = "Program not granted permission to access file(s).\n";
    
    private final String userSpecifiedStorageFolder; 
    
    private final String userSpecifiedStorageFileName;
    
    public SetStorageCommand(String userSpecifiedStorageFolder, String userSpecifiedStorageFileName) {
    	this.userSpecifiedStorageFolder = userSpecifiedStorageFolder;
    	this.userSpecifiedStorageFileName = userSpecifiedStorageFileName;
    }

	@Override
    public CommandResult execute() {
        assert model != null;
        
        model.saveState();
        
        try{
        	Pair<Path, Path> filePaths = model.validateSetStorage(userSpecifiedStorageFolder, userSpecifiedStorageFileName); //Throws InvalidPathException, SecurityException, IllegalArgumentException
        	
        	Path newStorageFileFilePath = filePaths.getKey();
        	
        	Path oldStorageFileFilePath = filePaths.getValue();
        	
        	model.setStorage(newStorageFileFilePath.toFile(), oldStorageFileFilePath.toFile()); //Throws IOException
        	
        	return new CommandResult(String.format(MESSAGE_SUCCESS, model.getTaskManagerStorageFilePath()));
        	
        } catch (InvalidPathException ex){
        	model.undoSaveState();
        	return new CommandResult(String.format(MESSAGE_INVALID_PATH_EXCEPTION));  	
        } catch (IOException ex){
        	model.undoSaveState();
        	return new CommandResult(MESSAGE_IO_EXCEPTION);    
        } catch (SecurityException ex){
        	model.undoSaveState();
        	return new CommandResult(MESSAGE_SECURITY_EXCEPTION);
        } catch (IllegalArgumentException ex){
        	model.undoSaveState();
        	return new CommandResult(ex.getMessage());
        }
    }
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private static final Pattern SET_STORAGE_ARGS_FORMAT = Pattern.compile
			("(?<folderFilePath>(\\s*[^\\s+])+)\\s+save-as\\s+(?<fileName>(\\s*[^\\s+])+)");
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Parses arguments in the context of the set storage command.
	 * Supports setting of date storage location to user-specified folder, and renaming of 
	 * data storage file with user-specifed file name.
	 *
	 * @param arguments
	 *            full set storage command arguments string
	 *            
	 * @return the prepared SetStorageCommand with user-specified folder file path and file name
	 */
	private Command prepareSetStorage(String arguments){
		final Matcher matcher = SET_STORAGE_ARGS_FORMAT.matcher(arguments.trim());
		
		if (!matcher.matches()){
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SetStorageCommand.MESSAGE_USAGE));
		}
		
		final String folderFilePath = matcher.group("folderFilePath").trim();
		final String fileName = matcher.group("fileName").trim();
		
		logger.finest("Parsed folder path: " + folderFilePath);
		logger.finest("Parsed file Name: " + fileName);
		
		return new SetStorageCommand(folderFilePath, fileName);
	}

```
###### \java\seedu\address\model\Model.java
``` java
    /** Returns TaskManagerStorageFilePath */
    String getTaskManagerStorageFilePath();

```
###### \java\seedu\address\model\Model.java
``` java
    /** Validates arguments passed to SetStorageCommand() method.
     * 	Returns newStorageFileFilePath (Path) and oldStorageFileFilePath (Path) if arguments are valid.
     */
    Pair<Path, Path> validateSetStorage(String userSpecifiedStorageFolder, String userSpecifiedStorageFileName);
    
    /** Sets task manager data storage location */    
    void setStorage(File newStorageFileFilePath, File oldStorageFileFilePath) throws IOException;
    
    /** Checks if alias argument for AddAliasCommand is valid. Alias cannot be a sub-string or super-string or any previously set alias. */
    boolean validateAliasforAddAliasCommand(String alias);    
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public String getTaskManagerStorageFilePath() {
    	return config.getTaskManagerFilePath();
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized boolean validateAliasforAddAliasCommand(String alias) {
    	assert alias != null;
    	assert !alias.isEmpty();
    	
    	ObservableList<Alias> aliasList = aliasManager.getFilteredAliases();
    	for(Alias currentAlias: aliasList){
    		if (currentAlias.getAlias().contains(alias) || alias.contains(currentAlias.getAlias())){
    			return false;
    		}
    	}
    	
    	return true;
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized Pair<Path, Path> validateSetStorage(String userSpecifiedStorageFolder, String userSpecifiedStorageFileName) 
    		throws InvalidPathException, SecurityException, IllegalArgumentException {	
    	
    	//Throws InvalidPathException
    	Path newStorageFolderFilePath = Paths.get(userSpecifiedStorageFolder);  
    	
    	//Throws SecurityException, IllegalArgumentException
    	setStorageCheckUserSpecifiedStorageFolderExists(newStorageFolderFilePath, userSpecifiedStorageFolder); 
    	
    	//Throws SecurityException, IllegalArgumentException
    	setStorageCheckUserSpecifiedStorageFolderisDirectory(newStorageFolderFilePath, userSpecifiedStorageFolder); 
    	
    	//Throws InvalidPathException
    	Path newStorageFileFilePath = newStorageFolderFilePath.resolve(userSpecifiedStorageFileName +".xml");  
    	
    	//Throws InvalidPathException
    	Path oldStorageFileFilePath = Paths.get(getTaskManagerStorageFilePath());  
    	
    	//Throws IllegalArgumentException
    	setStorageCheckDataStorageLocationPreviouslySet(newStorageFileFilePath, oldStorageFileFilePath); 
    	
    	//Throws SecurityException, IllegalArgumentException
    	setStorageCheckFileWithIdenticalNameExistsinUserSpecifiedStorageFolder(newStorageFileFilePath, 
    			userSpecifiedStorageFileName, userSpecifiedStorageFolder); 
    	
    	return new Pair<Path, Path>(newStorageFileFilePath, oldStorageFileFilePath);
    }
    
    @Override
    public synchronized void setStorage(File newStorageFile, File oldStorageFile) throws IOException{
    	assert newStorageFile!= null;
    	assert oldStorageFile!= null;
    	assert !newStorageFile.equals(oldStorageFile);
    	
    	setStorageCopyDataFromOldStorageFileToNewStorageFile(oldStorageFile, newStorageFile); //Throws IOException
    	
    	setStorageUpdateTaskManagerFilePathInConfig(newStorageFile); //Throws IOException
    	
    	setStorageSerialiseConfigToConfigJsonFile(); // Throws IOException
    }
    
    private void setStorageCheckUserSpecifiedStorageFolderExists(Path newStorageFolderFilePath, String userSpecifiedStorageFolder) 
    		throws SecurityException, IllegalArgumentException {
    	if(java.nio.file.Files.notExists(newStorageFolderFilePath)){  //Throws SecurityException
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_FOLDER_DOES_NOT_EXIST, userSpecifiedStorageFolder)); 
    	} 
    }
    
    private void setStorageCheckUserSpecifiedStorageFolderisDirectory(Path newStorageFolderFilePath, String userSpecifiedStorageFolder) 
    		throws SecurityException, IllegalArgumentException {
    	if(!java.nio.file.Files.isDirectory(newStorageFolderFilePath)){  //Throws SecurityException
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_FOLDER_NOT_DIRECTORY, userSpecifiedStorageFolder)); 
    	}      
    }
    
    private void setStorageCheckDataStorageLocationPreviouslySet(Path newStorageFileFilePath, Path oldStorageFileFilePath) {
    	if(newStorageFileFilePath.equals(oldStorageFileFilePath)){
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_STORAGE_PREVIOUSLY_SET, oldStorageFileFilePath.toString())); 
    	} 
    }
    
    private void setStorageCheckFileWithIdenticalNameExistsinUserSpecifiedStorageFolder(Path newStorageFileFilePath, 
    		String userSpecifiedStorageFileName, String userSpecifiedStorageFolder) throws SecurityException, IllegalArgumentException {
    	if(java.nio.file.Files.exists(newStorageFileFilePath)){  //Throws SecurityException
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_FILE_WITH_IDENTICAL_NAME_EXISTS, userSpecifiedStorageFileName 
    				+ ".xml", userSpecifiedStorageFolder));
    	} 
    }
    
    private void setStorageCopyDataFromOldStorageFileToNewStorageFile(File oldStorageFile, File newStorageFile) throws IOException {
    	Files.copy(oldStorageFile, newStorageFile);  //Throws IOException
    }
    
	//Updates taskManagerFilePath attribute in Config instance, config
    private void setStorageUpdateTaskManagerFilePathInConfig(File newStorageFile) throws IOException {
    	config.setTaskManagerFilePath(newStorageFile.getCanonicalPath());  //Throws IOException
    }
    
    //Serializes Config instance, config to JSON file indicated by config.configFilePath, overwrites existing JSON file
    private void setStorageSerialiseConfigToConfigJsonFile() throws IOException {
    	ConfigUtil.saveConfig(config, config.getConfigFilePath());  //Throws IOException
    }
    
```
###### \java\seedu\address\model\task\Task.java
``` java
	public static final String MESSAGE_END_DATE_TIME_NOT_AFTER_START_DATE_TIME = "End date/ time cannot be after or equal to start date/ time.\n"
    				+ "Please re-enter command with valid start and end dates/ times.\n";
	
	public static final String MESSAGE_START_DATE_TIME_CANNOT_BE_SET_WITH_END_DATE_TIME_REMOVED = 
			"Start date/ time cannot be set with end date/ time removed.\n";
	
	public static final String MESSAGE_START_DATE_TIME_CANNOT_BE_SET_WITH_END_DATE_TIME_MISSING = 
			"End date/ time is missing, start date/ time cannot be set.\n";

```
###### \java\seedu\address\model\task\Task.java
``` java
    public static void validateEndDateTimeAfterStartDateTime(LocalDateTime startDateTime, LocalDateTime endDateTime){
    	if (!endDateTime.isAfter(startDateTime)){
    		throw new IllegalArgumentException(MESSAGE_END_DATE_TIME_NOT_AFTER_START_DATE_TIME);
    	}
    }
    
    private void validateDateTimeArgumentsWithTaskType(Optional<LocalDateTime> startDate, Optional<LocalDateTime> endDate, TaskType taskType){
    	if (startDate.isPresent() && taskType.value != TaskType.Type.EVENT) {
    		throw new IllegalArgumentException("Only events should have start dates");
    	}
    	
    	if (endDate.isPresent() && taskType.value == TaskType.Type.SOMEDAY) {
    		throw new IllegalArgumentException("Only events and deadlines should have end dates");
    	}
    }
```
