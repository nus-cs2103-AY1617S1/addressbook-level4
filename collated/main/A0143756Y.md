# A0143756Y
###### \java\seedu\address\commons\core\Config.java
``` java
    public String getAliasManagerFilePath() {
    	return aliasManagerFilePath;
    }
    
    public void setAliasManagerFilePath(String aliasManagerFilePath) {
    	this.aliasManagerFilePath = aliasManagerFilePath;
    }
```
###### \java\seedu\address\logic\commands\AddAliasCommand.java
``` java
/**
 * Sets alias for an existing command.
 * Command alias and corresponding command phrase will be saved to XML file, "aliasbook.xml" in ./data folder.
 */
public class AddAliasCommand extends Command {

    public static final String COMMAND_WORD = "add-alias";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
    		+ ": Sets alias for a phrase.\n"
    		+ "Parameters: 'ALIAS' = 'ORIGINAL_PHRASE'\n"
    		+ "Example: " + COMMAND_WORD + " 'add-dl' = 'add deadline'\n";
    
    public static final String MESSAGE_SUCCESS = "Alias '%s' set for phrase '%s'.\n";
    
    public static final String MESSAGE_DUPLICATE_ALIAS = "Alias already exists in the alias manager.\n";
    
    public static final String MESSAGE_INVALID_ALIAS = "Alias '%s' is invalid. Alias cannot be a sub-string or "
    		+ "a super-string of any previously set alias. Please re-enter command with a valid alias.\n";
    
    private final String alias; 
    
    private final String originalPhrase;
    
    public AddAliasCommand(String alias, String originalPhrase) {
    	this.alias = alias;
    	this.originalPhrase = originalPhrase;
    }

	@Override
    public CommandResult execute() {
    	EventsCenter.getInstance().post(new DisplayAliasListEvent(model.getFilteredAliasList()));

        assert model != null;
        model.saveState();
        
        try{
        	
        	if(!model.validateAliasforAddAliasCommand(alias)){
        		
        		model.undoSaveState();
        		return new CommandResult(String.format(MESSAGE_INVALID_ALIAS, alias));	
        		
        	}
        	
        	Alias aliasToAdd = new Alias(alias, originalPhrase);
        	model.addAlias(aliasToAdd); //Throws DuplicateAliasException
        	return new CommandResult(String.format(MESSAGE_SUCCESS, alias, originalPhrase));
        	
        } catch (DuplicateAliasException ex){
        	
        	model.loadPreviousState();
            return new CommandResult(String.format(MESSAGE_DUPLICATE_ALIAS));
            
        }
    }
}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    public static final String MESSAGE_START_DATE_TIME_AFTER_END_DATE_TIME = 
    		"Start of event is scheduled after end of event. Please re-enter correct start and end dates/times.\n";
    public static final String MESSAGE_START_DATE_TIME_EQUALS_END_DATE_TIME =
    		"Start of event equals end of event. Please re-enter correct start and end dates/times.\n";
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
    public static final String MESSAGE_START_DATE_TIME_AFTER_END_DATE_TIME = 
    		"Start of event is scheduled after end of event. Please re-enter correct start and end dates/times.\n";
    public static final String MESSAGE_START_DATE_TIME_EQUALS_END_DATE_TIME =
    		"Start of event equals end of event. Please re-enter correct start and end dates/times.\n";
```
###### \java\seedu\address\logic\commands\SetStorageCommand.java
``` java
/**
 * Sets task manager data storage location, according to user specifications.
 * Task manager data to be saved to user-specified folder, with user-specified file name.
 */
public class SetStorageCommand extends Command {

    public static final String COMMAND_WORD = "set-storage";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
    		+ ": Sets task manager data storage location, according to user specifications. "
    		+ "Task manager data to be saved to user-specified folder, with user-specified file name.\n"
    		+ "Parameters: FOLDER_FILE_PATH save-as FILE_NAME\n"
    		+ "Example: " + COMMAND_WORD + " C:\\Users\\Liang\\Desktop save-as TaskInformation\n";
    
    public static final String MESSAGE_SUCCESS = "Task manager data storage location set to: %s\n"
    		+ "Please exit and restart Amethyst for new storage settings to be registered.\n";
    
    public static final String MESSAGE_FOLDER_DOES_NOT_EXIST = "User-specified folder: %s does not exist.\n";
    
    public static final String MESSAGE_FOLDER_NOT_DIRECTORY = "User-specified folder: %s is not a folder.\n";
    
    public static final String MESSAGE_STORAGE_PREVIOUSLY_SET = "Task manager data storage location has previously been set to: %s\n";
    
    public static final String MESSAGE_FILE_WITH_IDENTICAL_NAME_EXISTS = "File with identical name %s exists in user-specified folder %s.\n"
    		+ "Program will not proceed to overwrite existing file.\n"
    		+ "Re-enter command with different file name.\n";
    
    public static final String MESSAGE_INVALID_PATH_EXCEPTION = "Invalid file path.\n";
    
    public static final String MESSAGE_IO_EXCEPTION = "Input/output operation failed/ interrupted.\n";
    
    public static final String MESSAGE_SECURITY_EXCEPTION = "Program not granted permission to access file(s).\n";
    
    private final String userSpecifiedStorageFolder; 
    
    private final String userSpecifiedStorageFileName;
    
    public SetStorageCommand(String userSpecifiedStorageFolder, String userSpecifiedStorageFileName) {
    	this.userSpecifiedStorageFolder = userSpecifiedStorageFolder;
    	this.userSpecifiedStorageFileName = userSpecifiedStorageFileName;
    }

	@Override
    public CommandResult execute() {
        assert model != null;
        
        model.saveState();
        
        try{
        	Pair<Path, Path> filePaths = model.validateSetStorage(userSpecifiedStorageFolder, userSpecifiedStorageFileName); //Throws InvalidPathException, SecurityException, IllegalArgumentException
        	
        	Path newStorageFileFilePath = filePaths.getKey();
        	
        	Path oldStorageFileFilePath = filePaths.getValue();
        	
        	model.setStorage(newStorageFileFilePath.toFile(), oldStorageFileFilePath.toFile()); //Throws IOException
        	
        	return new CommandResult(String.format(MESSAGE_SUCCESS, model.getTaskManagerStorageFilePath()));
        	
        } catch (InvalidPathException ex){
        	model.undoSaveState();
        	return new CommandResult(String.format(MESSAGE_INVALID_PATH_EXCEPTION));  	
        } catch (IOException ex){
        	model.undoSaveState();
        	return new CommandResult(MESSAGE_IO_EXCEPTION);    
        } catch (SecurityException ex){
        	model.undoSaveState();
        	return new CommandResult(MESSAGE_SECURITY_EXCEPTION);
        } catch (IllegalArgumentException ex){
        	model.undoSaveState();
        	return new CommandResult(ex.getMessage());
        }
    }
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private static final Pattern SET_STORAGE_ARGS_FORMAT = Pattern.compile
			("(?<folderFilePath>(\\s*[^\\s+])+)\\s+save-as\\s+(?<fileName>(\\s*[^\\s+])+)");
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Command prepareSetStorage(String arguments){
		final Matcher matcher = SET_STORAGE_ARGS_FORMAT.matcher(arguments.trim());
		
		if(!matcher.matches()){
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SetStorageCommand.MESSAGE_USAGE));
		}
		
		final String folderFilePath = matcher.group("folderFilePath").trim();
		final String fileName = matcher.group("fileName").trim();
		
		System.out.println("Folder File Path: " + folderFilePath);
		System.out.println("File Name: " + fileName);
		
		return new SetStorageCommand(folderFilePath, fileName);
	}

	private Optional<LocalDateTime> convertToLocalDateTime(Optional<String> dateTimeString) 
		throws ParseException{
		Optional<LocalDateTime> dateTime = Optional.empty();
		if(dateTimeString.isPresent()) {
			dateTime = Optional.of(DateParser.parse(dateTimeString.get()));
		} 
		return dateTime;
	}
	
	private boolean isToRemoveDateTime (Optional<String> dateTimeString) {
		if(dateTimeString.isPresent()) {
			if(dateTimeString.get().equals("-")) {
				return true;
			}
		}
		return false;
	}

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
     * Parses arguments in the context of the set alias task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAddAlias(String arguments) {
        final Matcher matcher = ADD_ALIAS_COMMAND_FORMAT.matcher(arguments.trim());
    	
    	if(!matcher.matches()){	
        	return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddAliasCommand.MESSAGE_USAGE));
        }
    	
    	final String alias = matcher.group("alias").trim();
    	final String originalPhrase = matcher.group("originalPhrase").trim();
        
        return new AddAliasCommand(alias, originalPhrase);
    }

```
###### \java\seedu\address\model\alias\Alias.java
``` java
public class Alias implements ReadOnlyAlias, Comparable<ReadOnlyAlias> {
	
	private String alias;
	private String originalPhrase;
	
	/**
	 * Constructor for Alias class given alias and originalPhrase Strings.
	 */
	
	public Alias(String alias, String originalPhrase) {
		assert alias != null;
		assert !alias.isEmpty();
		assert originalPhrase != null;
		assert !originalPhrase.isEmpty();
		
		this.alias = alias;
		this.originalPhrase = originalPhrase;
	}
	
	
	public Alias(ReadOnlyAlias readOnlyAlias){
		this(readOnlyAlias.getAlias(), readOnlyAlias.getOriginalPhrase());
	}
	
	/**
	 * Constructor for Alias class given readOnlyAlias.
	 */

    public String getAlias() {
        return alias;
    }

    public void setAlias(String alias) {
        this.alias = alias;
    }
    
    public String getOriginalPhrase() {
        return originalPhrase;
    }
    
    public void setOriginalPhrase(String originalPhrase) {
        this.originalPhrase = originalPhrase;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // Short circuit if same object
                || (other instanceof ReadOnlyAlias // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyAlias) other));
    }

    @Override
    public int hashCode() {
        // Use this method for custom fields hashing instead of implementing your own
        return Objects.hash(alias, originalPhrase);
    }

    @Override
    public String toString() {
        return getAsText();
    }

	@Override
	public int compareTo(ReadOnlyAlias other) {
		int statusCompare = this.getOriginalPhrase().compareTo(other.getOriginalPhrase());
		if (statusCompare != 0) {
			return statusCompare;
		}
		else {
			return this.getAlias().compareTo(other.getAlias());	
		}
	}
}
```
###### \java\seedu\address\model\alias\ReadOnlyAlias.java
``` java
/**
 * A read-only immutable interface for an Alias in the alias book.
 * Implementations should guarantee that 
 *
 */
public interface ReadOnlyAlias extends Comparable<ReadOnlyAlias> {

	public String getAlias();
	public String getOriginalPhrase();
	
    /**
     * Returns true if both have the same state. (Note that interfaces cannot override equals() method in Object class)
     */
    default boolean isSameStateAs(ReadOnlyAlias other) {
        return other == this // Short circuit if same object
                || (other != null // To avoid NullPointerException below
                && other.getAlias().equals(this.getAlias()) // State checks here onwards
                && other.getOriginalPhrase().equals(this.getOriginalPhrase()));
    }
    
    /**
     * Formats the alias as text, printing alias and originalPhrase.
     */
    default String getAsText() {
    	final StringBuilder builder = new StringBuilder();
    	
    	builder.append("Alias: " + getAlias() + ", ");
    	builder.append("Original phrase: " + getOriginalPhrase() + ".\n");

        return builder.toString();
    }
    
    public int compareTo(ReadOnlyAlias other);
}
```
###### \java\seedu\address\model\Model.java
``` java
    /** Returns TaskManagerStorageFilePath */
    String getTaskManagerStorageFilePath();

```
###### \java\seedu\address\model\Model.java
``` java
    /** Validates arguments passed to SetStorageCommand() method.
     * 	Returns newStorageFileFilePath (Path) and oldStorageFileFilePath (Path) if arguments are valid.
     */
    Pair<Path, Path> validateSetStorage(String userSpecifiedStorageFolder, String userSpecifiedStorageFileName);
    
    /** Sets task manager data storage location */    
    void setStorage(File newStorageFileFilePath, File oldStorageFileFilePath) throws IOException;

    /** Saves alias to XML file, "aliasbook.xml" in ./data folder. */
    void addAlias(Alias aliasToAdd) throws UniqueAliasList.DuplicateAliasException;
    
    /** Checks if alias argument for AddAliasCommand is valid. Alias cannot be a sub-string or super-string or any previously set alias. */
    boolean validateAliasforAddAliasCommand(String alias);    
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public String getTaskManagerStorageFilePath() {
    	return config.getTaskManagerFilePath();
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void addAlias(Alias aliasToAdd) throws UniqueAliasList.DuplicateAliasException {
    	assert aliasToAdd != null;
    	
    	aliasManager.addAlias(aliasToAdd);
    	indicateAliasManagerChanged();
    }
    
    @Override
    public synchronized boolean validateAliasforAddAliasCommand(String alias) {
    	assert alias != null;
    	assert !alias.isEmpty();
    	
    	ObservableList<Alias> aliasList = aliasManager.getInternalList();
    	for(Alias currentAlias: aliasList){
    		if(currentAlias.getAlias().contains(alias) || alias.contains(currentAlias.getAlias())){
    			return false;
    		}
    	}
    	
    	return true;
    }
    
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized Pair<Path, Path> validateSetStorage(String userSpecifiedStorageFolder, String userSpecifiedStorageFileName) 
    		throws InvalidPathException, SecurityException, IllegalArgumentException {	
    	Path newStorageFolderFilePath = Paths.get(userSpecifiedStorageFolder);  //Throws InvalidPathException
    	
    	if(java.nio.file.Files.notExists(newStorageFolderFilePath)){  //Throws SecurityException
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_FOLDER_DOES_NOT_EXIST, userSpecifiedStorageFolder)); 
    	} 
    	
    	if(!java.nio.file.Files.isDirectory(newStorageFolderFilePath)){  //Throws SecurityException
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_FOLDER_NOT_DIRECTORY, userSpecifiedStorageFolder)); 
    	}        	        	        	
    	
    	Path newStorageFileFilePath = newStorageFolderFilePath.resolve(userSpecifiedStorageFileName +".xml");  //Throws InvalidPathException
    	
    	Path oldStorageFileFilePath = Paths.get(getTaskManagerStorageFilePath());  //Throws InvalidPathException
    	
    	if(newStorageFileFilePath.equals(oldStorageFileFilePath)){
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_STORAGE_PREVIOUSLY_SET, oldStorageFileFilePath.toString())); 
    	} 
    	
    	if(java.nio.file.Files.exists(newStorageFileFilePath)){  //Throws SecurityException
    		throw new IllegalArgumentException(String.format(SetStorageCommand.MESSAGE_FILE_WITH_IDENTICAL_NAME_EXISTS, userSpecifiedStorageFileName 
    				+ ".xml", userSpecifiedStorageFolder));
    	} 
    	
    	return new Pair<Path, Path>(newStorageFileFilePath, oldStorageFileFilePath);
    }
    
    @Override
    public synchronized void setStorage(File newStorageFile, File oldStorageFile) throws IOException{
    	assert newStorageFile!= null;
    	assert oldStorageFile!= null;
    	assert !newStorageFile.equals(oldStorageFile);
    	
    	Files.copy(oldStorageFile, newStorageFile);  //Throws IOException
    	
    	//Updates taskManagerFilePath attribute in Config instance, config
    	config.setTaskManagerFilePath(newStorageFile.getCanonicalPath());  //Throws IOException
    	
    	//Serializes Config instance, config to JSON file indicated by config.configFilePath, overwrites existing JSON file
    	ConfigUtil.saveConfig(config, config.getConfigFilePath());  //Throws IOException
    }
```
