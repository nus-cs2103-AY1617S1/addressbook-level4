# A0146123R
###### /java/seedu/toDoList/commons/events/storage/RedoStoragePathChangedEvent.java
``` java
/**
 * Indicates the change for the storage file path should be redone.
 */
public class RedoStoragePathChangedEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/toDoList/commons/events/storage/StoragePathChangedEvent.java
``` java
/**
 * Indicates the storage path is changed to a new path.
 */
public class StoragePathChangedEvent extends BaseEvent {

    private String newStorageFilePath;
    private boolean isToClearOld;

    public StoragePathChangedEvent(String newStorageFilePath, boolean isToClearOld) {
        assert newStorageFilePath != null;

        this.newStorageFilePath = newStorageFilePath;
        this.isToClearOld = isToClearOld;
    }

    public String getNewStorageFilePath() {
        return newStorageFilePath;
    }

    public Boolean isToClearOld() {
        return isToClearOld;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/toDoList/commons/events/storage/StoragePathEvent.java
``` java
/**
 * Indicates a change for the storage file path. It could be changed to a new
 * path or undone or redone the change.
 */
public class StoragePathEvent extends BaseEvent {

    private String newStorageFilePath;

    public StoragePathEvent(String newStorageFilePath) {
        assert newStorageFilePath != null;
        this.newStorageFilePath = newStorageFilePath;
    }

    public String getNewStorageFilePath() {
        return newStorageFilePath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/toDoList/commons/events/storage/UndoStoragePathChangedEvent.java
``` java
/**
 * Indicates the storage file path should be changed back.
 */
public class UndoStoragePathChangedEvent extends BaseEvent {

    private boolean isToClearNew;

    public UndoStoragePathChangedEvent(boolean isToClearNew) {
        this.isToClearNew = isToClearNew;
    }

    public boolean isToClearNew() {
        return isToClearNew;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/toDoList/commons/events/ui/FilterPanelChangedEvent.java
``` java
/**
 * Represents a change in the Filter Panel.
 */
public class FilterPanelChangedEvent extends BaseEvent {

    private final Set<Types> types;
    private final Map<Types, String> qualifications;
    private final Set<String> tags;

    public FilterPanelChangedEvent(Set<Types> types, Map<Types, String> qualifications, Set<String> tags) {
        this.types = types;
        this.qualifications = qualifications;
        this.tags = tags;
    }

    public Set<Types> getTypes() {
        return types;
    }

    public Map<Types, String> getQualifications() {
        return qualifications;
    }

    public Set<String> getTags() {
        return tags;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/toDoList/commons/events/ui/JumpToFilterPanelEvent.java
``` java
/**
 * Indicates a request to jump to the filter panel.
 */
public class JumpToFilterPanelEvent extends BaseEvent {
    
    private final Types attribute;
    
    public JumpToFilterPanelEvent(Types deadline) {
        this.attribute = deadline;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public Types getAttribute() {
        return attribute;
    }
}
```
###### /java/seedu/toDoList/commons/events/ui/UpdateFilterPanelEvent.java
``` java
/**
 * Represents a change in the filtered tasks in model that requires the Filter
 * Panel to update correspondingly.
 */
public class UpdateFilterPanelEvent extends BaseEvent {

    private final Set<Types> types;
    private final Map<Types, String> qualifications;
    private final Set<String> tags;

    public UpdateFilterPanelEvent(Set<Types> types, Map<Types, String> qualifications, Set<String> tags) {
        this.types = types;
        this.qualifications = qualifications;
        this.tags = tags;
    }

    public Set<Types> getTypes() {
        return types;
    }

    public Map<Types, String> getQualifications() {
        return qualifications;
    }

    public Set<String> getTags() {
        return tags;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/toDoList/commons/exceptions/StateLimitException.java
``` java
/**
 * Signals an error caused by no more states to get. 
 */
public class StateLimitException extends Exception{
    
}
```
###### /java/seedu/toDoList/commons/util/DateUtil.java
``` java
/**
 * Utility methods related to Date.
 */
public class DateUtil {

    private static final String DATE_VALIDATION_REGEX = "^[0-3][0-9].[0-1][0-9].([0-9]{4})(-[0-2]?[0-9]?)?";
    // EXAMPLE = "15.10.2016-14"

    private static final DateFormat dateFormat = new SimpleDateFormat("dd.MM.yyyy");
    private static final DateFormat dateTimeFormat = new SimpleDateFormat("dd.MM.yyyy-HH");
    private static final DateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM)
            .withLocale(Locale.GERMAN);
    private static final String TIME_SEPERATOR = "-";

    /**
     * Returns true if the given string is in a valid date format.
     */
    public static boolean isValidDateFormat(String test) {
        return test.matches(DATE_VALIDATION_REGEX);
    }

    /**
     * Returns true if the given string is an empty deadline.
     */
    public static boolean isEmptyDate(String test) {
        return test.isEmpty();
    }

    /**
     * Parse the given date.
     * 
     * @return a String that represents a valid date (i.e. if the user input
     *         31.04.2016, it will be corrected to 01.05.2016)
     * @throws IndexOutOfBoundsException
     *             if the given date cannot be parsed
     */
    public static String parseDate(String date) throws IndexOutOfBoundsException {
        if (isDateFormat(date)) {
            try {
                return dateFormat.format(dateFormat.parse(date));
            } catch (ParseException e) {
                return parseNotFormattedDate(date);
            }
        }
        try {
            return dateTimeFormat.format(dateTimeFormat.parse(date));
        } catch (ParseException e) {
            return parseNotFormattedDate(date);
        }
    }

```
###### /java/seedu/toDoList/commons/util/Types.java
``` java
/**
 * A container for types and attributes variables.
 */
public enum Types {
    EVENTS, TASKS, DONE, UNDONE, START_DATE, END_DATE, DEADLINE, RECURRING, TAG, PRIORITY_LEVEL, INVALID
}
```
###### /java/seedu/toDoList/logic/commands/AddCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Add an event with a starting and ending date or a task (with or without deadline) to the toDoList.\n"
            + "Parameters: n/EVENT_NAME s/START_DATE e/END_DATE [r/RECURRING_FREQUENCY] [p/PRIORITY_LEVEL] [t/TAG]...\n"
            + "or n/TASK_NAME [d/DEADLINE] [r/RECURRING_FREQUENCY] [p/PRIORITY_LEVEL] [t/TAG]...\n" + "Example: "
            + COMMAND_WORD
            + " n/Lecture s/7.10.2016-14 e/7.10.2016-16 r/weekly p/1 t/CS2103, add n/Project Deadline d/14.10.2016 p/3 t/CS2103";

    public static final String MESSAGE_EVENT_SUCCESS = "New event added: %1$s";
    public static final String MESSAGE_TASK_SUCCESS = "New task added: %1$s";

    private final Task toAdd;

```
###### /java/seedu/toDoList/logic/commands/ChangeCommand.java
``` java
/**
 * Changes the default storage location of the task manager.
 */
public class ChangeCommand extends Command {

    public static final String COMMAND_WORD = "change";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Change the default storage location to the specified location (must end with the file type extension, .xml)"
            + " and clear data saved in the previous location if specified.\n" + "Parameters: FILE_PATH [clear]\n"
            + "Example: " + COMMAND_WORD + " /Desktop/folder/toDoList.xml clear";

    public static final String MESSAGE_CHANGE_SUCCESS = "Storage location changed: %1$s";
    public static final String MESSAGE_INVALID_FILE_PATH = "The file path provided is invalid."
            + " It must end with the file type extension, .xml";
    public static final String MESSAGE_INVALID_CLEAR_DATA = "The clear data argument provided is invalid."
            + " It must be absent or \"clear\".";

    private static final String CLEAR = "clear";
    private static final String EMPTY = "";
    private static final String XML = ".xml";

    private final String filePath;
    private final String clear;
    private final boolean isToClearOld;

    /**
     * Convenience constructor using raw values.
     */
    public ChangeCommand(String filePath, String clear) {
        this.filePath = filePath;
        this.clear = clear;
        this.isToClearOld = true;
    }

    public ChangeCommand(String filePath) {
        this.filePath = filePath;
        this.clear = EMPTY;
        this.isToClearOld = false;
    }

    @Override
    public CommandResult execute() {
        assert filePath != null;
        assert clear != null;

        if (!isValidPath(filePath)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_FILE_PATH);
        }
        if (!isValidClear(clear)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_CLEAR_DATA);
        }
        model.updateTaskManagerToPath(filePath, isToClearOld);
        return new CommandResult(String.format(MESSAGE_CHANGE_SUCCESS, filePath));
    }

    /**
     * Returns true if the given path is a valid path
     */
    private boolean isValidPath(String path) {
        try {
            Paths.get(path);
            return isXml(path);
        } catch (InvalidPathException e) {
            return false;
        }
    }

    /**
     * Returns true if the given path ends with the file type extension, .xml.
     */
    private static boolean isXml(String path) {
        return path.endsWith(XML);
    }

    /**
     * Returns true if the given clear data argument is valid.
     */
    private static boolean isValidClear(String clear) {
        return clear.isEmpty() || clear.equals(CLEAR);
    }

}
```
###### /java/seedu/toDoList/logic/commands/FilterCommand.java
``` java
/**
 * Filter the list by given attributes.
 */
public class FilterCommand extends Command {

    public static final String COMMAND_WORD = "filter";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Filter list for specified attributes "
            + "and displays them as a list with index numbers.\n"
            + "Parameters: [s/START_DATE] [e/END_DATE] [d/DEADLINE] [r/RECURRING] [p/PRIORITY] [t/TAG]...\n"
            + "Example: " + COMMAND_WORD + " s/today r/daily";

    private final Optional<String> deadline;
    private final Optional<String> startDate;
    private final Optional<String> endDate;
    private final Optional<String> recurring;
    private final Set<String> tags;
    private final Optional<String> priority;

    /**
     * Convenience constructor using raw values.
     */
    public FilterCommand(Optional<String> deadline, Optional<String> startDate, Optional<String> endDate,
            Optional<String> recurring, Set<String> tags, Optional<String> priority) {
        this.deadline = deadline;
        this.startDate = startDate;
        this.endDate = endDate;
        this.recurring = recurring;
        this.tags = tags;
        this.priority = priority;
    }

    @Override
    public CommandResult execute() {
        Map<Types, String> filterQualifications = new HashMap<>();
        try {
            prepareDeadline(filterQualifications);
            prepareStartDate(filterQualifications);
            prepareEndDate(filterQualifications);
            prepareRecurring(filterQualifications);
            preparePriority(filterQualifications);
        } catch (IllegalValueException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(e.getMessage());
        }
        model.updateFilteredTaskListByQualifications(filterQualifications, tags);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

    /**
     * Parse the given deadline qualification.
     * 
     * @throws IllegalValueException
     *             if it is invalid
     */
    private void prepareDeadline(Map<Types, String> qualifications) throws IllegalValueException {
        if (deadline.isPresent()) {
            String deadlineString = Deadline.getValidDate(deadline.get());
            qualifications.put(Types.DEADLINE, deadlineString);
        }
    }

    /**
     * Parse the given start date qualification.
     * 
     * @throws IllegalValueException
     *             if it is invalid
     */
    private void prepareStartDate(Map<Types, String> qualifications) throws IllegalValueException {
        if (startDate.isPresent()) {
            String startDateString = EventDate.getValidDate(startDate.get());
            qualifications.put(Types.START_DATE, startDateString);
        }
    }

    /**
     * Parse the given end date qualification.
     * 
     * @throws IllegalValueException
     *             if it is invalid
     */
    private void prepareEndDate(Map<Types, String> qualifications) throws IllegalValueException {
        if (endDate.isPresent()) {
            String endDateString = EventDate.getValidDate(endDate.get());
            qualifications.put(Types.END_DATE, endDateString);
        }
    }

    /**
     * Parse the given priority qualification.
     * 
     * @throws IllegalValueException
     *             if it is invalid
     */
    private void prepareRecurring(Map<Types, String> qualifications) throws IllegalValueException {
        if (recurring.isPresent()) {
            if (Recurring.isValidFrequency(recurring.get())) {
                qualifications.put(Types.RECURRING, recurring.get());
            } else {
                throw new IllegalValueException(Recurring.MESSAGE_RECURRING_CONSTRAINTS);
            }
        }
    }

```
###### /java/seedu/toDoList/logic/commands/FindCommand.java
``` java
/**
 * Finds and lists all items in toDoList whose names contain any of the
 * argument keywords or all of the argument keywords. Keyword matching is not
 * case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Case-insensitive. By default, finds all items with names containing any of "
            + "the specified keywords and the matching will only compare word stems of keywords.\n"
            + "Only items matching the exact keyword will be returned if the command contains the exact! parameter.\n"
            + "Only items matching both groups of keywords will be returned if the two groups of keywords are connected by AND.\n"
            + "Parameters: KEYWORD [AND] [MORE_KEYWORDS] [exact!]\n" 
            + "Example: " + COMMAND_WORD + " horror night, " + COMMAND_WORD + " horror AND night exact!";

    private final Set<Set<String>> keywordsGroups;
    private final boolean isExactSearch;

    /**
     * Convenience constructor using raw values.
     */
    public FindCommand(Set<Set<String>> keywordsGroups, boolean isExactSearch) {
        this.keywordsGroups = keywordsGroups;
        this.isExactSearch = isExactSearch;
    }

    @Override
    public CommandResult execute() {
        if (isExactSearch) {
            model.updateFilteredTaskListWithKeywords(keywordsGroups);
        } else {
            model.updateFilteredTaskListWithStemmedKeywords(keywordsGroups);
        }
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/toDoList/logic/commands/JumpToDeadlineCommand.java
``` java
/**
 * Jumps to the deadline text field in filter panel.
 */
public class JumpToDeadlineCommand extends Command {
    
    public static final String COMMAND_WORD = "d";
    
    public static final String MESSAGE_JUMP_ACKNOWLEDGEMENT = "Enter deadline:";
    
    public JumpToDeadlineCommand() {}

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new JumpToFilterPanelEvent(Types.DEADLINE));
        return new CommandResult(MESSAGE_JUMP_ACKNOWLEDGEMENT);
    }

}
```
###### /java/seedu/toDoList/logic/commands/JumpToEndDateCommand.java
``` java
/**
 * Jumps to the end date text field in filter panel.
 */
public class JumpToEndDateCommand extends Command {
    
    public static final String COMMAND_WORD = "e";
    
    public static final String MESSAGE_JUMP_ACKNOWLEDGEMENT = "Enter end date:";
    
    public JumpToEndDateCommand() {}

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new JumpToFilterPanelEvent(Types.END_DATE));
        return new CommandResult(MESSAGE_JUMP_ACKNOWLEDGEMENT);
    }

}
```
###### /java/seedu/toDoList/logic/commands/JumpToPriorityCommand.java
``` java
/**
 * Jumps to the priority choice box in filter panel.
 */
public class JumpToPriorityCommand extends Command {
    
    public static final String COMMAND_WORD = "p";
    
    public static final String MESSAGE_JUMP_ACKNOWLEDGEMENT = "Select priority:";
    
    public JumpToPriorityCommand() {}

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new JumpToFilterPanelEvent(Types.PRIORITY_LEVEL));
        return new CommandResult(MESSAGE_JUMP_ACKNOWLEDGEMENT);
    }

}
```
###### /java/seedu/toDoList/logic/commands/JumpToRecurringCommand.java
``` java
/**
 * Jumps to the recurring text field in filter panel.
 */
public class JumpToRecurringCommand extends Command {
    
    public static final String COMMAND_WORD = "r";
    
    public static final String MESSAGE_JUMP_ACKNOWLEDGEMENT = "Enter recurring frequency:";

    public JumpToRecurringCommand() {}

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new JumpToFilterPanelEvent(Types.RECURRING));
        return new CommandResult(MESSAGE_JUMP_ACKNOWLEDGEMENT);
    }

}
```
###### /java/seedu/toDoList/logic/commands/JumpToStartDateCommand.java
``` java
/**
 * Jumps to the start date text field in filter panel.
 */
public class JumpToStartDateCommand extends Command {
    
    public static final String COMMAND_WORD = "s";
    
    public static final String MESSAGE_JUMP_ACKNOWLEDGEMENT = "Enter start date:";
    
    public JumpToStartDateCommand() {}

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new JumpToFilterPanelEvent(Types.START_DATE));
        return new CommandResult(MESSAGE_JUMP_ACKNOWLEDGEMENT);
    }

}
```
###### /java/seedu/toDoList/logic/commands/JumpToTagCommand.java
``` java
/**
 * Jumps to the tag text field in filter panel.
 */
public class JumpToTagCommand extends Command {
    
    public static final String COMMAND_WORD = "t";
    
    public static final String MESSAGE_JUMP_ACKNOWLEDGEMENT = "Enter tags:";
    
    public JumpToTagCommand() {}

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new JumpToFilterPanelEvent(Types.TAG));
        return new CommandResult(MESSAGE_JUMP_ACKNOWLEDGEMENT);
    }

}
```
###### /java/seedu/toDoList/logic/commands/RedoChangeCommand.java
``` java
/**
 * Redoes change the storage location of the toDoList.
 */
public class RedoChangeCommand extends Command {

    public static final String COMMAND_WORD = "redochange";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Redo change the default storage location to the new location" 
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_CHANGE_SUCCESS = "Storage location changed.";
    public static final String MESSAGE_REDO_FAILED = "No undo change command to redo.";

    @Override
    public CommandResult execute() {
        try {
            model.redoUpdateTaskManagerPath();
            return new CommandResult(MESSAGE_CHANGE_SUCCESS);
        } catch (StateLimitException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_REDO_FAILED);
        }
    }

}
```
###### /java/seedu/toDoList/logic/commands/RedoCommand.java
``` java
/**
 * Redoes the most recent action that is undone.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_REDO_SUCCESS = "Redid the most recent action that is undone.\n%1$s";
    public static final String MESSAGE_REDO_FAILED = "No command to redo.";

    @Override
    public CommandResult execute() {
        try {
            String message = model.getNextState();
            return new CommandResult(String.format(MESSAGE_REDO_SUCCESS, message));
        } catch (StateLimitException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_REDO_FAILED);
        }
    }

}
```
###### /java/seedu/toDoList/logic/commands/UndoChangeCommand.java
``` java
/**
 * Undoes change the storage location of the toDoList.
 */
public class UndoChangeCommand extends Command {

    public static final String COMMAND_WORD = "undochange";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Change the default storage location back to the previous location"
            + " and clear data saved in the current location if specified.\n" 
            + "Parameters: [clear]\n"
            + "Example: " + COMMAND_WORD + " clear";

    public static final String MESSAGE_CHANGE_SUCCESS = "Storage location changed back.";
    public static final String MESSAGE_UNDO_FAILED = "No change command to undo.";
    public static final String MESSAGE_INVALID_CLEAR_DATA = "The clear data argument provided is invalid."
            + " It must be abscent or \"clear\".";

    private static final String CLEAR = "clear";

    private final String clear;
    private final boolean isToClearNew;

    /**
     * Convenience constructor using raw values.
     */
    public UndoChangeCommand(String clear) {
        this.clear = clear.trim();
        this.isToClearNew = !clear.isEmpty();
    }

    @Override
    public CommandResult execute() {
        assert clear != null;

        if (!isValidClear(clear)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_CLEAR_DATA);
        }
        try {
            model.changeBackTaskManagerPath(isToClearNew);
            return new CommandResult(MESSAGE_CHANGE_SUCCESS);
        } catch (StateLimitException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_UNDO_FAILED);
        }
    }

    /**
     * Returns true if the given clear data argument is valid.
     */
    private static boolean isValidClear(String clear) {
        return clear.isEmpty() || clear.equals(CLEAR);
    }

}
```
###### /java/seedu/toDoList/logic/commands/UndoCommand.java
``` java
/**
 * Undoes the most recent action (up to 10 times).
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_UNDO_SUCCESS = "Undid the most recent action.";
    public static final String MESSAGE_UNDO_FAILED = "No command to undo.";

    @Override
    public CommandResult execute() {
        try {
            model.getPreviousState();
            return new CommandResult(MESSAGE_UNDO_SUCCESS);
        } catch (StateLimitException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_UNDO_FAILED);
        }
    }

}
```
###### /java/seedu/toDoList/logic/parser/Parser.java
``` java
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if ( ! matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // Group keywords by AND operator
        final String[] keywords = matcher.group("keywords").split("AND");
        final Set<Set<String>> keywordsGroup = new HashSet<Set<String>>();
        for (String keyword : keywords) {
            // keywords delimited by whitespace
            keywordsGroup.add(new HashSet<>(Arrays.asList(keyword.trim().split("\\s+"))));
        }
        return new FindCommand(keywordsGroup, matcher.group("keywords").contains("exact!"));
    }

```
###### /java/seedu/toDoList/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the change storage location command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareChange(String arguments) {
        final String[] args = arguments.trim().split("\\s+");
        final int defaultLength = 1;
        final int clearLength = 2;
        final int filePath = 0;
        final int clear = 1;
        if (( args.length != defaultLength && args.length != clearLength ) || args[filePath].isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeCommand.MESSAGE_USAGE));
        }
        if (args.length == defaultLength) {
            return new ChangeCommand(args[filePath]);
        } else {
            return new ChangeCommand(args[filePath], args[clear]);
        }
    }

    /**
     * Parses arguments in the context of the filter attributes command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFilter(String arguments) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(deadlinePrefix, startDatePrefix, endDatePrefix,
                recurringPrefix, tagPrefix, priorityPrefix);
        argsTokenizer.tokenize(arguments);
        Optional<String> deadline = argsTokenizer.getValue(deadlinePrefix);
        Optional<String> startDate = argsTokenizer.getValue(startDatePrefix);
        Optional<String> endDate = argsTokenizer.getValue(endDatePrefix);
        Optional<String> recurring = argsTokenizer.getValue(recurringPrefix);
        Optional<List<String>> tags = argsTokenizer.getAllValues(tagPrefix);
        Optional<String> priority = argsTokenizer.getValue(priorityPrefix);
        if (deadline.isPresent() || startDate.isPresent() || endDate.isPresent() || recurring.isPresent()
                || tags.isPresent() || priority.isPresent()) {
            return new FilterCommand(deadline, startDate, endDate, recurring, toSet(tags), priority);
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FilterCommand.MESSAGE_USAGE));
    }

```
###### /java/seedu/toDoList/MainApp.java
``` java
    /**
     * Updates config file when storage file path is changed.
     */
    @Subscribe
    public void handleStoragePathChangedEvent(StoragePathEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));

        this.config.setTaskManagerFilePath(event.getNewStorageFilePath());
        try {
            ConfigUtil.saveConfig(config, configFilePathUsed);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
    }
```
###### /java/seedu/toDoList/model/Model.java
``` java
    /** Updates the filter of the filtered task list to filter by the given type. */
    void updateFilteredTaskListByType(Types type);

    /** Updates the filter of the filtered task list to filter by multiple qualifications. */
    void updateFilteredTaskListByQualifications(Map<Types, String> qualifications, Set<String> tags);
    
    /** Updates the filter of the filtered task list to filter by multiple types and qualifications. */
    void updateFilteredTaskListByTypesAndQualifications(Set<Types> types, Map<Types, String> qualifications,
            Set<String> tags);

    /** 
     * Updates the filter of the filtered task list to filter by the the given 
     * keywords (for find command).
     */
    void updateFilteredTaskListWithKeywords(Set<Set<String>> keywordsGroups);

    /**
     * Updates the filter of the filtered task list to filter by the stemmed
     * words of the given keywords (for find command). (Stemming is the process
     * of reducing inflected (or sometimes derived) words to their word stem.
     * Example: "stems", "stemmer", "stemming", "stemmed" as based on "stem")
     */
    void updateFilteredTaskListWithStemmedKeywords(Set<Set<String>> keywordsGroups);

    /**
     * Updates the task manager to the new file path and deletes the data file
     * in the previous file path if it is specified.
     */
    void updateTaskManagerToPath(String filePath, boolean isToClearOld);

    /**
     * Changes the task manager back to the old file path and deletes the data
     * file in the new file path if it is specified.
     * 
     * @throws StateLimitException
     */
    void changeBackTaskManagerPath(boolean isToClearNew) throws StateLimitException;

    /**
     * Redoes update the task manager to the new file path and deletes the data
     * file in the previous file path if it was specified.
     * 
     * @throws StateLimitException
     */
    void redoUpdateTaskManagerPath() throws StateLimitException;

    /** Saves the current state of the task manager. */
    void saveState(String message);

    /**
     * Changes the task manager to the previous state.
     * 
     * @return String message
     * @throws StateLimitException
     */
    String getPreviousState() throws StateLimitException;

    /**
     * Updates the task manager to the next state.
     * 
     * @return String message
     * @throws StateLimitException
     */
    String getNextState() throws StateLimitException;

    /**
     * Updates the filter of the filter task list so it will correspond to
     * changes in the filter panel.
     */
    void handleFilterPanelChangedEvent(FilterPanelChangedEvent abce);

```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    @Override
    public void updateTaskManagerToPath(String filePath, boolean isToClearOld) {
        stateManager.saveFilePath(filePath, isToClearOld);
        indicateTaskManagerChanged();
    }

    @Override
    public void changeBackTaskManagerPath(boolean isToClearNew) throws StateLimitException {
        stateManager.setPreviousFilePath(isToClearNew);
        indicateTaskManagerChanged();
    }

    @Override
    public void redoUpdateTaskManagerPath() throws StateLimitException {
        stateManager.setNextFilePath();
        indicateTaskManagerChanged();
    }

    @Override
    public void saveState(String message) {
        stateManager.saveState(new TaskManagerState(taskManager, message));
    }

    @Override
    public String getPreviousState() throws StateLimitException {
        TaskManagerState previousState = stateManager.getPreviousState();
        return getState(previousState);
    }

    @Override
    public String getNextState() throws StateLimitException {
        TaskManagerState nextState = stateManager.getNextState();
        return getState(nextState);
    }

    private String getState(TaskManagerState state) {
        resetData(state.getTaskManager());
        return state.getMessage();
    }
```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
        raise(new UpdateFilterPanelEvent(new HashSet<Types>(), new HashMap<Types, String>(), new HashSet<String>()));
    }
```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListByQualifications(Map<Types, String> qualifications, Set<String> tags) {
        updateFilteredTaskListAndOperation(getPredicateForMultipleQualifications(qualifications, tags));
        raise(new UpdateFilterPanelEvent(new HashSet<Types>(), qualifications, tags));
    }

    private ArrayList<Expression> getPredicateForMultipleQualifications(Map<Types, String> qualifications,
            Set<String> tags) {
        ArrayList<Expression> predicate = new ArrayList<>();
        qualifications.forEach((attribute, keyword) -> predicate.add(getPredicateForAttribute(attribute, keyword)));
        if (!tags.isEmpty()) {
            predicate.add(getPredicateForTags(tags));
        }
        return predicate;
    }

    private Expression getPredicateForAttribute(Types attribute, String keyword) {
        switch (attribute) {
        case START_DATE:
        case DEADLINE:
        case END_DATE:
            return new PredicateExpression(new DateQualifier(keyword, attribute));
        case RECURRING:
            return new PredicateExpression(new RecurringQualifier(keyword));
        case PRIORITY_LEVEL:
            return new PredicateExpression(new PriorityQualifier(Integer.parseInt(keyword)));
        default:
            assert false;
            return null;
        }
    }

    private Expression getPredicateForTags(Set<String> keyword) {
        return new PredicateExpression(new TagQualifier(keyword));
    }

    @Override
    public void updateFilteredTaskListByTypesAndQualifications(Set<Types> types, Map<Types, String> qualifications,
            Set<String> tags) {
        ArrayList<Expression> predicate = getPredicateForMultipleQualifications(qualifications, tags);
        types.forEach(type -> predicate.add(getPredicateForType(type)));
        updateFilteredTaskListAndOperation(predicate);
    }

    @Override
    public void updateFilteredTaskListWithKeywords(Set<Set<String>> keywordsGroups) {
        ArrayList<Expression> predicate = new ArrayList<>();
        for (Set<String> keywords : keywordsGroups) {
            predicate.add(new PredicateExpression(new NameQualifier(keywords)));
        }
        updateFilteredTaskListAndOperation(predicate);
    }

    @Override
    public void updateFilteredTaskListWithStemmedKeywords(Set<Set<String>> keywordsGroups) {
        ArrayList<Expression> predicate = new ArrayList<>();
        for (Set<String> keywords : keywordsGroups) {
            predicate.add(new PredicateExpression(new StemmedNameQualifier(keywords)));
        }
        updateFilteredTaskListAndOperation(predicate);
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    private void updateFilteredTaskListAndOperation(ArrayList<Expression> expression) {
        Predicate<? super Task> predicate;
        Predicate<Task> predicates = task -> true;
        for (Expression e : expression) {
            predicate = task -> e.satisfies(task);
            predicates = predicates.and(predicate);
        }
        filteredTasks.setPredicate(predicates);
    }

    @Subscribe
    @Override
    public void handleFilterPanelChangedEvent(FilterPanelChangedEvent event) {
        updateFilteredTaskListByTypesAndQualifications(event.getTypes(), event.getQualifications(), event.getTags());
    }
```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    private class StemmedNameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        StemmedNameQualifier(Set<String> nameKeyWords) {
            Stemmer stemmer = new Stemmer();
            this.nameKeyWords = nameKeyWords.stream().map(keyword -> stemmer.stem(keyword)).collect(Collectors.toSet());
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            Set<String> taskName = getTaskName(task);
            Stemmer stemmer = new Stemmer();
            return nameKeyWords.stream()
                    .filter(keyword -> taskName.stream().map(name -> stemmer.stem(name))
                            .filter(name -> name.equals(keyword)).count() > 0)
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "stemmed name=" + String.join(", ", nameKeyWords);
        }

        private Set<String> getTaskName(ReadOnlyTask task) {
            String[] taskName = task.getName().taskName.split("\\s+");
            return new HashSet<>(Arrays.asList(taskName));
        }
    }

```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private final String TIME_SEPERATOR = "-";
        private final int DAY = 0;

        private String dateValue;
        private Types dateType;
        private boolean isEvent;
        private boolean isDay;

        DateQualifier(String dateValue, Types dateType) {
            assert dateValue != null;
            this.dateValue = dateValue.trim();
            this.dateType = dateType;
            this.isEvent = dateType.equals(Types.DEADLINE) ? false : true;
            this.isDay = DateUtil.isDateFormat(this.dateValue);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.isEvent() == isEvent) {
                String date;
                switch (dateType) {
                case START_DATE:
                    date = ((EventDate) task.getDate()).getStartDate();
                    break;
                case END_DATE:
                    date = ((EventDate) task.getDate()).getEndDate();
                    break;
                case DEADLINE:
                    date = task.getDate().getValue();
                    break;
                default:
                    assert false;
                    return false;
                }
                return isDay ? dateValue.equals(getDay(date)) : dateValue.equals(date);
            }
            return false;
        }

        @Override
        public String toString() {
            return "date type=" + dateType + " date=" + dateValue;
        }

        private String getDay(String date) {
            return date.split(TIME_SEPERATOR)[DAY];
        }
    }

```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    private class TagQualifier implements Qualifier {
        private Set<String> tagKeyWords;

        TagQualifier(Set<String> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagKeyWords.stream().filter(keyword -> {
                try {
                    return task.getTags().contains(new Tag(keyword));
                } catch (IllegalValueException e) {
                    return false;
                }
            }).findAny().isPresent();
        }

        @Override
        public String toString() {
            return "tags=" + String.join(", ", tagKeyWords);
        }
    }

```
###### /java/seedu/toDoList/model/state/State.java
``` java
/**
 * The API of the State component.
 */
public interface State {

    /** Saves the current state of the task manager. */
    public void saveState(TaskManagerState state);

    /** Gets the previous state of the task manager. */
    public TaskManagerState getPreviousState() throws StateLimitException;

    /** Gets the next state of the task manager. */
    public TaskManagerState getNextState() throws StateLimitException;

    /** Saves and sets the file path of the task manager. */
    public void saveFilePath(String filePath, boolean isToClearOld);

    /** Sets the task manager to the previous file path. */
    public void setPreviousFilePath(boolean isToClearNew) throws StateLimitException;

    /** Sets the task manager to the next file path. */
    public void setNextFilePath() throws StateLimitException;

}
```
###### /java/seedu/toDoList/model/state/StateManager.java
``` java
/**
 * Saves the states of the task manager.
 */
public class StateManager extends ComponentManager implements State {

    private static final int MAX = 10; // Undo/Redo up to 10 times
    private static final int MIN = 1;

    private TaskManagerState currentState;
    private LinkedList<TaskManagerState> undoStates;
    private LinkedList<TaskManagerState> redoStates;

    private int undoFilePathAvailable;
    private int redoFilePathAvailable;

    /**
     * Initializes a StateManager with the given TaskManagerState.
     * TaskManagerState should not be null.
     */
    public StateManager(TaskManagerState initialState) {
        assert initialState != null;

        currentState = initialState;
        undoStates = new LinkedList<TaskManagerState>();
        redoStates = new LinkedList<TaskManagerState>();
        undoFilePathAvailable = 0;
        redoFilePathAvailable = 0;
    }

    @Override
    public void saveState(TaskManagerState state) {
        assert state != null;

        if (undoStates.size() == MAX) {
            undoStates.removeFirst();
        }
        assert undoStates.size() < MAX;
        
        undoStates.add(currentState);
        currentState = state;
        redoStates.clear();
    }

    @Override
    public TaskManagerState getPreviousState() throws StateLimitException {
        if (undoStates.size() < MIN) {
            throw new StateLimitException();
        }
        redoStates.add(currentState);
        currentState = undoStates.removeLast();
        return currentState;
    }

    @Override
    public TaskManagerState getNextState() throws StateLimitException {
        if (redoStates.size() < MIN) {
            throw new StateLimitException();
        }
        undoStates.add(currentState);
        currentState = redoStates.removeLast();
        return currentState;
    }

    @Override
    public void saveFilePath(String filePath, boolean isToClearOld) {
        assert filePath != null;

        raise(new StoragePathChangedEvent(filePath, isToClearOld));
        undoFilePathAvailable++;
        redoFilePathAvailable = 0;
    }

    @Override
    public void setPreviousFilePath(boolean isToClearNew) throws StateLimitException {
        if (undoFilePathAvailable < MIN) {
            throw new StateLimitException();
        }
        raise(new UndoStoragePathChangedEvent(isToClearNew));
        undoFilePathAvailable--;
        redoFilePathAvailable++;
    }

    @Override
    public void setNextFilePath() throws StateLimitException {
        if (redoFilePathAvailable < MIN) {
            throw new StateLimitException();
        }
        raise(new RedoStoragePathChangedEvent());
        undoFilePathAvailable++;
        redoFilePathAvailable--;
    }

}
```
###### /java/seedu/toDoList/model/state/TaskManagerState.java
``` java
/**
 * Represents the state of the task manager.
 */
public class TaskManagerState {
    
    private final ReadOnlyTaskManager taskManager;
    private final String message;
    
    public TaskManagerState(ReadOnlyTaskManager taskManager, String message) {
        this.taskManager = new TaskManager(taskManager);
        this.message = message;
    }
    
    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }
    
    public String getMessage() {
        return message;
    }
}
```
###### /java/seedu/toDoList/model/task/Date.java
``` java
/**
 * Represents a Task's date.
 * It can be deadline for tasks or event date for events.
 */
public interface Date {
    
    int hashCode();
    
    String getValue();
    
    String toString();
    
    ArrayList<LocalDate> getLocalDate();
    
    void updateDate(String... dateString);
    
    void updateRecurringDate(long numOfDays);
    
    default boolean isEmptyDate() {
        return DateUtil.isEmptyDate(getValue());
    }

}
```
###### /java/seedu/toDoList/model/task/Deadline.java
``` java
/**
 * Represents a Task's deadline. Empty String "" means no deadline (floating
 * task) Guarantees: is valid as declared in
 * {@link #isValidDeadlineFormat(String)}
 */
public class Deadline implements Date {

    public static final String MESSAGE_DEADLINE_CONSTRAINTS = "Deadline must be a valid date";

    private String date;

    /**
     * Validates given deadline.
     *
     * @throws IllegalValueException
     *             if given deadline string is invalid.
     */
    public Deadline(String date) throws IllegalValueException {
        assert date != null;
        this.date = getValidDate(date);
        assert isValidDeadlineFormat(this.date);
    }

    /**
     * Gets a date that is valid and is in valid deadline format.
     */
    public static String getValidDate(String date) throws IllegalValueException {
        if (DateUtil.isEmptyDate(date)) {
            return date;
        }
        try {
            return DateUtil.parseDate(date);
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException(MESSAGE_DEADLINE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if a given string is in a valid deadline format.
     */
    public static boolean isValidDeadlineFormat(String test) {
        return DateUtil.isEmptyDate(test) || DateUtil.isValidDateFormat(test);
    }

    @Override
    public String getValue() {
        return date;
    }

    @Override
    public String toString() {
        return date;
    }

```
###### /java/seedu/toDoList/model/task/Deadline.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this || ( other instanceof Deadline && isSameDeadline((Deadline) other) );
    }

    private boolean isSameDeadline(Deadline other) {
        return date.equals(other.date);
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }

}
```
###### /java/seedu/toDoList/model/task/EventDate.java
``` java
/**
 * Represents a Event's dates Guarantees: is valid as declared in
 * {@link #isValidEventDateFormat(String)}
 */
public class EventDate implements Date {

    public static final String MESSAGE_EVENT_DATE_CONSTRAINTS = "Event date must be a valid date";

    private String date;

    private String startDate;
    private String endDate;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException
     *             if given dates string is invalid.
     */
    public EventDate(String startDate, String endDate) throws IllegalValueException {
        assert startDate != null && endDate != null;
        this.startDate = getValidDate(startDate.trim());
        assert isValidEventDateFormat(this.startDate);
        this.endDate = getValidDate(endDate.trim());
        assert isValidEventDateFormat(this.endDate);
        this.date = this.startDate + " to " + this.endDate;
    }

    /**
     * Gets a date that is valid and is in a valid event date format.
     */
    public static String getValidDate(String date) throws IllegalValueException {
        try {
            return DateUtil.parseDate(date);
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException(MESSAGE_EVENT_DATE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if a given string is in a valid event date format.
     */
    private static boolean isValidEventDateFormat(String test) {
        return DateUtil.isValidDateFormat(test);
    }

    @Override
    public String getValue() {
        return date;
    }

    @Override
    public String toString() {
        return date;
    }

    @Override
    public boolean equals(Object other) {
        return other == this || ( other instanceof EventDate && isSameEventDate((EventDate) other) );
    }

    private boolean isSameEventDate(EventDate other) {
        return date.equals(other.date);
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDate, endDate);
    }

    public String getStartDate() {
        return startDate;
    }

    public String getEndDate() {
        return endDate;
    }

```
###### /java/seedu/toDoList/model/task/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override
     * .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                        && other.getName().equals(this.getName()) // state checks here onwards
                        && other.getDate().equals(this.getDate()) 
                        && other.isDone() == this.isDone()
                        && (other.isRecurring() ? other.getRecurring().equals(this.getRecurring())
                                : other.isRecurring() == this.isRecurring())
                        && other.getPriorityLevel().equals(this.getPriorityLevel()));
    }
```
###### /java/seedu/toDoList/model/task/Task.java
``` java
    @Override
    public Date getDate() {
        return date;
    }

    @Override
    public boolean isEvent() {
        return isEvent;
    }
```
###### /java/seedu/toDoList/model/task/Task.java
``` java
    public void setName(Name newName) {
        name = newName;
        nameString.set(name.taskName);
    }

    public void setDate(Date newDate) {
        date = newDate;
        dateString.setValue(date.getValue());
        // It does nothing but can magically fix a bug. It seems like the UI
        // need some time to reflect.
        dateString.get();
    }

    public void setRecurring(Recurring newRecurring) {
        recurring = newRecurring;
        isRecurring = true;
        recurringString.set(recurring.recurringFrequency);
    }

    /**
     * Returns Observable wrappers of the task
     */
    public StringProperty getNameString() {
        return nameString;
    }

    public StringProperty getDateString() {
        return dateString;
    }

    public BooleanProperty getDone() {
        return done;
    }

    public StringProperty getRecurringString() {
        return recurringString;
    }

    /*
     * Makes Task observable by its status
     */
    public static Callback<Task, Observable[]> extractor() {
        return (Task task) -> new Observable[] { task.getNameString(), task.getDateString(), task.getDone(),
                task.getRecurringString(), task.getPriorityInteger() };
    }

```
###### /java/seedu/toDoList/model/TaskManager.java
``` java
    /**
     * Marks the given task as done.
     */
    public void markTask(ReadOnlyTask p)  {
        p.markAsDone();
    }

```
###### /java/seedu/toDoList/storage/FilePath.java
``` java
/**
 * Represents the file path of the task manager.
 */
public class FilePath {

    private final String path;
    private final boolean isToClear;

    public FilePath(String path, boolean isToClear) {
        this.path = path;
        this.isToClear = isToClear;
    }

    public String getPath() {
        return path;
    }

    public boolean isToClear() {
        return isToClear;
    }

}
```
###### /java/seedu/toDoList/storage/FilePathManager.java
``` java
/**
 * Saves the file path of the task manager.
 */
public class FilePathManager {

    private static final int MIN = 1;

    private FilePath currentFilePath;
    private Stack<FilePath> undoFilePath;
    private Stack<FilePath> redoFilePath;

    /**
     * Initializes a FilePathManager with the given FilePath. FilePath should
     * not be null.
     */
    public FilePathManager(FilePath initialFilePath) {
        assert initialFilePath != null;
        
        currentFilePath = initialFilePath;
        undoFilePath = new Stack<FilePath>();
        redoFilePath = new Stack<FilePath>();
    }

    /** Saves the current file path of the task manager. */
    public void saveFilePath(FilePath filePath) {
        assert filePath != null;
        
        undoFilePath.push(currentFilePath);
        currentFilePath = filePath;
        redoFilePath.clear();
    }

    /** Gets the previous file path of the task manager. */
    public FilePath getPreviousFilePath() {
        assert undoFilePath.size() >= MIN;
        redoFilePath.push(currentFilePath);
        currentFilePath = undoFilePath.pop();
        return currentFilePath;
    }

    /** Gets the next file path of the task manager. */
    public FilePath getNextFilePath() {
        assert redoFilePath.size() >= MIN;
        undoFilePath.push(currentFilePath);
        currentFilePath = redoFilePath.pop();
        return currentFilePath;
    }

}
```
###### /java/seedu/toDoList/storage/Storage.java
``` java
    /**
     * Saves the current version of the Task Manager to a new file in hard disk.
     * Delete the old data file if it is specified. Raises
     * {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleStoragePathChangedEvent(StoragePathChangedEvent event);

    /**
     * Saves the current version of the Task Manager to the previous file in
     * hard disk. Delete the new data file if it is specified. Raises
     * {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleUndoStoragePathChangedEvent(UndoStoragePathChangedEvent event);

    /**
     * Redo saves the current version of the Task Manager to the new file in
     * hard disk. Delete the new data file if it was previously specified. Raises
     * {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleRedoStoragePathChangedEvent(RedoStoragePathChangedEvent event);
}
```
###### /java/seedu/toDoList/storage/StorageManager.java
``` java
    @Override
    public FilePath getTaskManagerPreviousFilePath() {
        return taskManagerStorage.getTaskManagerPreviousFilePath();
    }
    
    @Override
    public FilePath getTaskManagerNextFilePath() {
        return taskManagerStorage.getTaskManagerNextFilePath();
    }
    
    @Override
    public void saveTaskManagerFilePath(FilePath filePath) {
        taskManagerStorage.saveTaskManagerFilePath(filePath);
    }
    
    @Override
    public void setTaskManagerFilePath(FilePath filePath) throws IOException {
        taskManagerStorage.setTaskManagerFilePath(filePath);
    }
```
###### /java/seedu/toDoList/storage/StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleStoragePathChangedEvent(StoragePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Storage file path changed"));
        FilePath filePath = new FilePath(event.getNewStorageFilePath(), event.isToClearOld());
        changeFilePath(filePath);
        saveTaskManagerFilePath(filePath);
    }

    @Override
    @Subscribe
    public void handleUndoStoragePathChangedEvent(UndoStoragePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Undo storage file path changed"));
        changeFilePath(new FilePath(getTaskManagerPreviousFilePath().getPath(), event.isToClearNew()));
    }

    @Override
    @Subscribe
    public void handleRedoStoragePathChangedEvent(RedoStoragePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Redo storage file path changed"));
        changeFilePath(getTaskManagerNextFilePath());
    }

    private void changeFilePath(FilePath filePath) {
        try {
            setTaskManagerFilePath(filePath);
            raise(new StoragePathEvent(filePath.getPath()));
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

}
```
###### /java/seedu/toDoList/storage/TaskManagerStorage.java
``` java
    /**
     * Returns the previous file path of the data file.
     */
    FilePath getTaskManagerPreviousFilePath();
    
    /**
     * Returns the next file path of the data file.
     */
    FilePath getTaskManagerNextFilePath();
    
    /**
     * Saves the file path of the data file.
     */
    void saveTaskManagerFilePath(FilePath filePath);
    
    /**
     * Sets the file path of the data file.
     * @throws IOException 
     */
    void setTaskManagerFilePath(FilePath filePath) throws IOException;
```
###### /java/seedu/toDoList/storage/XmlFileStorage.java
``` java
    /**
     * Deletes the XML storage file with the specified path.
     */
    public static void deleteFile(Path filePath) throws IOException{
        Files.deleteIfExists(filePath);
    }
```
###### /java/seedu/toDoList/storage/XmlTaskManagerStorage.java
``` java
    @Override
    public FilePath getTaskManagerPreviousFilePath() {
        return filePathManager.getPreviousFilePath();
    }

    @Override
    public FilePath getTaskManagerNextFilePath() {
        return filePathManager.getNextFilePath();
    }

    @Override
    public void saveTaskManagerFilePath(FilePath filePath) {
        filePathManager.saveFilePath(filePath);
    }

    @Override
    public void setTaskManagerFilePath(FilePath newFilePath) throws IOException {
        assert newFilePath != null;
        if (newFilePath.isToClear()) {
            logger.info("Attempting to delete the data file: " + this.filePath);
            deleteTaskManager();
        }
        logger.info("Saving to new file: " + newFilePath.getPath());
        assert newFilePath.getPath() != null;
        this.filePath = newFilePath.getPath();
    }
```
###### /java/seedu/toDoList/storage/XmlTaskManagerStorage.java
``` java
    /**
     * Deletes the storage file.
     * @throws IOException if there was any problem deleting the file.
     */
    private void deleteTaskManager() throws IOException {
        assert filePath != null;
        XmlFileStorage.deleteFile(Paths.get(filePath));
    }
```
###### /java/seedu/toDoList/ui/FilterPanel.java
``` java
/**
 * Controller for the filter panel that is displayed at the left of the application.
 */
public class FilterPanel extends UiPart {

    public static final String SUCCESS_FILTER = "Filter the todoList";
    public static final String INVALID_FILTER = "Invalid filter: ";

    private static final Logger logger = LogsCenter.getLogger(FilterPanel.class);
    private static final String FXML = "FilterPanel.fxml";

    private static final String EMPTY = "";
    private static final String NIL = "nil";
    private static final String SPACE = "\\s+";
    private static final String ONE = "1";
    private static final String TWO = "2";
    private static final String THREE = "3";
    
    private static final String DEFAULT_BACKGROUND = "-fx-background-color: white";
    private static final String ERROR_BACKGROUND = "-fx-background-color: #d9534f";

    private GridPane mainPane;
    private AnchorPane placeHolder;
    private ResultDisplay resultDisplay;

    @FXML
    private ToggleButton eventsToggleButton;

    @FXML
    private ToggleButton tasksToggleButton;

    @FXML
    private ToggleButton doneToggleButton;

    @FXML
    private ToggleButton undoneToggleButton;

    @FXML
    private TextField deadlineTextField;

    @FXML
    private TextField recurringTextField;

    @FXML
    private TextField startDateTextField;

    @FXML
    private TextField endDateTextField;

    @FXML
    private TextField tagsTextField;

    @FXML
    private ChoiceBox<String> priorityChoiceBox;

    public static FilterPanel load(Stage stage, AnchorPane placeHolder, ResultDisplay resultDisplay) {
        FilterPanel filterPanel = UiPartLoader.loadUiPart(stage, placeHolder, new FilterPanel());
        filterPanel.configure(resultDisplay);
        return filterPanel;
    }

    public void configure(ResultDisplay resultDisplay) {
        this.resultDisplay = resultDisplay;
        addMainPane();
        initialPriority();
        registerAsAnEventHandler(this);
    }

    private void addMainPane() {
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    private void initialPriority() {
        priorityChoiceBox.setItems(FXCollections.observableArrayList(EMPTY, ONE, TWO, THREE));
    }

    @Override
    public void setNode(Node node) {
        mainPane = (GridPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    /**
     * Sets the corresponding text filed or choice box to be focused.
     */
    @Subscribe
    private void handleJumpFilterPanelEvent(JumpToFilterPanelEvent event) {
        Types qualification = event.getAttribute();
        switch (qualification) {
        case DEADLINE:
            deadlineTextField.requestFocus();
            return;
        case START_DATE:
            startDateTextField.requestFocus();
            return;
        case END_DATE:
            endDateTextField.requestFocus();
            return;
        case RECURRING:
            recurringTextField.requestFocus();
            return;
        case PRIORITY_LEVEL:
            priorityChoiceBox.requestFocus();
            priorityChoiceBox.show();
            return;
        case TAG:
            tagsTextField.requestFocus();
            return;
        default:
            assert false;
        }
    }

    /**
     * Handles changes in the filter panel.
     */
    @FXML
    private void handleFilterChanged() {
        Set<Types> types = handleTypesChanged();
        Map<Types, String> qualifications;
        try {
            qualifications = handleQualificationsChanged();
        } catch (IllegalValueException e) {
            indicateInvalidFilter(e);
            return;
        }
        Set<String> tagSet = handleTagsChanged();
        
        raise(new FilterPanelChangedEvent(types, qualifications, tagSet));
        indicateFilterSuccess();
    }

    /**
     * Indicates an invalid filter command caused by a parameter with illegal
     * value.
     * 
     * @param illegalValueException
     */
    private void indicateInvalidFilter(IllegalValueException illegalValueException) {
        logger.info(INVALID_FILTER + illegalValueException.getMessage());
        resultDisplay.setStyleToIndicateIncorrectCommand();
        resultDisplay.postMessage(INVALID_FILTER + illegalValueException.getMessage());
    }

    /**
     * Indicates filter successfully.
     */
    private void indicateFilterSuccess() {
        logger.info("Input in filter panel changed");
        resultDisplay.setStyleToIndicateCorrectCommand();
        resultDisplay.postMessage(SUCCESS_FILTER);
    }

    /**
     * Handles changes in the selection of types.
     * 
     * @return a set of selected types.
     */
    private Set<Types> handleTypesChanged() {
        Set<Types> types = new HashSet<>();
        if (eventsToggleButton.isSelected()) {
            types.add(Types.EVENTS);
        }
        if (tasksToggleButton.isSelected()) {
            types.add(Types.TASKS);
        }
        if (doneToggleButton.isSelected()) {
            types.add(Types.DONE);
        }
        if (undoneToggleButton.isSelected()) {
            types.add(Types.UNDONE);
        }
        return types;
    }

    /**
     * Handles changes in the inputs for qualification
     * 
     * @return a map of qualifications
     * @throws IllegalValueException
     *             if any input is invalid
     */
    private Map<Types, String> handleQualificationsChanged() throws IllegalValueException {
        Map<Types, String> qualifications = new HashMap<>();
        handleDeadlineChanged(qualifications);
        handleStartDateChanged(qualifications);
        handleEndDateChanged(qualifications);
        handleRecurringChanged(qualifications);
        handlePriorityChanged(qualifications);
        return qualifications;
    }

    /*
     * For the following inputs, we assume that they are correct. If the input
     * is invalid, the corresponding text field will be changed accordingly to
     * indicate the error.
     */

    /**
     * Handles changes in the deadline text field.
     * 
     * @throws IllegalValueException
     *             if the given deadline is invalid.
     */
    private void handleDeadlineChanged(Map<Types, String> qualifications) throws IllegalValueException {
        String deadline = parseTextFieldInput(deadlineTextField);
        if (deadline.isEmpty()) {
            return;
        }
        if (deadline.equals(NIL)) {
            qualifications.put(Types.DEADLINE, EMPTY);
        } else {
            try {
                deadline = Deadline.getValidDate(deadline);
                qualifications.put(Types.DEADLINE, deadline);
            } catch (IllegalValueException e) {
                indicateInvalidTextFieldInput(deadlineTextField);
                throw e;
            }
        }
    }

    /**
     * Handles changes in the start date text field.
     * 
     * @throws IllegalValueException
     *             if the given start date is invalid.
     */
    private void handleStartDateChanged(Map<Types, String> qualifications) throws IllegalValueException {
        String startDate = parseTextFieldInput(startDateTextField);
        if (startDate.isEmpty()) {
            return;
        }
        try {
            startDate = EventDate.getValidDate(startDate);
            qualifications.put(Types.START_DATE, startDate);
        } catch (IllegalValueException e) {
            indicateInvalidTextFieldInput(startDateTextField);
            throw e;
        }
    }

    /**
     * Handles changes in the end date text filed.
     * 
     * @throws IllegalValueException
     *             if the given end date is invalid.
     */
    private void handleEndDateChanged(Map<Types, String> qualifications) throws IllegalValueException {
        String endDate = parseTextFieldInput(endDateTextField);
        if (endDate.isEmpty()) {
            return;
        }
        try {
            endDate = EventDate.getValidDate(endDate);
            qualifications.put(Types.END_DATE, endDate);
        } catch (IllegalValueException e) {
            indicateInvalidTextFieldInput(endDateTextField);
            throw e;
        }
    }

    /**
     * Handles changes in the recurring text field.
     * 
     * @throws IllegalValueException
     *             if the given recurring frequency is invalid.
     */
    private void handleRecurringChanged(Map<Types, String> qualifications) throws IllegalValueException {
        String recurring = parseTextFieldInput(recurringTextField);
        if (recurring.isEmpty()) {
            return;
        }
        if (Recurring.isValidFrequency(recurring)) {
            qualifications.put(Types.RECURRING, recurring);
        } else {
            indicateInvalidTextFieldInput(recurringTextField);
            throw new IllegalValueException(Recurring.MESSAGE_RECURRING_CONSTRAINTS);
        }
    }

    /**
     * Parses the input in the given text field and reset its background color
     * to default.
     */
    private String parseTextFieldInput(TextField textField) {
        textField.setStyle(DEFAULT_BACKGROUND);
        return textField.getText().trim();
    }

    /**
     * Indicates the input in the given text field is invalid.
     */
    private void indicateInvalidTextFieldInput(TextField textField) {
        textField.requestFocus();
        textField.setStyle(ERROR_BACKGROUND);
    }

    /**
     * Handles changes in the priority level choice box.
     */
    private void handlePriorityChanged(Map<Types, String> qualifications) {
        String priority = priorityChoiceBox.getSelectionModel().getSelectedItem().toString();
        if (!priority.isEmpty()) {
            qualifications.put(Types.PRIORITY_LEVEL, priority);
        }
    }

    /**
     * Handles changes in the tags text field.
     * 
     * @return a set of tags
     */
    private Set<String> handleTagsChanged() {
        String tags = tagsTextField.getText().trim();
        Set<String> tagSet;
        if (tags.isEmpty()) {
            tagSet = new HashSet<>();
        } else {
            tagSet = new HashSet<>(Arrays.asList(tags.split(SPACE)));
        }
        return tagSet;
    }
    
    /**
     * Updates filter panel so it will correspond to changes in the filtered
     * task list.
     */
    @Subscribe
    private void handleUpdateFilterPanelEvent(UpdateFilterPanelEvent event) {
        reset();
        
        event.getTypes().forEach(type -> updateType(type));
        event.getQualifications().forEach((attribute, keyword) -> updateQualification(attribute, keyword));
        updateTags(event.getTags());
    }

    /**
     * Resets the filter panel.
     */
    private void reset() {
        resetToggleButtons();
        resetTextFields();
        resetChoiceBox();
    }

    /**
     * Resets toggle buttons.
     */
    private void resetToggleButtons() {
        eventsToggleButton.setSelected(false);
        tasksToggleButton.setSelected(false);
        doneToggleButton.setSelected(false);
        undoneToggleButton.setSelected(false);
    }

    /**
     * Resets text fields.
     */
    private void resetTextFields() {
        resetTextFields(deadlineTextField);
        resetTextFields(startDateTextField);
        resetTextFields(endDateTextField);
        resetTextFields(recurringTextField);
        resetTextFields(tagsTextField);
    }

    private void resetTextFields(TextField textField) {
        textField.setStyle(DEFAULT_BACKGROUND);
        textField.setText("");
    }

    /**
     * Resets choice box.
     */
    private void resetChoiceBox() {
        priorityChoiceBox.getSelectionModel().selectFirst();
    }

    /**
     * Updates selected types in the filter panel.
     */
    private void updateType(Types type) {
        switch (type) {
        case EVENTS:
            eventsToggleButton.setSelected(true);
            return;
        case TASKS:
            tasksToggleButton.setSelected(true);
            return;
        case DONE:
            doneToggleButton.setSelected(true);
            return;
        case UNDONE:
            undoneToggleButton.setSelected(true);
            return;
        default:
            assert false;
        }
    }

    /**
     * Updates qualifications inputs in the filter panel.
     */
    private void updateQualification(Types attribute, String keyword) {
        switch (attribute) {
        case DEADLINE:
            deadlineTextField.setText(keyword);
            return;
        case START_DATE:
            startDateTextField.setText(keyword);
            return;
        case END_DATE:
            endDateTextField.setText(keyword);
            return;
        case RECURRING:
            recurringTextField.setText(keyword);
            return;
        case PRIORITY_LEVEL:
            priorityChoiceBox.getSelectionModel().select(Integer.parseInt(keyword));
            return;
        default:
            assert false;
        }
    }

    /**
     * Updates tags inputs in the filter panel.
     */
    private void updateTags(Set<String> tags) {
        String tagString = "";
        for (String tag : tags) {
            tagString += tag + " ";
        }
        tagsTextField.setText(tagString);
    }

}
```
###### /java/seedu/toDoList/ui/StatusBarFooter.java
``` java
    @Subscribe
    public void handleStoragePathChangedEvent(StoragePathEvent event) {
        setSaveLocation(event.getNewStorageFilePath());
    }
}
```
