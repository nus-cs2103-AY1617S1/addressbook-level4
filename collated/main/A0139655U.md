# A0139655U
###### \java\seedu\address\commons\exceptions\TaskNotRecurringException.java
``` java
/**
 * Signals that task does not have recurrence rate or does not have both start and end dates.
 */
public class TaskNotRecurringException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public TaskNotRecurringException(String message) {
        super(message);
    }
}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
/**
 * Adds a person to the address book.
 */
public class AddCommand extends UndoableCommand {

    private final Logger logger = LogsCenter.getLogger(AddCommand.class);

    public static final String COMMAND_WORD = "add";
    private static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds an item to To-Do List.\n"
            + "Parameters: [add] NAME [from/at/start DATE_TIME] [to/by/end DATE_TIME] [repeat every RECURRING_INTERVAL] [-PRIORITY]\n"

            + "Example: " + COMMAND_WORD + " feed cat by today 11:30am repeat every day -high";

    //@author
    public static final String MESSAGE_SUCCESS = "New item added: %1$s";
    public static final String MESSAGE_UNDO_SUCCESS = "Undid add item: %1$s";
    private static final String MESSAGE_UNDO_FAILURE = "Failed to undo last add command: add %1$s";
    public static final String TOOL_TIP = "[add] NAME [start DATE_TIME] [end DATE_TIME] "
            + "[repeat every RECURRING_INTERVAL] [-PRIORITY]";

```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException If any of the raw values are invalid.
     */
    public AddCommand(HashMap<String, Optional<String>> mapOfStrings) throws IllegalValueException {
        HashMap<String, Object> mapOfTaskParameters = AddCommandHelper.convertStringToObjects(mapOfStrings);
        assert mapOfTaskParameters.get(Name.getMapNameKey()) != null;

        Name taskName = (Name) mapOfTaskParameters.get(Name.getMapNameKey());
        Date startDate = (Date) mapOfTaskParameters.get(DateTime.getMapStartDateKey());
        Date endDate = (Date) mapOfTaskParameters.get(DateTime.getMapEndDateKey());
        RecurrenceRate recurrenceRate = (RecurrenceRate) mapOfTaskParameters
                .get(RecurrenceRate.getMapRecurrenceRateKey());
        Priority priority = (Priority) mapOfTaskParameters.get(Priority.getMapPriorityKey());

        logger.log(Level.FINEST, "taskName is " + taskName + "\nstartDate is " + startDate + "\nendDate is "
                + endDate + "\n recurrenceRate is " + recurrenceRate + "\npriority is " + priority);
        this.toAdd = new Task(taskName, startDate, endDate, recurrenceRate, priority);
    }
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    public static String getMessageUsage() {
        return MESSAGE_USAGE;
    }
}
```
###### \java\seedu\address\logic\commands\AddCommandHelper.java
``` java
/**
 * Helps AddCommand to validate user input.
 */
public class AddCommandHelper {
    

    private final static Logger logger = LogsCenter.getLogger(AddCommandHelper.class);
    
    private static final String MESSAGE_RECUR_DATE_TIME_CONSTRAINTS = "For recurring tasks to be valid, "
            + "at least one DATE_TIME must be provided.";
    private static final String MESSAGE_END_DATE_CONSTRAINTS = "End date should be later than start date.";
    private static final String MESSAGE_DATE_CONSTRAINTS = "Invalid date.";
    
    /** used to check for invalid dates e.g 40 Oct */
    private static final String REGEX_VALIDATE_DATE = ".*?(?:SEEK > by_day (?<date>\\d+) \\W+).*";

    private static final String STRING_CONSTANT_ONE = "1";
    private static final int BASE_INDEX = 0;
    private static final int MAX_DAYS_IN_MONTH = 31;
    
    /**
     * Returns a HashMap containing values of taskName, startDate, endDate, recurrenceRate and priority.
     *
     * @param args  HashMap containing Optional<String> values of taskName, startDate, endDate, rate, timePeriod and priority.
     * @return      HashMap containing values of taskName, startDate, endDate, recurrenceRate and priority.
     * @throws IllegalValueException  If recurrenceRate or date is invalid.
     */
    public static HashMap<String, Object> convertStringToObjects(HashMap<String, Optional<String>> mapOfStrings) 
            throws IllegalValueException {
        Name taskName = new Name(mapOfStrings.get(Name.getMapNameKey()).get());
        Date startDate = convertStringToStartDate(mapOfStrings.get(DateTime.getMapStartDateKey()));
        Date endDate = convertStringToEndDate(mapOfStrings.get(DateTime.getMapEndDateKey()), startDate);
        RecurrenceRate recurrenceRate = convertStringToRecurrenceRate(mapOfStrings.get(RecurrenceRate.getMapRateKey()), 
                mapOfStrings.get(TimePeriod.getTimePeriodKey())); 
        
        if (isRecurWeekdaysButDatesNotGiven(startDate, endDate, recurrenceRate)) {
            startDate = DateTime.assignStartDateToSpecifiedWeekday(recurrenceRate.getTimePeriod().toString());
        } 
        
        Priority priority = Priority.convertStringToPriority(mapOfStrings.get(Priority.getMapPriorityKey()).get());
        
        checkInvalidCombinations(startDate, endDate, recurrenceRate);
        
        return mapContainingVariables(taskName, startDate, endDate, recurrenceRate, priority);
    }

    /**
     * Checks whether the combination of startDate, endDate and recurrenceRate is valid.
     *
     * @param startDate Start date of Task.
     * @param endDate   End date of Task.
     * @param recurrenceRate    Recurrence rate of Task.
     * @throws IllegalValueException  If invalid combination of startDate, endDate and recurrenceRate exists.
     */
    private static void checkInvalidCombinations(Date startDate, Date endDate, RecurrenceRate recurrenceRate)
            throws IllegalValueException {
        if (isOtherRecurrenceButDatesNotGiven(startDate, endDate, recurrenceRate)) {
            logger.log(Level.FINE, "IllegalValueException thrown in AddCommandHelper, recurrence rate given but dates not given");
            throw new IllegalValueException(MESSAGE_RECUR_DATE_TIME_CONSTRAINTS);
        }
        
        if (endDate != null && startDate != null && endDate.before(startDate)) {
            logger.log(Level.FINE, "IllegalValueException thrown in AddCommandHelper, end date is before start date");
            throw new IllegalValueException(MESSAGE_END_DATE_CONSTRAINTS);
        }
    }

    /**
     * Put the input parameters taskName, startDate, endDate, recurrenceRate and priority into a HashMap and returns the map.
     *
     * @param taskName          Name of Task.
     * @param startDate         Start date of Task.
     * @param endDate           End date of Task.
     * @param recurrenceRate    Recurrence rate of Task.
     * @param priority          Priority of Task.
     * @return                  HashMap containing values of taskName, startDate, endDate, recurrenceRate and priority.
     */
    private static HashMap<String, Object> mapContainingVariables(Name taskName, Date startDate, Date endDate,
            RecurrenceRate recurrenceRate, Priority priority) {
        assert taskName != null && priority != null;
        HashMap<String, Object> map = new HashMap<String, Object>();

        map.put(Name.getMapNameKey(), taskName);
        map.put(DateTime.getMapStartDateKey(), startDate);
        map.put(DateTime.getMapEndDateKey(), endDate);
        map.put(RecurrenceRate.getMapRecurrenceRateKey(), recurrenceRate);
        map.put(Priority.getMapPriorityKey(), priority);
        
        return map;
    }
    
    /**
     * Converts given String into the Date representation.
     *
     * @param startDateString   User's input of date.
     * @return                  The Date representation of startDateString if startDateString is present. 
     *                          Else, returns null.
     * @throws IllegalValueException    If startDateString cannot be converted into a Date object.
     */
    private static Date convertStringToStartDate(Optional<String> startDateString) throws IllegalValueException {
        assert startDateString != null;
        Date startDate = null;
        
        if (startDateString.isPresent()) {
            validateDateString(startDateString.get());
            startDate = DateTime.convertStringToDate(startDateString.get());

            if (!DateTime.hasTimeValue(startDateString.get())) {
                startDate = DateTime.setTimeToStartOfDay(startDate);
            }
        }
        return startDate;
    }

    /**
     * Validates if dateString is valid.
     *
     * @param dateString   User's input of date.
     * @throws IllegalValueException    If dateString is an invalid date e.g 40 Oct.
     */
    private static void validateDateString(String dateString) throws IllegalValueException {
        if (DateTime.isValidDate(dateString)) {
            List<DateGroup> dates = new Parser().parse(dateString);
            String syntaxTree = dates.get(BASE_INDEX).getSyntaxTree().toStringTree();
            Pattern pattern = Pattern.compile(REGEX_VALIDATE_DATE);
            Matcher matcher = pattern.matcher(syntaxTree);
            if (matcher.matches() && Integer.parseInt(matcher.group("date")) > MAX_DAYS_IN_MONTH) {
                logger.log(Level.FINE, "IllegalValueException thrown in AddCommandHelper, validateDateString, invalid date");
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
            }
        } else {
            logger.log(Level.FINE, "IllegalValueException thrown in AddCommandHelper, validateDateString, "
                    + "input does not conform to user guide");
            throw new IllegalValueException(DateTime.getMessageValueConstraints());
        }
    }
    
    /**
     * Converts given String into the Date representation. If user did not specify the date in endDateString,
     * it will take the date of startDate.
     *
     * @param endDateString User's input of date.
     * @param startDate     Start date of Task.
     * @return              The Date representation of endDateString if endDateString is present. Else, returns null.
     * @throws IllegalValueException    If endDateString cannot be converted into a Date object.
     */
    private static Date convertStringToEndDate(Optional<String> endDateString, Date startDate) throws IllegalValueException {
        assert endDateString != null;
        Date endDate = null;
        
        if (endDateString.isPresent()) {
            validateDateString(endDateString.get());
            endDate = DateTime.convertStringToDate(endDateString.get());
            if (startDate != null && !DateTime.hasDateValue(endDateString.get())) {
                endDate = DateTime.setEndDateToStartDate(startDate, endDate);
            }
            if (!DateTime.hasTimeValue(endDateString.get())) {
                endDate = DateTime.setTimeToEndOfDay(endDate);
            }
        }
        return endDate;
    }
    
    /**
     * Converts given String into the RecurrenceRate representation. 
     *
     * @param rateString        User's input of rate.
     * @param timePeriodString  User's input of time period.
     * @return                  The RecurrenceRate representation of rateString and timePeriodString if present. 
     *                          Else, returns null.
     * @throws IllegalValueException    If rateString is present but timePeriodString isn't present
     *                                  (for e.g, "3" is invalid. Examples such as "3 days" or "week" is valid).
     */
    private static RecurrenceRate convertStringToRecurrenceRate(Optional<String> rateString,
            Optional<String> timePeriodString) throws IllegalValueException {
        assert rateString != null && timePeriodString != null;
        RecurrenceRate recurrenceRate = null;
        
        if (rateString.isPresent() && timePeriodString.isPresent()) {
            recurrenceRate = new RecurrenceRate(rateString.get(), timePeriodString.get());
        } else if (!rateString.isPresent() && timePeriodString.isPresent()) {
            recurrenceRate = new RecurrenceRate(STRING_CONSTANT_ONE, timePeriodString.get());
        } else if (rateString.isPresent() && !timePeriodString.isPresent()) {
            logger.log(Level.FINE, "IllegalValueException thrown in AddCommandHelper, convertStringToRecurrenceRate, "
                    + "rate is present but time period absent");
            throw new IllegalValueException(RecurrenceRate.getMessageValueConstraints());
        }
        return recurrenceRate;
    }
    
    /**
     * Returns true if both dates are null and the Task repeats every weekday e.g "monday". 
     *
     * @param startDate         Start date of Task.
     * @param endDate           End date of Task.
     * @param recurrenceRate    Recurrence rate of Task.
     * @return                  True if both dates are null and Task repeats every weekday. Else, returns false.
     */
    private static boolean isRecurWeekdaysButDatesNotGiven(Date startDate, Date endDate, RecurrenceRate recurrenceRate) {
        if (recurrenceRate != null) {
            TimePeriod recurrenceRateTimePeriod = recurrenceRate.getTimePeriod();
            TimePeriod day = TimePeriod.DAY;
            
            return recurrenceRateTimePeriod != day 
                    && recurrenceRate.getTimePeriod().toString().toLowerCase().contains(day.toString().toLowerCase()) 
                    && startDate == null && endDate == null;
        } else {
            return false;
        }
    }
    
    /**
     * Returns true if both dates are null and the Task repeats every non-weekday e.g "week". 
     *
     * @param startDate         Start date of Task.
     * @param endDate           End date of Task.
     * @param recurrenceRate    Recurrence rate of Task.
     * @return                  True if both dates are null and Task repeats every non-weekday. Else, returns false.
     */
    private static boolean isOtherRecurrenceButDatesNotGiven(Date startDate, Date endDate, RecurrenceRate recurrenceRate) {
        return recurrenceRate != null && startDate == null && endDate == null;
    }
    
    public static String getMessageRecurDateTimeConstraints() {
        return MESSAGE_RECUR_DATE_TIME_CONSTRAINTS;
    }
    
    public static String getMessageEndDateConstraints() {
        return MESSAGE_END_DATE_CONSTRAINTS;
    }
    
    public static String getMessageDateConstraints() {
        return MESSAGE_DATE_CONSTRAINTS;
    }
}
```
###### \java\seedu\address\logic\parser\CommandParser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args  Full command args string.
     * @return      The prepared command.
     */
    private Command prepareAdd(String args){
        assert args != null;
        
        logger.finer("Entering CommandParser, prepareAdd()");
        String argsTrimmed = args.trim();
        if(argsTrimmed.isEmpty()) {
            logger.log(Level.FINE, "Trimmed argument is empty, returning IncorrectCommand");
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.getMessageUsage()));
        }
        
        try {  
            HashMap<String, Optional<String>> extractedValues = retrieveAddFieldsFromArgs(argsTrimmed);
            logger.log(Level.FINE, "Exiting CommandParser, prepareAdd()");
            return new AddCommand(extractedValues);
        } catch (IllegalValueException ive) {
            logger.log(Level.FINE, "IllegalValueException caught in CommandParser, prepareAdd(), returning IncorrectCommand");
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ive.getMessage() + NEWLINE_STRING + 
                    AddCommand.getMessageUsage()));
        }
    }

```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
/**
 * Parses user input for add and edit commands
 */
public class CommandParserHelper {
    
    private final Logger logger = LogsCenter.getLogger(CommandParserHelper.class);
    
    private static final String MESSAGE_REPEATED_START_TIME = "Repeated start times are not allowed.";
    private static final String MESSAGE_REPEATED_END_TIME = "Repeated end times are not allowed.";
    private static final String MESSAGE_INVALID_MATCHER = "Matcher is unable to find a match.";
    
    private static final int ZERO = 0;
    private static final int ONE = 1;
    private static final int TWO = 2;
    
    private static final String TASK_NAME = "taskName";
    private static final String START_DATE_FORMAT_ONE = "startDateFormatOne";
    private static final String START_DATE_FORMAT_TWO = "startDateFormatTwo";
    private static final String START_DATE_FORMAT_THREE = "startDateFormatThree";
    private static final String END_DATE_FORMAT_ONE = "endDateFormatOne";
    private static final String END_DATE_FORMAT_TWO = "endDateFormatTwo";
    private static final String END_DATE_FORMAT_THREE = "endDateFormatThree";
    private static final String END_DATE_FORMAT_FOUR = "endDateFormatFour";
    private static final String END_DATE_FORMAT_FIVE = "endDateFormatFive";
    private static final String END_DATE_FORMAT_SIX = "endDateFormatSix";
    private static final String RATE = "rate";
    private static final String TIME_PERIOD = "timePeriod";
    private static final String PRIORITY = "priority";

    private static final String REGEX_OPEN_BRACE = "(";
    private static final String REGEX_CASE_IGNORE = "?i:";
    private static final String REGEX_CLOSE_BRACE = ")";
    private static final String REGEX_GREEDY_SELECT = ".*?";
    private static final String REGEX_ESCAPE_CHARACTER = "\"";
    
    /** greedily captures the taskName until it reaches the following keyword */
    private static final String REGEX_NAME = "?<taskName>.*?";
    
    /** used for concatenating keyword to REGEX_NAME */
    private static final String REGEX_ADDITIONAL_KEYWORD = "(?:" + "(?: from )" + "|(?: at )" + "|(?: start )"
            + "|(?: by )" + "|(?: to )" + "|(?: end )" + ")";
    
    /** 
     * greedily captures everything after the keyword (from, at, start, by, to, end), 
     * until it reaches the next regex expression or end of input
     */
    private static final String REGEX_FIRST_DATE = "(?:" + "(?: from (?<" + START_DATE_FORMAT_ONE + ">.*?))"
            + "|(?: at (?<" + START_DATE_FORMAT_TWO + ">.*?))" + "|(?: start (?<" + START_DATE_FORMAT_THREE + ">.*?))"
            + "|(?: by (?<" + END_DATE_FORMAT_ONE + ">.*?))" + "|(?: to (?<" + END_DATE_FORMAT_TWO + ">.*?))"
            + "|(?: end (?<" + END_DATE_FORMAT_THREE + ">.*?))" + ")";
    
    /** 
     * greedily captures everything after the keyword (from, at, start, by, to, end), 
     * until it reaches the next regex expression or end of input
     */
    private static final String REGEX_SECOND_DATE = "(?:" + "(?: from (?:.*?))"
            + "|(?: at (?:.*?))" + "|(?: start (?:.*?))"
            + "|(?: by (?<" + END_DATE_FORMAT_FOUR + ">.*?))" + "|(?: to (?<" + END_DATE_FORMAT_FIVE + ">.*?))"
            + "|(?: end (?<" + END_DATE_FORMAT_SIX + ">.*?))" + ")";
    
    /** 
     * greedily captures everything after the keyword (repeat every, -), 
     * until it reaches the next regex expression or end of input
     */
    private static final String REGEX_RECURRENCE_AND_PRIORITY = "(?: repeat every (?<rate>\\d+)?(?<timePeriod>.*?))?"
            + "(?: -(?<priority>.*?))?";

    /** beginning of regex in the event that input is escaped */
    private static final String REGEX_OPEN_BRACE_CASE_IGNORE_NAME_ESCAPE = REGEX_OPEN_BRACE + REGEX_CASE_IGNORE
            + REGEX_ESCAPE_CHARACTER + REGEX_OPEN_BRACE + REGEX_NAME + REGEX_CLOSE_BRACE + REGEX_ESCAPE_CHARACTER;
    
    /** beginning of regex in the event that input is not escaped */
    private static final String REGEX_OPEN_BRACE_CASE_IGNORE_NAME = REGEX_OPEN_BRACE + REGEX_CASE_IGNORE
            + REGEX_OPEN_BRACE + REGEX_NAME;
    
    /** used for concatenating keyword to REGEX_NAME */
    private static final String REGEX_KEYWORD_GREEDY_SELECT = REGEX_ADDITIONAL_KEYWORD + REGEX_GREEDY_SELECT;
    
    /** end of regex; only concatenated at the end after other required regex expressions have been concatenated. */
    private static final String REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE = REGEX_RECURRENCE_AND_PRIORITY
            + REGEX_CLOSE_BRACE;
    
    private Pattern pattern;
    private Matcher matcher;

    /**
     * Returns a HashMap containing Optional<String> values of
     * taskName, startDate, endDate, rate, timePeriod and priority.
     *
     * @param args  User input of task to add.
     * @return      Values of taskName, startDate, endDate, rate, timePeriod and priority.
     * @throws IllegalValueException    If args does not match the matcher.
     */
    public HashMap<String, Optional<String>> prepareAdd(String args) throws IllegalValueException {
        assert args != null;
        OptionalStringTask task = new OptionalStringTask();
        
        if (args.contains(REGEX_ESCAPE_CHARACTER)) {
            logger.log(Level.FINEST, "In prepareAdd, args contains escape character");
            generateMatcherForEscapeInput(args, task);
        } else {
            logger.log(Level.FINEST, "In prepareAdd, args does not contain escape character");
            generateMatcherForNonEscapeInput(args, task);
        }
        
        assignTaskParameters(task);
        return mapContainingVariables(task);
    }
    
```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
    /**
     * Generates the matcher for the escaped input args.
     *
     * @param args  User input of task to add.
     * @param task  Object to store values for startDate and endDate.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForEscapeInput(String args, OptionalStringTask task) throws IllegalValueException {
        assert args != null && task != null;
        
        String argsMinusTaskName = generateArgsMinusTaskName(args);
        int numberOfKeywords = generateNumberOfKeywords(argsMinusTaskName);
        logger.log(Level.FINEST, "Number of keywords in \"" + args + "\" = " + numberOfKeywords);
        String regex = REGEX_OPEN_BRACE_CASE_IGNORE_NAME_ESCAPE;
        
        if (numberOfKeywords == ZERO) {
            generateMatcherForNoKeywordEscape(args, regex);
        } else if (numberOfKeywords == ONE) {
            generateMatcherForOneKeywordEscape(args, regex);
            matcherSetStartOrEndDate(task);
        } else if (numberOfKeywords >= TWO) {
            generateMatcherForTwoKeywordsEscape(args, regex);
            matcherSetStartOrEndDate(task);
            matcherSetEndDate(task);
        }
    }
    
    /**
     * Generates the matcher for the input args.
     *
     * @param args  User input of task to add.
     * @param task  Object to store values for startDate and endDate.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForNonEscapeInput(String args, OptionalStringTask task) throws IllegalValueException {
        assert args != null && task != null;
        
        int numberOfKeywords = generateNumberOfKeywords(args);
        logger.log(Level.FINEST, "Number of keywords in \"" + args + "\" = " + numberOfKeywords);
        String regex = generateStartOfRegex(numberOfKeywords);

        if (numberOfKeywords == ZERO) {
            generateMatcherForNoKeyword(args, regex);
        } else if (numberOfKeywords == ONE) {
            generateMatcherForOneKeyword(args, regex);
            matcherSetStartOrEndDate(task);
            if (startOrEndDateIsInvalid(task.startDate, task.endDate)) {
                tryGenerateMatcherForNoKeyword(args, task, regex);
            }
        } else if (numberOfKeywords >= TWO) {
            generateMatcherForTwoKeywords(args, regex);
            matcherSetStartOrEndDate(task);
            if (startOrEndDateIsInvalid(task.startDate, task.endDate)) {
                tryGenerateMatcherForOneOrNoKeyword(args, task, regex);
            } else { 
                matcherSetEndDate(task);
            }
        }
    }

    /**
     * Checks whether matcher for one keyword or zero keyword matches the input args.
     *
     * @param args  User input of task to add.
     * @param task  Object to store values for startDate and endDate.
     * @param regex Used to generate matcher
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void tryGenerateMatcherForOneOrNoKeyword(String args, OptionalStringTask task, String regex)
            throws IllegalValueException {
        tryMatcherForOneKeyword(args, task, regex);
        matcherSetStartOrEndDate(task);
        if (startOrEndDateIsInvalid(task.startDate, task.endDate)) {
            regex += REGEX_KEYWORD_GREEDY_SELECT;
            tryGenerateMatcherForNoKeyword(args, task, regex);
        }
    }

    /**
     * Checks whether matcher for one keyword matches the input args.
     *
     * @param args  User input of task to add.
     * @param task  Object to store values for startDate and endDate.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void tryMatcherForOneKeyword(String args, OptionalStringTask task, String regex)
            throws IllegalValueException {
        reinitialiseStartAndEndDatesToEmpty(task);
        regex += REGEX_KEYWORD_GREEDY_SELECT;
        generateMatcherForOneKeyword(args, regex);
    }

    /**
     * Checks whether matcher for zero keyword matches the input args.
     *
     * @param args  User input of task to add.
     * @param task  Object to store values for startDate and endDate.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void tryGenerateMatcherForNoKeyword(String args, OptionalStringTask task, String regex)
            throws IllegalValueException {
        reinitialiseStartAndEndDatesToEmpty(task);
        regex += REGEX_KEYWORD_GREEDY_SELECT;
        generateMatcherForNoKeyword(args, regex);
    }

    /**
     * Returns a string containing args minus the escaped string.
     *
     * @param args  User input of task to add.
     * @return      Args minus escaped string.
     */
    private String generateArgsMinusTaskName(String args) {
        assert args != null;
        
        int indexOfEndOfTaskName = args.lastIndexOf(REGEX_ESCAPE_CHARACTER) + ONE;
        return args.substring(indexOfEndOfTaskName);
    }
    
    /**
     * Returns the number of occurrences of "from", "at", "start", "by", "to", "end" in args.
     * The value returned will be >= 0.
     *
     * @param args  User input of task to add.
     * @return      Number of occurrences of "from", "at", "start", "by", "to", "end".
     */
    private int generateNumberOfKeywords(String args) {    
        assert args != null;
        
        int numberOfKeywords = ZERO;
        pattern = Pattern.compile(REGEX_ADDITIONAL_KEYWORD);
        matcher = pattern.matcher(args);
        while (matcher.find()) {
            numberOfKeywords++;
        }
        
        assert numberOfKeywords >= 0;
        return numberOfKeywords;
    }
    
    /**
     * Generates the start of the regex that captures the taskName.
     *
     * @param numberOfKeywords  Number of occurrences of "from", "at", "start", "by", "to", "end".
     * @return                  The start of the regex.
     */
    private String generateStartOfRegex(int numberOfKeywords) {
        assert numberOfKeywords >= ZERO;
        
        String regex = REGEX_OPEN_BRACE_CASE_IGNORE_NAME;

        if (numberOfKeywords > TWO) {
            int numberOfAdditionalKeywords = numberOfKeywords - TWO;
            for (int i = 0; i < numberOfAdditionalKeywords; i++) {
                regex += REGEX_KEYWORD_GREEDY_SELECT;
            }
        }
        return regex;
    }

    /**
     * Validates the matcher for the given args, where args has no keywords.
     *
     * @param args  User input of task to add.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForNoKeyword(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        regex += REGEX_CLOSE_BRACE + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
        generateAndValidateMatcher(args, regex);
    }
    
    /**
     * Generates and validates a matcher from the given args and regex.
     *
     * @param args  User input of task to add.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateAndValidateMatcher(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        pattern = Pattern.compile(regex);
        matcher = pattern.matcher(args);
        if (!matcher.matches()) {
            logger.log(Level.FINE, "IllegalValueException thrown in CommandParserHelper, generateAndValidateMatcher, "
                    + "matcher does not match");
            throw new IllegalValueException(MESSAGE_INVALID_MATCHER);
        }
    }
    
    /**
     * Generates the matcher for the given escaped args, where args has no keyword.
     *
     * @param args  User input of task to add.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForNoKeywordEscape(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        regex += REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
        generateAndValidateMatcher(args, regex);
    }
    
    /**
     * Generates the matcher for the given escaped args, where args has one keyword.
     *
     * @param args  User input of task to add.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForOneKeywordEscape(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForOneKeywordEscape(regex);
        generateAndValidateMatcher(args, regexCopy);
    }

    /**
     * Generates the matcher for the given args, where args has one keyword.
     *
     * @param args  User input of task to add.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForOneKeyword(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForOneKeyword(regex);
        generateAndValidateMatcher(args, regexCopy);
    }
    
    /**
     * Generates the regex to match an escaped string with one keyword 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching one keyword.
     *
     * @param regex     Used to generate matcher.
     * @return regex    That matches an escaped string with one keyword.
     */
    private String generateRegexForOneKeywordEscape(String regex) {
        assert regex != null;
        return regex + REGEX_FIRST_DATE + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }

    /**
     * Generates the regex to match an string with one keyword 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching one keyword.
     *
     * @param regex     Used to generate matcher.
     * @return regex    That matches a string with one keyword.
     */
    private String generateRegexForOneKeyword(String regex) {
        assert regex != null;
        return regex + REGEX_CLOSE_BRACE + REGEX_FIRST_DATE + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }
    
    /**
     * Sets start date or end date depending on which matcher group was matched
     * @param regex  Used to generate matcher.
     */
    private void matcherSetStartOrEndDate(OptionalStringTask task) {
        assert task != null && matcher != null;
        task.startDate = matchesStartDateFormatsOneToThree();
        task.endDate = matchesEndDateFormatsOneToThree();
        assert task.startDate.isPresent() ^ task.endDate.isPresent();
    }
    
    /**
     * Reinitialises both start date and end date to be empty.
     *
     * @param task  Object to store values for startDate and endDate.
     */
    private void reinitialiseStartAndEndDatesToEmpty(OptionalStringTask task) {
        assert task != null;
        task.startDate = Optional.empty();
        task.endDate = Optional.empty();
    }
    
    /**
     * Verifies if either startDate or endDate is present, and if either dates are present,
     * then verifies whether the date is valid.
     *
     * @param startDate User input of start date. May not exist if user did not input start date.
     * @param endDate   User input of end date. May not exist if user did not input end date.
     * @return          True if the date that is present is valid.
     */
    private boolean startOrEndDateIsInvalid(Optional<String> startDate, Optional<String> endDate) {
        return startDate.isPresent() && !DateTime.isValidDate(startDate.get())
                || endDate.isPresent() && !DateTime.isValidDate(endDate.get());
    }
    
    /**
     * Checks whether any of the matcher groups for start date are present. 
     * Either none of the matcher groups are present, or only one matcher group is present. 
     * Return the value stored in the matcher group if it is present, else return Optional.empty().
     *
     * @return  The value of the matcher group if it is present, else return Optional.empty().
     */
    private Optional<String> matchesStartDateFormatsOneToThree() {
        assert matcher != null;

        Optional<String> startDate = Optional.empty();

        if (matcher.group(START_DATE_FORMAT_ONE) != null) {
            startDate = Optional.of(matcher.group(START_DATE_FORMAT_ONE).trim());
        } else if (matcher.group(START_DATE_FORMAT_TWO) != null) {
            startDate = Optional.of(matcher.group(START_DATE_FORMAT_TWO).trim());
        } else if (matcher.group(START_DATE_FORMAT_THREE) != null) {
            startDate = Optional.of(matcher.group(START_DATE_FORMAT_THREE).trim());
        }

        return startDate;
    }
    
    /**
     * Checks whether any of the matcher groups for end date are present. 
     * Either none of the matcher groups are present, or only one matcher group is present. 
     * Return the value of the matcher group if it is present, else return Optional.empty().
     *
     * @return  The value of the matcher group if it is present, else return Optional.empty().
     */
    private Optional<String> matchesEndDateFormatsOneToThree() {
        assert matcher != null;

        Optional<String> endDate = Optional.empty();

        if (matcher.group(END_DATE_FORMAT_ONE) != null) {
            endDate = Optional.of(matcher.group(END_DATE_FORMAT_ONE).trim());
        } else if (matcher.group(END_DATE_FORMAT_TWO) != null) {
            endDate = Optional.of(matcher.group(END_DATE_FORMAT_TWO).trim());
        } else if (matcher.group(END_DATE_FORMAT_THREE) != null) {
            endDate = Optional.of(matcher.group(END_DATE_FORMAT_THREE).trim());
        }

        return endDate;
    }

    /**
     * Generates the matcher for the given escaped args, where args has two keywords.
     *
     * @param args  User input of task to add.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForTwoKeywordsEscape(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForTwoKeywordsEscape(regex);
        generateAndValidateMatcher(args, regexCopy);
    }

    /**
     * Generates the matcher for the given args, where args has two keywords.
     *
     * @param args  User input of task to add.
     * @param regex Used to generate matcher.
     * @throws IllegalValueException  If args does not match the matcher.
     */
    private void generateMatcherForTwoKeywords(String args, String regex) throws IllegalValueException {
        assert args != null && regex != null;
        String regexCopy = generateRegexForTwoKeywords(regex);
        generateAndValidateMatcher(args, regexCopy);
    }
    
    /**
     * Generates the regex to match an escaped string with two keywords 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching two keywords.
     *
     * @param regex     Used to generate matcher.
     * @return regex    That matches an escaped string with two keywords.
     */
    private String generateRegexForTwoKeywordsEscape(String regex) {
        assert regex != null;
        return regex + REGEX_FIRST_DATE + REGEX_SECOND_DATE
                + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }

    /**
     * Generates the regex to match a string with two keywords 
     * by concatenating the given regex generated by generateStartOfRegex() 
     * with the regex for matching two keywords.
     *
     * @param regex     Used to generate matcher.
     * @return regex    That matches a string with two keywords.
     */
    private String generateRegexForTwoKeywords(String regex) {
        assert regex != null;
        return regex + REGEX_CLOSE_BRACE + REGEX_FIRST_DATE + REGEX_SECOND_DATE
                + REGEX_RECURRENCE_PRIORITY_CLOSE_BRACE;
    }

    /**
     * Sets the Task's end date if user input is valid.
     *
     * @param task  Object to store values for startDate and endDate.
     * @throws IllegalValueException    If user input contains repeated end date or repeated start date.
     */
    private void matcherSetEndDate(OptionalStringTask task) throws IllegalValueException {
        assert task != null;
        if (isRepeatedEndDate(task)) { 
            logger.log(Level.FINE, "IllegalValueException thrown in CommandParserHelper, matcherSetEndDate, repeated end time");
            throw new IllegalValueException(MESSAGE_REPEATED_END_TIME);
        } else {
            task.endDate = matchesEndDateFormatsFourToSix();
            if (isEndDateUnmatched(task)) {
                logger.log(Level.FINE, "IllegalValueException thrown in CommandParserHelper, matcherSetEndDate, repeated start time");
                throw new IllegalValueException(MESSAGE_REPEATED_START_TIME);
            }
        }
    }

    /**
     * Checks if end date is repeated in user input.
     * For e.g, "by 1030pm by 1050pm" is not allowed.
     * Since setStartOrEndDate(OptionalStringTask) would have set a start or end date,
     * thus if end date is present (i.e was set previously), it implies that end date is repeated.
     *
     * @param task  Object to store values for startDate and endDate.
     * @return      True if endDate is present, else returns false.
     */
    private boolean isRepeatedEndDate(OptionalStringTask task) {
        assert task != null;
        return task.endDate.isPresent();
    }

    /**
     * Checks if end date is still unmatched.
     * This may happen in cases like "from 1030pm from 1050pm", which is not allowed.
     * Thus if end date is still absent, it implies that start date is repeated.
     *
     * @param task  Object to store values for startDate and endDate.
     * @return      True if endDate is present, else returns false.
     */
    private boolean isEndDateUnmatched(OptionalStringTask task) {
        assert task != null;
        return !task.endDate.isPresent();
    }

    /**
     * Put all the values of parameters in task into a HashMap, and returns the HashMap.
     * 
     * @param task  OptionalStringTask object that contains String values to be converted to 
     *              an actual Task object.
     * @return      Map containing the values of parameters in task.
     */
    private HashMap<String, Optional<String>> mapContainingVariables(OptionalStringTask task) {
        assert task != null;
        HashMap<String, Optional<String>> map = new HashMap<String, Optional<String>>();
        
        map.put(Name.getMapNameKey(), task.taskName);
        map.put(DateTime.getMapStartDateKey(), task.startDate);
        map.put(DateTime.getMapEndDateKey(), task.endDate);
        map.put(RecurrenceRate.getMapRateKey(), task.rate);
        map.put(TimePeriod.getTimePeriodKey(), task.timePeriod);
        map.put(Priority.getMapPriorityKey(), task.priority);
        
        return map;
    }
    
    /**
     * Returns a HashMap containing user's input of rate and timePeriod.
     * 
     * @return  HashMap containing user's input of rate and timePeriod.
     *          If user did not input any fields, return Optional.empty() for the field in HashMap.
     */
    private HashMap<String, Optional<String>> matchesRateAndTimePeriod() throws IllegalValueException {
        HashMap<String, Optional<String>> map = new HashMap<String, Optional<String>>();

        Optional<String> rate = Optional.empty();
        Optional<String> timePeriod = Optional.empty();

        if (matcher.group(RATE) != null) {
            rate = Optional.of(matcher.group(RATE).trim());
        }

        if (matcher.group(TIME_PERIOD) != null) {
            timePeriod = Optional.of(matcher.group(TIME_PERIOD).trim());
        }
            
        map.put(RATE, rate);
        map.put(TIME_PERIOD, timePeriod);

        return map;
    }

    /**
     * Checks whether any of the matcher groups for end date are present. 
     * Either none of the matcher groups are present, or only one matcher group is present. 
     * Return the value of the matcher group if it is present, else return Optional.empty().
     *
     * @return  The value of the matcher group if it is present, else return Optional.empty().
     */
    private Optional<String> matchesEndDateFormatsFourToSix() {
        assert matcher != null;

        Optional<String> endDate = Optional.empty();

        if (matcher.group(END_DATE_FORMAT_FOUR) != null) {
            endDate = Optional.of(matcher.group(END_DATE_FORMAT_FOUR).trim());
        } else if (matcher.group(END_DATE_FORMAT_FIVE) != null) {
            endDate = Optional.of(matcher.group(END_DATE_FORMAT_FIVE).trim());
        } else if (matcher.group(END_DATE_FORMAT_SIX) != null) {
            endDate = Optional.of(matcher.group(END_DATE_FORMAT_SIX).trim());
        }

        return endDate;
    }

    /**
     * Returns user's trimmed input of priority.
     * 
     * @return  User's trimmed input of priority. If user did not specify a priority,
     *          by default, return "medium".
     */
    private String matchesPriority() {
        String priority;
        if (matcher.group(PRIORITY) != null) {
            priority = matcher.group(PRIORITY).trim();
        } else {
            priority = "medium";
        }
        return priority;
    }

```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
    /**
     * Assigns values into Task's parameters.
     * 
     * @param task  OptionalStringTask object that contains String values to be converted to 
     *              an actual Task object.
     */
    private void assignTaskParameters(OptionalStringTask task) throws IllegalValueException {
        assert matcher.group(TASK_NAME) != null && task != null;
        task.taskName = Optional.of(matcher.group(TASK_NAME).trim());
        HashMap<String, Optional<String>> recurrenceRateMap = matchesRateAndTimePeriod();
        task.rate = recurrenceRateMap.get(RATE);
        task.timePeriod = recurrenceRateMap.get(TIME_PERIOD);
        task.priority = Optional.of(matchesPriority());
    }
    
    public static String getMessageRepeatedStartTime() {
        return MESSAGE_REPEATED_START_TIME;
    }
    
    public static String getMessageRepeatedEndTime() {
        return MESSAGE_REPEATED_END_TIME;
    }

```
###### \java\seedu\address\logic\parser\CommandParserHelper.java
``` java
    /*
     * A simplified version of Task class, having all parameters stored as String objects.
     */
    private class OptionalStringTask {
        public Optional<String> taskName;
        public Optional<String> startDate;
        public Optional<String> endDate;
        public Optional<String> rate;
        public Optional<String> timePeriod;
        public Optional<String> priority;
        
        public OptionalStringTask() {
            taskName = startDate = endDate = rate = timePeriod = priority = Optional.empty();
        }
    }
}
```
###### \java\seedu\address\model\item\DateTime.java
``` java
/**
 * Contains methods that works with Date objects in addition to what is given in Java Date API.
 */
public abstract class DateTime {
    
    private final static Logger logger = LogsCenter.getLogger(DateTime.class);
    
    /** Name of key in map that maps to the start date of task */
    private static final String MAP_START_DATE_KEY = "startDate";
    /** Name of key in map that maps to the end date of task */
    private static final String MAP_END_DATE_KEY = "endDate";

    private static final String MONDAY = "monday";
    private static final String TUESDAY = "tuesday";
    private static final String WEDNESDAY = "wednesday";
    private static final String THURSDAY = "thursday";
    private static final String FRIDAY = "friday";
    private static final String SATURDAY = "saturday";
    private static final String SUNDAY = "sunday";
    
    private static final String TIME = "EXPLICIT_TIME";
    private static final String DATE_FORMAT_ONE = "EXPLICIT_DATE";
    private static final String DATE_FORMAT_TWO = "RELATIVE_DATE";

    private static final int NEGATIVE_ONE = -1;
    private static final int BASE_INDEX = 0;
    private static final int ONE = 1;

    private static final int NUMBER_OF_DAYS_IN_A_WEEK = 7;
    
    private static final String MESSAGE_VALUE_CONSTRAINTS = "DATE_TIME format: "
            + "DATE must be in one of the formats: "
            + "\"13th Sep 2015\", \"02-08-2015\" (mm/dd/yyyy) \n"
            + "TIME must be in one of the formats: "
            + "\"7:30am\", \"19:30\"";

    /**
     * Converts given String into a valid Date object.
     * 
     * @param dateString    User's input for date.
     * @return              Date representation converted from given String.
     * @throws IllegalValueException    If dateString cannot be converted into a Date object.
     */
    public static Date convertStringToDate(String dateString) throws IllegalValueException {
        assert dateString != null;
        
        if (isValidDate(dateString)) {
            List<DateGroup> dates = new Parser().parse(dateString);
            Date date = dates.get(BASE_INDEX).getDates().get(BASE_INDEX);
            return date;
        } else {
            logger.log(Level.FINE, "IllegalValueException thrown in DateTime, convertStringToDate, "
                    + "date is invalid");
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if given string contains date value (e.g, "30th Dec 2015").
     * 
     * @param dateString    User's input for date.
     * @return  true        If given string contains date value. Else, return false.
     * @throws IllegalValueException    If dateString cannot be converted into a Date object.
     */
    public static boolean hasDateValue(String dateString) throws IllegalValueException {
        assert dateString != null;
        
        if (isValidDate(dateString)) {
            List<DateGroup> dates = new Parser().parse(dateString);
            String syntaxTree = dates.get(BASE_INDEX).getSyntaxTree().toStringTree();

            if (syntaxTree.contains(DATE_FORMAT_ONE) || syntaxTree.contains(DATE_FORMAT_TWO)) {
                return true;
            } else {
                return false;
            }
        } else {
            logger.log(Level.FINE, "IllegalValueException thrown in DateTime, hasDateValue, "
                    + "date is invalid");
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
    }
    
    /**
     * Returns true if given string contains time value (e.g, "11:30am").
     * 
     * @param dateString    User's input for date.
     * @return              True if given string contains time value. Else, return false.
     * @throws IllegalValueException    If dateString cannot be converted into a Date object.
     */
    public static boolean hasTimeValue(String dateString) throws IllegalValueException {
        assert dateString != null;
        
        if (isValidDate(dateString)) {
            List<DateGroup> dates = new Parser().parse(dateString);
            String syntaxTree = dates.get(BASE_INDEX).getSyntaxTree().toStringTree();

            if (syntaxTree.contains(TIME)) {
                return true;
            } else {
                return false;
            }
        } else {
            logger.log(Level.FINE, "IllegalValueException thrown in DateTime, hasTimeValue, "
                    + "date is invalid");
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
    }
    
    /**
     * Sets endDate to have the same date, month and year as the startDate.
     * If upon setting and endDate is of earlier time than startDate, 
     * then set endDate to be startDate + 1.
     * 
     * @param startDate Start date of Task.
     * @param endDate   End date of Task.
     * @return          Updated value of endDate.
     */
    public static Date setEndDateToStartDate(Date startDate, Date endDate) {
        assert startDate != null && endDate != null;
        Calendar calendarStartDate = Calendar.getInstance();
        calendarStartDate.setTime(startDate);
        int date = calendarStartDate.get(Calendar.DATE);
        int month = calendarStartDate.get(Calendar.MONTH);
        int year = calendarStartDate.get(Calendar.YEAR);

        Calendar calendarEndDate = Calendar.getInstance();
        calendarEndDate.setTime(endDate);
        calendarEndDate.set(Calendar.DATE, date);
        calendarEndDate.set(Calendar.MONTH, month);
        calendarEndDate.set(Calendar.YEAR, year);
        if (calendarEndDate.getTimeInMillis() <= calendarStartDate.getTimeInMillis()) {
            calendarEndDate.set(Calendar.DATE, date + ONE);
        } 
        
        Date updatedDate = calendarEndDate.getTime();
        return updatedDate;
    }

    /**
     * Returns true if given String conforms to what was specified in User Guide e.g 
     * "5pm tomorrow", "02/10/2016", "13 Sep 10pm".
     * 
     * @param dateString    User's input for date.
     * @return              True if given String conforms to what was specified in User Guide. Else, return false.
     */
    public static boolean isValidDate(String dateString) {
        assert dateString != null;
        List<DateGroup> dates = new Parser().parse(dateString.trim());
        try {
            int positionOfMatchingValue = dates.get(BASE_INDEX).getPosition();
            
            if (positionOfMatchingValue > ONE) {
                return false;
            }
        } catch (IndexOutOfBoundsException ioobe) {
            return false;
        }
        return true;
    }
    
    /**
     * Assigns start date to a specified weekday according to the given dateString.
     * 
     * @param dateString    User's input for date.
     * @throws IllegalValueException    If dateString is not a weekday.
     */
    public static Date assignStartDateToSpecifiedWeekday(String dateString) throws IllegalValueException {
        assert dateString != null; 
                
        String lowerCaseDateString = dateString.toLowerCase();
        
        if (lowerCaseDateString.equals(MONDAY) || lowerCaseDateString.equals(TUESDAY) || 
                lowerCaseDateString.equals(WEDNESDAY) || lowerCaseDateString.equals(THURSDAY) || 
                lowerCaseDateString.equals(FRIDAY) || lowerCaseDateString.equals(SATURDAY) || 
                lowerCaseDateString.equals(SUNDAY)) {
        
            List<DateGroup> dates = new Parser().parse(dateString);
            Date date = dates.get(BASE_INDEX).getDates().get(BASE_INDEX);
            date = setTimeToStartOfDay(date);
            date = correctDateIfSameDay(date);
        
            return date;
        } else {
            logger.log(Level.FINE, "IllegalValueException thrown in DateTime, assignStartDateToSpecifiedWeekday, "
                    + "dateString is not a week day");
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
    }

    /**
     * Corrects date if it is same day as today. For e.g, if today is Tuesday, and user input "foo repeat every Tuesday",
     * the starting date will be set to next Tuesday which is false. This method corrects the date to today.
     * 
     * @param date  Date value of Task.
     * @return      Same date if date not equals today's date. Else, return date minus 7 days.
     */
    private static Date correctDateIfSameDay(Date date) {
        assert date != null;
        
        Calendar temp = Calendar.getInstance();
        Calendar actual = Calendar.getInstance();
        actual.setTime(date);
        
        if (actual.get(Calendar.DAY_OF_WEEK) == temp.get(Calendar.DAY_OF_WEEK)) {
            actual.add(Calendar.DATE, NUMBER_OF_DAYS_IN_A_WEEK * NEGATIVE_ONE);
            date = actual.getTime();
        }
        
        return date;
    }
    
    /**
     * Sets time of Date object to start of the day i.e "00:00:00" and returns it.
     * 
     * @param date  Date value of Task.
     * @return date With time values set to start of the day.
     */
    public static Date setTimeToStartOfDay(Date date) {
        assert date != null;
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        
        Date updatedDate = calendar.getTime();
        return updatedDate;
    }

    /**
     * Sets time of Date object to end of the day i.e "23:59:59"
     * 
     * @param date  Date value of Task.
     * @return date With time values set to end of the day.
     */
    public static Date setTimeToEndOfDay(Date date) {
        assert date != null;
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.set(Calendar.HOUR_OF_DAY, 23);
        calendar.set(Calendar.MINUTE, 59);
        calendar.set(Calendar.SECOND, 59);
        
        Date updatedDate = calendar.getTime();
        return updatedDate;
    }
    
    /**
     * Updates date according to recurrence rate.
     * 
     * @param date              Date value of Task.
     * @param recurrenceRate    Recurrence rate of Task.
     * @return                  Date with updated values according to recurrence rate.
     */
    public static Date updateDateByRecurrenceRate(Date date, RecurrenceRate recurrenceRate) {
        assert date != null && recurrenceRate != null;
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        int rate = recurrenceRate.getRate();
        
        switch (recurrenceRate.getTimePeriod()) {
        case HOUR :
            calendar.add(Calendar.HOUR_OF_DAY, rate);
            break;
        case DAY :
            calendar.add(Calendar.DAY_OF_YEAR, rate);
            break;
        case WEEK :
            calendar.add(Calendar.WEEK_OF_YEAR, rate);
            break;
        case MONTH :
            calendar.add(Calendar.MONTH, rate);
            break;
        case YEAR :
            calendar.add(Calendar.YEAR, rate);
            break;
        case MONDAY :
            updateCalendarToComingSpecifiedDay(calendar, MONDAY, rate);
            break;
        case TUESDAY :
            updateCalendarToComingSpecifiedDay(calendar, TUESDAY, rate);
            break;
        case WEDNESDAY :
            updateCalendarToComingSpecifiedDay(calendar, WEDNESDAY, rate);
            break;
        case THURSDAY :
            updateCalendarToComingSpecifiedDay(calendar, THURSDAY, rate);
            break;
        case FRIDAY :
            updateCalendarToComingSpecifiedDay(calendar, FRIDAY, rate);
            break;
        case SATURDAY :
            updateCalendarToComingSpecifiedDay(calendar, SATURDAY, rate);
            break;
        case SUNDAY :
            updateCalendarToComingSpecifiedDay(calendar, SUNDAY, rate);
            break;
        }
        
        date = calendar.getTime();
        return date;
    }
    
    /**
     * Updates calendar to coming Mondays depending on value of rate.
     * 
     * @param calendar  Calendar representation of the date value of Task.
     * @param rate      Amount of Mondays to jump over.
     */
    private static void updateCalendarToComingSpecifiedDay(Calendar calendar, String day, int rate) {
        assert calendar != null;
        updateDateRateMinusOneTimes(calendar, rate);

        calendar.add(Calendar.DATE, ONE);
        
        try {
            Class c = Class.forName("java.util.Calendar");
            Field specifiedDayOfWeek = c.getDeclaredField(day.toUpperCase());
            Integer valueOfSpecifiedDayOfWeek = (Integer) specifiedDayOfWeek.get(calendar);
            
            while (calendar.get(Calendar.DAY_OF_WEEK) != valueOfSpecifiedDayOfWeek) {
                calendar.add(Calendar.DATE, ONE);
            }
        } catch (ClassNotFoundException | NoSuchFieldException | SecurityException | IllegalAccessException e) {
            System.out.println("Here");
        }
    }
    
    /**
     * Updates calendar by (rate - 1) * 7 days.
     * 
     * @param calendar  Calendar representation of the date value of Task.
     * @param rate      Amount of weeks to jump over.
     */
    private static void updateDateRateMinusOneTimes(Calendar calendar, int rate) {
        assert calendar != null;
        if (rate > ONE) {
            calendar.add(Calendar.DATE, (rate - ONE) * NUMBER_OF_DAYS_IN_A_WEEK);
        }
    }
    
    public static String getMessageValueConstraints() {
        return MESSAGE_VALUE_CONSTRAINTS;
    }
    
    /** 
     * @return The key in map that maps to the start date of task.
     */
    public static String getMapStartDateKey() {
        return MAP_START_DATE_KEY;
    }
    
    /** 
     * @return The key in map that maps to the end date of task.
     */
    public static String getMapEndDateKey() {
        return MAP_END_DATE_KEY;
    }
}
```
###### \java\seedu\address\model\item\Name.java
``` java
/**
 * Represents a Task's name in the task manager.
 * Guarantees: immutable
 */
public class Name {

    /** Name of key in map that maps to the task name of task */
    private static final String MAP_TASK_NAME_KEY = "taskName";
    
    private String taskName;
    
    public Name(String name) {
        assert name != null;
        name = name.trim();
        this.taskName = name;
    }
    
    public String getTaskName() {
        return taskName;
    }
    
    /** 
     * @return  The key in map that maps to the task name of task.
     */
    public static String getMapNameKey() {
        return MAP_TASK_NAME_KEY;
    }

    @Override
    public String toString() {
        return this.taskName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.taskName.equals(((Name) other).taskName)); // state check
    }

    @Override
    public int hashCode() {
        return taskName.hashCode();
    }

    public int compareTo(Name other) {
        return taskName.compareTo(other.taskName);
    }
}
```
###### \java\seedu\address\model\item\RecurrenceRate.java
``` java
/**
 * Represents a Task's recurrence rate in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #RecurrenceRate(String, String)}
 */
public class RecurrenceRate {
    
    /** Name of key in map that maps to the recurrence rate of task */
    private static final String MAP_RECURRENCE_RATE_KEY = "recurrenceRate";
    /** Name of key in map that maps to the rate of recurrence rate */
    private static final String MAP_RATE_KEY = "rate";
    
    private static final int ZERO = 0;
    private static final int ONE = 1;
    private static final String STRING_CONSTANT_ONE = "1";

    private static final String MESSAGE_VALUE_CONSTRAINTS = "RECURRING_INTERVAL Format : repeat every [RATE] TIME_PERIOD\n"
            + "RATE must be a positive integer and TIME_PERIOD must be in one of the formats: "
            + "\"hour(s)\", \"day(s)\", \"week(s)\", \"month(s)\", \"year(s)\", "
            + "or days of the week such as \"Monday\", \"Wed\"\n"
            + "For example: \"repeat every 3 days\", \"repeat every week\", \"repeat every Wed\"";

    private Integer rate;
    private TimePeriod timePeriod;

    /**
     * Constructor for RecurrenceRate. 
     * Checks for validity of rate and timePeriod.
     *
     * @throws IllegalValueException    If either values are invalid.
     */
    public RecurrenceRate(String rateString, String timePeriodString) throws IllegalValueException {
        assert rateString != null && timePeriodString != null;
        
        Optional<TimePeriod> timePeriod = TimePeriod.convertStringToTimePeriod(timePeriodString.trim());
        this.timePeriod = timePeriod.orElseThrow(() -> new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS));
        this.rate = convertStringToRateInteger(rateString);
    }
    
    public RecurrenceRate(String timePeriod) throws IllegalValueException {
        this(STRING_CONSTANT_ONE, timePeriod);
    }

    /**
     * Converts rate from String to Integer.
     *
     * @param rateString    User input of rate of recurrence.
     * @return              Integer value of rate.
     * @throws IllegalValueException    If rate cannot be converted into an Integer
     * or rate <= 0.
     */
    private Integer convertStringToRateInteger(String rateString) throws IllegalValueException {
        assert rateString != null;
        int rateInteger;
        
        try {
            rateInteger = Integer.valueOf(rateString);
        } catch (NumberFormatException nfe) {
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
        
        if (rateInteger <= 0) {
            throw new IllegalValueException(MESSAGE_VALUE_CONSTRAINTS);
        }
        
        return rateInteger;
    }
    
    public static String getMessageValueConstraints() {
        return MESSAGE_VALUE_CONSTRAINTS;
    }
    
    public Integer getRate() {
        return rate;
    }
    
    public TimePeriod getTimePeriod() {
        return timePeriod;
    }
    
    @Override
    public String toString() {
        return "Every " + (rate == ONE ? "" : rate.toString() + " ")
                + timePeriod.toString().substring(ZERO, ONE).toUpperCase() + timePeriod.toString().substring(ONE).toLowerCase()
                + (rate.intValue() > ONE ? "s" : "");
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RecurrenceRate // instanceof handles nulls
                && this.rate.equals(((RecurrenceRate) other).rate) // state check
                && this.timePeriod.equals(((RecurrenceRate) other).timePeriod));
    }

    @Override
    public int hashCode() {
        return rate.hashCode();
    }
    
    /** 
     * @return The key in map that maps to the recurrence rate of task.
     */
    public static String getMapRecurrenceRateKey() {
        return MAP_RECURRENCE_RATE_KEY;
    }
    
    /** 
     * @return The key in map that maps to the rate of recurrence rate.
     */
    public static String getMapRateKey() {
        return MAP_RATE_KEY;
    }
}
```
###### \java\seedu\address\model\item\Task.java
``` java
    /**
     * Updates the startDate and/or endDate of the completed recurring task.
     * 
     * @throws TaskNotRecurringException    If task does not have recurrence rate
     *                                      or does not have both start and end dates.
     */
    public void updateRecurringTask() throws TaskNotRecurringException {
        if (recurrenceRate == null || (startDate == null && endDate == null)) {
            throw new TaskNotRecurringException(MESSAGE_RECURRING_TASK_CONSTRAINTS);
        }

        if (startDate != null && endDate == null) {
            startDate = DateTime.updateDateByRecurrenceRate(startDate, recurrenceRate);
        } else if (startDate == null && endDate != null) {
            endDate = DateTime.updateDateByRecurrenceRate(endDate, recurrenceRate);
        } else if (startDate != null && endDate != null) {
            int timeDifference = (int) (endDate.getTime() - startDate.getTime());
            startDate = DateTime.updateDateByRecurrenceRate(startDate, recurrenceRate);
            endDate = updateEndDate(timeDifference);
        }
    }

    /**
     * Updates endDate using the timeDifference between startDate and endDate.
     * 
     * @param timeDifference    The difference in milliseconds between end date and start date.
     * @return                  Updated value of endDate.
     */
    private Date updateEndDate(int timeDifference) {
        assert timeDifference >= 0;
        
        Calendar endCalendar = Calendar.getInstance();
        endCalendar.setTime(startDate);
        endCalendar.add(Calendar.MILLISECOND, timeDifference);
        Date date = endCalendar.getTime();

        return date;
    }

```
###### \java\seedu\address\model\item\TimePeriod.java
``` java
/**
 * Represents a RecurrenceRate's time period.  
 * Guarantees: is valid as declared in {@link #convertStringToTimePeriod(String)}
 */
public enum TimePeriod {
    HOUR,
    DAY,
    WEEK,
    MONTH,
    YEAR,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;
    
    /** Name of key in map that maps to the time period of recurrence rate */
    private static final String MAP_TIME_PERIOD_KEY = "timePeriod";
    
    /**
     * Map containing valid user inputs and which values these inputs are mapped to.
     */
    public static final HashMap<String, TimePeriod> INPUT_TO_TIME_PERIOD_MAP = new HashMap<String, TimePeriod>() {{
        put("hour", TimePeriod.HOUR);
        put("hours", TimePeriod.HOUR);
        put("day", TimePeriod.DAY);
        put("days", TimePeriod.DAY);
        put("week", TimePeriod.WEEK);
        put("weeks", TimePeriod.WEEK);
        put("month", TimePeriod.MONTH);
        put("months", TimePeriod.MONTH);
        put("year", TimePeriod.YEAR);
        put("years", TimePeriod.YEAR);
        put("mon", TimePeriod.MONDAY);
        put("monday", TimePeriod.MONDAY);
        put("tue", TimePeriod.TUESDAY);
        put("tues", TimePeriod.TUESDAY);
        put("tuesday", TimePeriod.TUESDAY);
        put("wed", TimePeriod.WEDNESDAY);
        put("wednesday", TimePeriod.WEDNESDAY);
        put("thur", TimePeriod.THURSDAY);
        put("thurs", TimePeriod.THURSDAY);
        put("thursday", TimePeriod.THURSDAY);
        put("fri", TimePeriod.FRIDAY);
        put("friday", TimePeriod.FRIDAY);
        put("sat", TimePeriod.SATURDAY);
        put("saturday", TimePeriod.SATURDAY);
        put("sun", TimePeriod.SUNDAY);
        put("sunday", TimePeriod.SUNDAY);
    }};
    
    /**
     * Converts user input into TimePeriod if valid.
     *
     * @param timePeriodString  User input of time period.
     * @return                  Optional.empty() if user input does not match any time period.
     *                          Else, returns the corresponding TimePeriod value.
     */
    public static Optional<TimePeriod> convertStringToTimePeriod(String timePeriodString) {
        assert timePeriodString != null;
        
        Optional<TimePeriod> timePeriod = Optional.empty();
        
        for (String key : INPUT_TO_TIME_PERIOD_MAP.keySet()) {
            if (key.equals(timePeriodString.toLowerCase())) {
                timePeriod = Optional.of(INPUT_TO_TIME_PERIOD_MAP.get(key));
            }
        }
        return timePeriod;
    }
    
    /** 
     * @return The key in map that maps to the time period of recurrence rate.
     */
    public static String getTimePeriodKey() {
        return MAP_TIME_PERIOD_KEY;
    }
}
```
