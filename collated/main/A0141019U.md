# A0141019U
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends Command {
	public static final String COMMAND_WORD = "redo";

	// TODO better message
	public static final String MESSAGE_REDO_SUCCESS = "Redid last undo successfully";
	public static final String MESSAGE_REDO_FAIL = "No more actions to redo";

	public RedoCommand() {}

	@Override
	public CommandResult execute() {
		try {
			model.loadNextState();
			return new CommandResult(MESSAGE_REDO_SUCCESS);
		}
		catch (EmptyStackException e) {
			return new CommandResult(MESSAGE_REDO_FAIL);
		}
	}
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {
	public static final String COMMAND_WORD = "undo";

	public static final String MESSAGE_UNDO_SUCCESS = "Undid last command successfully";
	public static final String MESSAGE_UNDO_FAIL = "No more actions to undo";

	public UndoCommand() {}

	@Override
	public CommandResult execute() {
		try {
			model.loadPreviousState();
			return new CommandResult(MESSAGE_UNDO_SUCCESS);
		}
		catch (EmptyStackException e) {
			return new CommandResult(MESSAGE_UNDO_FAIL);
		}
	}
}
```
###### \java\seedu\address\logic\parser\DateParser.java
``` java
public class DateParser {

	private static final Pattern[] STANDARD_DATE_FORMATS = new Pattern[] {
			Pattern.compile("(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{4})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MM-yyyy HH:mm am
			Pattern.compile("(?<year>\\d{4})-(?<month>\\d{1,2})-(?<day>\\d{1,2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // yyyy-MM-dd HH:mmpm
			Pattern.compile("(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MM-yy HH:mm pm
			Pattern.compile("(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{4})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MMM-yyyy HH:mm am
			Pattern.compile("(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MMM-yy HH:mm am

			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{4})"), // HH:mm am dd-MM-yyyy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<year>\\d{4})-(?<month>\\d{1,2})-(?<day>\\d{1,2})"), // HH:mmpm yyyy-MM-dd 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{2})"), // HH:mm pm dd-MM-yy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{4})"), // HH:mm am dd-MMM-yyyy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{2})") // HH:mm am dd-MMM-yy 
	};

	private static final Pattern[] NATURAL_LANGUAGE = new Pattern[] {
			Pattern.compile("(?<day>today|tomorrow|next week)?\\s*(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // tomorrow 2:30 pm
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s*(?<day>today|tomorrow|next week)?") // 2pm tomorrow
	};

	
	/**
	 * @return LocalDateTime if valid date format
	 * @throws ParseException if unable to parse
	 */
	public static LocalDateTime parse(String dateString) throws ParseException {
		dateString = dateString.trim();

		LocalDateTime dateTime = parseNaturalLanguage(dateString);
		if (dateTime == null) {
			dateTime = parseStandardFormat(dateString);
		}
		
		if (dateTime == null) {
			throw new ParseException("Failed to parse date and time.", -1);
		}
		else {
			System.out.println("date parser result: " + dateTime);
			return dateTime;
		}
	}

	private static LocalDateTime parseNaturalLanguage(String dateString) throws ParseException {
		ArrayList<Matcher> matchers = new ArrayList<>();
		for (int i=0; i<NATURAL_LANGUAGE.length; i++) {
			matchers.add(NATURAL_LANGUAGE[i].matcher(dateString));
		}
		
		LocalDateTime now = LocalDateTime.now();
		
		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				Optional<String> dayOpt = Optional.ofNullable(matcher.group("day"));
				String parsedDay = dayOpt.orElse("today");
				
				int year, month, day;
				switch(parsedDay) {
				case "today":
					year = now.getYear();
					month = now.getMonthValue();
					day = now.getDayOfMonth();
					break;
				case "tomorrow":
					year = now.getYear();
					month = now.plusDays(1).getMonthValue();
					day = now.plusDays(1).getDayOfMonth();
					break;
				case "next week":
					year = now.getYear();
					month = now.plusDays(7).getMonthValue();
					day = now.plusDays(7).getDayOfMonth();
					break;
				default:
					throw new ParseException("Day phrase is not today, tomorrow, or next week.", -1);
				}
				
				Optional<String> meridiemOpt = Optional.ofNullable(matcher.group("meridiem"));
				int hour = parseHour(matcher.group("hour"), meridiemOpt.orElse(""));
				
				Optional<String> minuteOpt = Optional.ofNullable(matcher.group("minute"));
				int minute = parseMinute(minuteOpt.orElse("0"));

				return LocalDateTime.of(year, month, day, hour, minute);
			}
		}

		// if matcher did not match
		return null;
	}
	

	private static LocalDateTime parseStandardFormat(String dateString) throws ParseException {
		ArrayList<Matcher> matchers = new ArrayList<>();
		for (int i=0; i<STANDARD_DATE_FORMATS.length; i++) {
			matchers.add(STANDARD_DATE_FORMATS[i].matcher(dateString));
		}

		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				int year = parseYear(matcher.group("year"));
				int month = parseMonth(matcher.group("month"));
				int day = parseDay(matcher.group("day"));
				
				Optional<String> meridiemOpt = Optional.ofNullable(matcher.group("meridiem"));
				int hour = parseHour(matcher.group("hour"), meridiemOpt.orElse(""));

				Optional<String> minuteOpt = Optional.ofNullable(matcher.group("minute"));
				int minute = parseMinute(minuteOpt.orElse("0"));

				return LocalDateTime.of(year, month, day, hour, minute);
			}
		}

		// if matcher did not match
		return null;
	}
	

	private static int parseYear(String yearString) {
		int year;
		if (yearString.length() == 2) {
			year = 2000 + Integer.parseInt(yearString);
		}
		else {
			year = Integer.parseInt(yearString);
		}

		return year;
	}

	private static int parseMonth(String wordMonth) throws ParseException {
		try {
			int month = Integer.parseInt(wordMonth);

			if (month < 1 || month > 12) {
				throw new ParseException("Month is not within valid bounds 1 - 12 inclusive", -1);
			}
			else {
				return month;
			}
		}
		catch (NumberFormatException e) {

			switch (wordMonth.toLowerCase()) {
			case "jan":
				return 1;
			case "feb":
				return 2;
			case "mar":
				return 3;
			case "apr":
				return 4;
			case "may":
				return 5;
			case "jun":
				return 6;
			case "jul":
				return 7;
			case "aug":
				return 8;
			case "sep":
				return 9;
			case "oct":
				return 10;
			case "nov":
				return 11;
			case "dec":
				return 12;
			default:
				throw new ParseException("Month is not an integer or one of the standard 3 letter abbreviations.", -1);
			}

		}
	}

	private static int parseDay(String dayString) throws ParseException {
		int day = Integer.parseInt(dayString);

		if (day < 1 || day > 31) {
			throw new ParseException("Day is not within valid bounds 1 - 31 inclusive", -1);
		}
		else {
			return day;
		}
	}

	private static int parseHour(String hour12, String meridiem) throws ParseException {
		meridiem = meridiem.toLowerCase();
		int hour;
		
		if (meridiem.equals("am") && hour12.equals("12")) {
			hour = 0;
		}
		else if (meridiem.equals("pm") && !hour12.equals("12")) {
			hour = 12 + Integer.parseInt(hour12);
		}
		else {
			hour = Integer.parseInt(hour12);
		}

		if (hour > 23) {
			throw new ParseException("Hour is not within valid bounds 0 - 23 inclusive", -1);
		}
		else {
			return hour;
		}
	}

	private static int parseMinute(String minuteString) throws ParseException {
		int minute = Integer.parseInt(minuteString);

		if (minute < 0 || minute > 60) {
			throw new ParseException("Minute is not within valid bounds 0 - 60 inclusive", -1);
		}
		else {
			return minute;
		}
	}
	
	public static void main(String[] args) {
		try {
			LocalDateTime date1 = DateParser.parse("12-12-12 05:00");
			System.out.println(date1.toString());
			LocalDateTime date2 = DateParser.parse("12-12-12 05:00");
			System.out.println(date2.toString());
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

	// Different regexps for different permutations of arguments
	private static final Pattern ADD_COMMAND_FORMAT_1 = Pattern
			.compile("(?i)(?<taskType>event|ev|deadline|dl|someday|sd)(?<addTaskArgs>.*)");
	private static final Pattern ADD_COMMAND_FORMAT_2 = Pattern
			.compile("(?i)(?<addTaskArgs>.*)(?<taskType>event|ev|deadline|dl|someday|sd)");

	
	private static final Pattern EVENT_ARGS_FORMAT_1 = Pattern.compile(
			"(?i)'(?<taskName>.*\\S+.*)'(\\s+on\\s+)?(?<date>\\S+)?\\s+from\\s+(?<startTime>\\S+\\s?\\S+)\\s+to\\s+(?<endTime>\\S+\\s?\\S+)");
	private static final Pattern EVENT_ARGS_FORMAT_2 = Pattern.compile(
			"(?i)'(?<taskName>.*\\S+.*)'\\s+from\\s+(?<startTime>\\S+\\s?\\S+)\\s+to\\s+(?<endTime>\\S+\\s?\\S+)(\\s+on\\s+)?(?<date>\\S+)?");
	private static final Pattern EVENT_ARGS_FORMAT_3 = Pattern.compile(
			"(?i)from\\s+(?<startTime>\\S+\\s?\\S+)\\s+to\\s+(?<endTime>\\S+\\s?\\S+)(\\s+on\\s+)?(?<date>\\S+)?\\s+'(?<taskName>.*\\S+.*)'");

	
	private static final Pattern DEADLINE_ARGS_FORMAT_1 = Pattern
			.compile("(?i)'(?<taskName>.*\\S+.*)'\\s+by\\s+(?<dateTime>.+)");
	private static final Pattern DEADLINE_ARGS_FORMAT_2 = Pattern
			.compile("(?i)by\\s+(?<dateTime>.+)\\s+'(?<taskName>.*\\S+.*)'");


	private static final Pattern SOMEDAY_ARGS_FORMAT = Pattern.compile("'(?<taskName>.*\\S+.*)'");

	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Command prepareAdd(String arguments) {
		ArrayList<Matcher> matchers = new ArrayList<>();
		matchers.add(ADD_COMMAND_FORMAT_1.matcher(arguments.trim()));
		matchers.add(ADD_COMMAND_FORMAT_2.matcher(arguments.trim()));

		// Null values will always be overwritten if the matcher matches.
		String taskType = null;
		String addTaskArgs = null;

		boolean isAnyMatch = false;

		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				isAnyMatch = true;
				taskType = matcher.group("taskType").trim();
				addTaskArgs = matcher.group("addTaskArgs").trim();
				
				break;
			}
		}

		if (!isAnyMatch) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}

		System.out.println("task type: " + taskType);
		System.out.println("add args: " + addTaskArgs);

		switch (taskType.toLowerCase()) {
		// TODO change hardcoded strings to references to strings in command
		// classes
		case "event":
		case "ev":
			return prepareAddEvent(addTaskArgs);

		case "deadline":
		case "dl":
			return prepareAddDeadline(addTaskArgs);

		case "someday":
		case "sd":
			return prepareAddSomeday(addTaskArgs);

		default:
			// TODO better error message
			return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
		}
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Command prepareAddEvent(String arguments) {
		arguments = arguments.trim();
		
		ArrayList<Matcher> matchers = new ArrayList<>();
		matchers.add(EVENT_ARGS_FORMAT_1.matcher(arguments));
		matchers.add(EVENT_ARGS_FORMAT_2.matcher(arguments));
		matchers.add(EVENT_ARGS_FORMAT_3.matcher(arguments));


		// Null values will always be overwritten if the matcher matches.
		String taskName = null;
		LocalDateTime startDateTime = null;
		LocalDateTime endDateTime = null;
		
		boolean isAnyMatch = false;
		
		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				isAnyMatch = true;

				taskName = matcher.group("taskName").trim();
			
				String startTime = matcher.group("startTime").trim();
				String endTime = matcher.group("endTime").trim();
				
				Optional<String> dateOpt = Optional.ofNullable(matcher.group("date"));
				String date = dateOpt.orElse("");
				
				try {
					System.out.println("start: " + date + " " + startTime);
					System.out.println("end: " + date + " " + endTime);
					
					startDateTime = DateParser.parse(date + " " + startTime);
					endDateTime = DateParser.parse(date + " " + endTime);
				} catch (ParseException e) {
					return new IncorrectCommand(e.getMessage());
				}				

				try {
					return new AddCommand(taskName, startDateTime, endDateTime);
				} catch (IllegalValueException e) {
					return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
				}
			}
		}

		if (!isAnyMatch) {
			System.out.println("no match");
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}

		try {
			return new AddCommand(taskName, startDateTime, endDateTime);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Command prepareAddDeadline(String arguments) {
		ArrayList<Matcher> matchers = new ArrayList<>();
		matchers.add(DEADLINE_ARGS_FORMAT_1.matcher(arguments.trim()));
		matchers.add(DEADLINE_ARGS_FORMAT_2.matcher(arguments.trim()));

		// Null values will always be overwritten if the matcher matches.
		String taskName = null;
		LocalDateTime dateTime = null;

		boolean isAnyMatch = false;

		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				isAnyMatch = true;

				taskName = matcher.group("taskName").trim();
				String dateTimeString = matcher.group("dateTime").trim();
				System.out.println("dateTimeString: " + dateTimeString);
				
				try {
					dateTime = DateParser.parse(dateTimeString);
				} catch (ParseException e) {
					return new IncorrectCommand(e.getMessage());
				}

				break;
			}
		}

		if (!isAnyMatch) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}

		System.out.println("task name: " + taskName);
		System.out.println("date: " + dateTime.toString());

		// TODO format date properly
		try {
			return new AddCommand(taskName, dateTime);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Command prepareAddSomeday(String arguments) {
		final Matcher matcher = SOMEDAY_ARGS_FORMAT.matcher(arguments.trim());
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}

		final String taskName = matcher.group("taskName").trim();
		System.out.println("task name: " + taskName);

		// TODO format date properly
		try {
			return new AddCommand(taskName);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(e.getMessage());
		}
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        if (args.equals("")) {
        	return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
    	
    	// keyphrases delimited by commas
        final String[] keyphrases = args.split(",");
        final Set<String> keyphraseSet = new HashSet<>(Arrays.asList(keyphrases));
        
        System.out.println("keyphrase set: " + keyphraseSet.toString());
        
        return new FindCommand(keyphraseSet);
    }

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	// Only supports task type and done|not-done options.
	private Command prepareList(String arguments) {
		if (arguments.equals("")) {
			return new ListCommand();
		}

		String[] args = arguments.split(" ");

		String taskType = null;
		String done = null;
		for (int i = 0; i < args.length; i++) {
			switch (args[i].trim()) {
			case "event":
			case "ev":
			case "deadline":
			case "dl":
			case "someday":
			case "sd":
				taskType = args[i];
				break;
			case "done":
			case "not-done":
				done = args[i];
				break;
			default:
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
			}
		}

		return new ListCommand(taskType, done);
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Parses arguments in the context of the delete task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
	private Command prepareDelete(String arguments) {
		int[] indices;
		try {
			indices = prepareIndexList(arguments);
		} catch (IncorrectCommandException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
		}
		return new DeleteCommand(indices);
	}

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Returns an ArrayList of the specified indices in the {@code command} IF
	 * positive unsigned integers are given. Returns an ArrayList with a single
	 * element {@code Optional.empty()} otherwise.
	 */
	private ArrayList<Optional<Integer>> parseIndices(String args) {
		String[] indexStrings = args.split(" ");
		ArrayList<Optional<Integer>> optionals = new ArrayList<>();

		for (int i = 0; i < indexStrings.length; i++) {
			System.out.println("parseIndices: " + indexStrings[i].trim());
			if (!StringUtil.isUnsignedInteger(indexStrings[i].trim())) {
				optionals = new ArrayList<>();
				optionals.add(Optional.empty());
				return optionals;
			}

			optionals.add(Optional.of(Integer.parseInt(indexStrings[i])));
		}

		return optionals;
	}

	public static void main(String[] args) {
		Parser p = new Parser();
		p.parseCommand("find bob, oh my darling, clementine");
	}
	
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    public void saveState() {
    	stateHistory.push(new TaskManager(taskManager));
    	// Allow redos only if the previous action is an undo
    	undoHistory.clear();
    }
    
    public void loadPreviousState() throws EmptyStackException {
    	TaskManager oldTaskManager = stateHistory.pop();
    	
    	undoHistory.push(new TaskManager(taskManager));
    	
    	taskManager.setTasks(oldTaskManager.getFilteredTasks());
    	taskManager.setTags(oldTaskManager.getTagList());
    	
    	indicateTaskManagerChanged();
    }
    
    public void loadNextState() throws EmptyStackException {
    	TaskManager oldTaskManager = undoHistory.pop();

    	stateHistory.push(new TaskManager(taskManager));
    	
    	taskManager.setTasks(oldTaskManager.getFilteredTasks());
    	taskManager.setTags(oldTaskManager.getTagList());
    	
    	indicateTaskManagerChanged();
    }
    
```
