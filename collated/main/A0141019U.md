# A0141019U
###### \java\seedu\address\commons\util\StringUtil.java
``` java
    /**
     * Returns number of occurrences of the character in a string
     */
    public static int countOccurrences(char character, String string) {
    	int numOccurrences = 0;
    	char[] charArray = string.toCharArray();
    	
    	for (int i=0; i<charArray.length; i++) {
    		if (charArray[i] == character) {
    			numOccurrences += 1;
    		}
    	}
    	
    	return numOccurrences;
    }
}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    public AddCommand(String name, String taskType, Optional<LocalDateTime> startDate, Optional<LocalDateTime> endDate, Set<String> tags) throws IllegalValueException {
    	final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
    	
    	this.toAdd = new Task(
        		new Name(name),
        		new TaskType(taskType),
        		new Status("pending"), 
        		startDate, 
        		endDate,
        		new UniqueTagList(tagSet)
         );
    }
    
    /**
     * Convenience constructor for event task using raw values
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    // TODO allow tag list as params
    public AddCommand(String name, LocalDateTime startDate, LocalDateTime endDate) throws IllegalValueException {
       	this.toAdd = new Task(
        		new Name(name),
        		new TaskType("event"),
        		new Status("pending"), 
        		Optional.of(startDate), 
        		Optional.of(endDate),
        		new UniqueTagList()
                );
    }
    
    /**
     * Convenience constructor for deadline task using raw values
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, LocalDateTime endDate) throws IllegalValueException {
    	this.toAdd = new Task(
        		new Name(name),
        		new TaskType("deadline"),
        		new Status("pending"), 
        		Optional.empty(), 
        		Optional.of(endDate),
        		new UniqueTagList()
                );
    	System.out.println("deadline added: " + toAdd);
    }
    
    /**
     * Convenience constructor for someday task using raw values
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name) throws IllegalValueException {
    	this.toAdd = new Task(
        		new Name(name),
        		new TaskType("someday"),
        		new Status("pending"), 
        		Optional.empty(), 
        		Optional.empty(),
        		new UniqueTagList()
                );
    }
    
    /**
     * Copy constructor.
     */
    public AddCommand(ReadOnlyTask source) {
        this.toAdd = new Task(source);
    }


    @Override
    public CommandResult execute() {
    	assert model != null;
        try {
        	EventsCenter.getInstance().post(new DisplayTaskListEvent(model.getFilteredTaskList()));
        	model.saveState();
            model.addTask(toAdd);
            raiseJumpToTaskEvent(toAdd);
            model.checkForOverdueTasks();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
        	// If adding was unsuccessful, then the state should not be saved - no change was made.
        	model.undoSaveState();
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }
    
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends Command {
	public static final String COMMAND_WORD = "redo";

	public static final String MESSAGE_REDO_SUCCESS = "Redid last undo successfully";
	public static final String MESSAGE_REDO_FAIL = "No actions to redo";

	public RedoCommand() {}

	@Override
	public CommandResult execute() {
		try {
			model.loadNextState();
			return new CommandResult(MESSAGE_REDO_SUCCESS);
		}
		catch (EmptyStackException e) {
			return new CommandResult(MESSAGE_REDO_FAIL);
		}
	}
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {
	public static final String COMMAND_WORD = "undo";

	public static final String MESSAGE_UNDO_SUCCESS = "Undid last command successfully";
	public static final String MESSAGE_UNDO_FAIL = "No actions to undo";

	public UndoCommand() {}

	@Override
	public CommandResult execute() {
		model.checkForOverdueTasks();
		try {
			model.loadPreviousState();
			return new CommandResult(MESSAGE_UNDO_SUCCESS);
		}
		catch (EmptyStackException e) {
			return new CommandResult(MESSAGE_UNDO_FAIL);
		}
	}
}
```
###### \java\seedu\address\logic\parser\DateParser.java
``` java
public class DateParser {

	private static final Pattern[] STANDARD_DATE_FORMATS = new Pattern[] {
			Pattern.compile("(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{4})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MM-yyyy HH:mm am
			Pattern.compile("(?<year>\\d{4})-(?<month>\\d{1,2})-(?<day>\\d{1,2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // yyyy-MM-dd HH:mmpm
			Pattern.compile("(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MM-yy HH:mm pm
			Pattern.compile("(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{4})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MMM-yyyy HH:mm am
			Pattern.compile("(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MMM-yy HH:mm am

			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{4})"), // HH:mm am dd-MM-yyyy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<year>\\d{4})-(?<month>\\d{1,2})-(?<day>\\d{1,2})"), // HH:mmpm yyyy-MM-dd 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>\\d{1,2})-(?<year>\\d{2})"), // HH:mm pm dd-MM-yy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{4})"), // HH:mm am dd-MMM-yyyy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})-(?<month>[a-z]{3})-(?<year>\\d{2})") // HH:mm am dd-MMM-yy 
	};

	private static final Pattern[] NATURAL_LANGUAGE = new Pattern[] {
			Pattern.compile("(?<day>[a-zA-Z\\s]+)?\\s*(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // tomorrow 2:30 pm
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s*(?<day>[a-zA-Z\\s]+)?") // 2pm tomorrow
	};

	
	/**
	 * @return LocalDateTime if valid date format
	 * @throws ParseException if unable to parse
	 */
	public static LocalDateTime parse(String dateString) throws ParseException {
		dateString = dateString.trim();
		
		System.out.println(dateString);
		
		LocalDateTime dateTime = parseNaturalLanguage(dateString);
		if (dateTime == null) {
			dateTime = parseStandardFormat(dateString);
		}
		
		if (dateTime == null) {
			throw new ParseException("Failed to parse date and time.", -1);
		}
		else {
			System.out.println("date parser result: " + dateTime);
			return dateTime;
		}
	}

	private static LocalDateTime parseNaturalLanguage(String dateString) throws ParseException {
		ArrayList<Matcher> matchers = new ArrayList<>();
		for (int i=0; i<NATURAL_LANGUAGE.length; i++) {
			matchers.add(NATURAL_LANGUAGE[i].matcher(dateString));
		}
		
		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				Optional<String> dayOpt = Optional.ofNullable(matcher.group("day"));
				System.out.println(dayOpt);
				String dayWord = dayOpt.orElse("today");
				LocalDateTime dayMonthYear = parseDayWord(dayWord);
				
				Optional<String> meridiemOpt = Optional.ofNullable(matcher.group("meridiem"));
				int hour = parseHour(matcher.group("hour"), meridiemOpt.orElse(""));
				
				Optional<String> minuteOpt = Optional.ofNullable(matcher.group("minute"));
				int minute = parseMinute(minuteOpt.orElse("0"));

				return LocalDateTime.of(dayMonthYear.getYear(), dayMonthYear.getMonth(), dayMonthYear.getDayOfMonth(), hour, minute);
			}
		}

		// if matcher did not match
		return null;
	}
	

	private static LocalDateTime parseStandardFormat(String dateString) throws ParseException {
		ArrayList<Matcher> matchers = new ArrayList<>();
		for (int i=0; i<STANDARD_DATE_FORMATS.length; i++) {
			matchers.add(STANDARD_DATE_FORMATS[i].matcher(dateString));
		}

		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				int year = parseYear(matcher.group("year"));
				int month = parseMonth(matcher.group("month"));
				int day = parseDayNumber(matcher.group("day"));
				
				Optional<String> meridiemOpt = Optional.ofNullable(matcher.group("meridiem"));
				int hour = parseHour(matcher.group("hour"), meridiemOpt.orElse(""));

				Optional<String> minuteOpt = Optional.ofNullable(matcher.group("minute"));
				int minute = parseMinute(minuteOpt.orElse("0"));

				return LocalDateTime.of(year, month, day, hour, minute);
			}
		}

		// if matcher did not match
		return null;
	}
	

	private static int parseYear(String yearString) {
		yearString = yearString.trim();
		
		int year;
		if (yearString.length() == 2) {
			year = 2000 + Integer.parseInt(yearString);
		}
		else {
			year = Integer.parseInt(yearString);
		}

		return year;
	}

	private static int parseMonth(String monthString) throws ParseException {
		monthString = monthString.trim();
		
		try {
			int month = Integer.parseInt(monthString);

			if (month < 1 || month > 12) {
				throw new ParseException("Month is not within valid bounds 1 - 12 inclusive", -1);
			}
			else {
				return month;
			}
		}
		catch (NumberFormatException e) {

			switch (monthString.toLowerCase()) {
			case "jan":
				return 1;
			case "feb":
				return 2;
			case "mar":
				return 3;
			case "apr":
				return 4;
			case "may":
				return 5;
			case "jun":
				return 6;
			case "jul":
				return 7;
			case "aug":
				return 8;
			case "sep":
				return 9;
			case "oct":
				return 10;
			case "nov":
				return 11;
			case "dec":
				return 12;
			default:
				throw new ParseException("Month is not an integer or one of the standard 3 letter abbreviations.", -1);
			}

		}
	}
	
	private static LocalDateTime parseDayWord(String dayString) throws ParseException {
		dayString = dayString.trim();
		
		LocalDateTime now = LocalDateTime.now();
		
		switch (dayString.toLowerCase()) {
		case "today":
			return now;
		case "tmr":
		case "tomorrow":
			return now.plusDays(1);
		case "next week":
			return now.plusDays(7);
		
		case "mon":
		case "monday":
			return now.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
		case "tue":
		case "tuesday":
			return now.with(TemporalAdjusters.next(DayOfWeek.TUESDAY));
		case "wed":
		case "wednesday":
			return now.with(TemporalAdjusters.next(DayOfWeek.WEDNESDAY));
		case "thu":
		case "thursday":
			return now.with(TemporalAdjusters.next(DayOfWeek.THURSDAY));
		case "fri":
		case "friday":
			return now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY));
		case "sat":
		case "saturday":
			return now.with(TemporalAdjusters.next(DayOfWeek.SATURDAY));
		case "sun":
		case "sunday":
			return now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
		default:
			throw new ParseException("Day is not today, tomorrow, next week or day of week.", -1);
		}
	}

	private static int parseDayNumber(String dayString) throws ParseException {
		dayString = dayString.trim();
		
		int day = Integer.parseInt(dayString);

		if (day < 1 || day > 31) {
			throw new ParseException("Day is not within valid bounds 1 - 31 inclusive", -1);
		}
		else {
			return day;
		}
	}

	private static int parseHour(String hour12, String meridiem) throws ParseException {
		hour12 = hour12.trim();
		meridiem = meridiem.trim();
		
		meridiem = meridiem.toLowerCase();
		int hour;
		
		if (meridiem.equals("am") && hour12.equals("12")) {
			hour = 0;
		}
		else if (meridiem.equals("pm") && !hour12.equals("12")) {
			hour = 12 + Integer.parseInt(hour12);
		}
		else {
			hour = Integer.parseInt(hour12);
		}

		if (hour > 23) {
			throw new ParseException("Hour is not within valid bounds 0 - 23 inclusive", -1);
		}
		else {
			return hour;
		}
	}

	private static int parseMinute(String minuteString) throws ParseException {
		minuteString = minuteString.trim();
		
		int minute = Integer.parseInt(minuteString);

		if (minute < 0 || minute > 60) {
			throw new ParseException("Minute is not within valid bounds 0 - 60 inclusive", -1);
		}
		else {
			return minute;
		}
	}
	
	public static void main(String[] args) {
		try {
			LocalDateTime date1 = DateParser.parse("12-12-12 05:00");
			System.out.println(date1.toString());
			LocalDateTime date2 = DateParser.parse("12-12-12 05:00");
			System.out.println(date2.toString());
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Model model;
	
	private static final Logger logger = LogsCenter.getLogger(Parser.class);
	
	private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private static final Prefix namePrefix = new Prefix("'");
	private static final Prefix startDateTimePrefix = new Prefix("from ");
	private static final Prefix endDateTimePrefix = new Prefix("to ");
	private static final Prefix dlEndDateTimePrefix = new Prefix("by ");
	private static final Prefix datePrefix = new Prefix("on ");
	private static final Prefix tagsPrefix = new Prefix("#");
	
	
	public Parser(Model model) {
		this.model = model;
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private String replaceAliases(String userInput) {
		List<Alias> aliasList = this.model.getAliasList();
		List<String> aliases = new ArrayList<>(); 
		List<String> originals = new ArrayList<>(); 
		
		for (Alias aliasObj : aliasList) {
			aliases.add(aliasObj.getAlias());
			originals.add(aliasObj.getOriginalPhrase());
		}
		
		for (int i=0; i<aliases.size(); i++) {
			String alias = aliases.get(i);
			System.out.println("alias: " + alias);
			// Does not replace arguments in find command or within quotes			
			if (userInput.contains(alias) && !userInput.matches(".*'.*(" + alias + ").*'.*") && !userInput.contains("find")) {
				System.out.println("match");
				userInput = userInput.replace(alias, originals.get(i));
			}
		}
		
		System.out.println("userInput: " + userInput);
		
		return userInput;
	}
	
	
	private Command prepareAdd(String arguments) {
		if (StringUtil.countOccurrences('\'', arguments) != 2) {
			// TODO better error msg?
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
		
		Pair<String, String> nameAndArgs = separateNameAndArgs(arguments);
		String taskName = nameAndArgs.getKey();
		String args = nameAndArgs.getValue();

		System.out.println("name: " + taskName);
		System.out.println("args: " + args);
		
		String argsLowerCase = args.toLowerCase();	
		
		if (argsLowerCase.contains(" on ")
				&& argsLowerCase.contains(" from ") 
				&& argsLowerCase.contains(" to ")) {
			logger.log(Level.FINEST, "Calling prepareAddEventSameDay");
			return prepareAddEventSameDay(taskName, "event", args);
		}
		else if (argsLowerCase.contains(" from ")
				&& argsLowerCase.contains(" to ")) {
			logger.log(Level.FINEST, "Calling prepareAddEventDifferentDays");
			return prepareAddEventDifferentDays(taskName, "event", args);
		}
		else if (argsLowerCase.contains(" by ")) {
			logger.log(Level.FINEST, "Calling prepareAddDeadline");
			return prepareAddDeadline(taskName, "deadline", args);
		}
		else if (args.matches("\\s*(#.+)*\\s*")) {
			logger.log(Level.FINEST, "Calling prepareAddSomeday");
			return prepareAddSomeday(taskName, "someday", args);
		}
		else {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
	}
	
	
	private Pair<String, String> separateNameAndArgs(String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix);
		argsTokenizer.tokenize(arguments);
		
		String preamble = argsTokenizer.getPreamble().orElse("");
		
		List<String> stringsAfterQuotes = argsTokenizer.getAllValues(namePrefix).get();
		String taskName = stringsAfterQuotes.get(0);
		String argsAfterName = stringsAfterQuotes.get(1);
		
		return new Pair<>(taskName, " " + preamble + " " + argsAfterName + " ");	
	}
	
	
	private Command prepareAddEventDifferentDays(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(startDateTimePrefix, endDateTimePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		String startDateTimeString = argsTokenizer.getValue(startDateTimePrefix).get();
		String endDateTimeString = argsTokenizer.getValue(endDateTimePrefix).get();
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));

		return getAddCommand(taskName, taskType, startDateTimeString, endDateTimeString, tagSet);
	}
	
	
	private Command prepareAddEventSameDay(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(startDateTimePrefix, endDateTimePrefix, datePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		String dateString = argsTokenizer.getValue(datePrefix).get();
		String startDateTimeString = argsTokenizer.getValue(startDateTimePrefix).get() + " " + dateString;
		String endDateTimeString = argsTokenizer.getValue(endDateTimePrefix).get() + " " + dateString;
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));

		return getAddCommand(taskName, taskType, startDateTimeString, endDateTimeString, tagSet);
	}

	
	private Command prepareAddDeadline(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(dlEndDateTimePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		String endDateTimeString = argsTokenizer.getValue(dlEndDateTimePrefix).get();
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));
		
		return getAddCommand(taskName, taskType, null, endDateTimeString, tagSet);
	}
	
	private Command prepareAddSomeday(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(dlEndDateTimePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));
		
		// TODO better approach than using nulls as flag values
		return getAddCommand(taskName, taskType, null, null, tagSet);
	}
	
	
	private Command getAddCommand(String taskName, String taskType, String startDateTimeString, String endDateTimeString, Set<String> tagSet) {
		Optional<LocalDateTime> startDateTimeOpt, endDateTimeOpt;

		try {
			if (startDateTimeString == null) {
				startDateTimeOpt = Optional.empty();
			}
			else {
				startDateTimeOpt = Optional.of(DateParser.parse(startDateTimeString));
			}
			
			if (endDateTimeString == null) {
				endDateTimeOpt = Optional.empty();
			}
			else {
				endDateTimeOpt = Optional.of(DateParser.parse(endDateTimeString));
			}
			
			return new AddCommand(taskName, taskType, startDateTimeOpt, endDateTimeOpt, tagSet);
		} catch (ParseException e) {
			return new IncorrectCommand(e.getMessage());
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
	}
	
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        if (args.equals("")) {
        	return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
    	
    	// keyphrases delimited by commas
        final String[] keyphrases = args.trim().split("\\s*,\\s*");
        final Set<String> keyphraseSet = new HashSet<>(Arrays.asList(keyphrases));
        
        System.out.println("keyphrase set: " + keyphraseSet.toString());
        
        return new FindCommand(keyphraseSet);
    }

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	// Only supports task type and status type options.
	private Command prepareList(String arguments) {
		if (arguments.equals("")) {
			return new ListCommand();
		}

		String[] args = arguments.split(" ");

		String taskType = null;
		String status = null;
		for (int i = 0; i < args.length; i++) {
			switch (args[i].trim()) {
			case "event":
			case "ev":
			case "deadline":
			case "dl":
			case "someday":
			case "sd":
				taskType = args[i];
				break;
			case "done":
			case "pending":
			case "overdue":
				status = args[i];
				break;
			default:
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
			}
		}

		return new ListCommand(taskType, status);
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Parses arguments in the context of the delete task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
	private Command prepareDelete(String arguments) {
		int[] indices;
		try {
			indices = parseIndices(arguments);
		} catch (IllegalArgumentException e) {
			return new IncorrectCommand(e.getMessage());
		}
		return new DeleteCommand(indices);
	}

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * @return an array of the specified indices in the {@code command} if
	 * positive unsigned integers are given. 
	 * @throws IllegalArgumentException otherwise
	 */
	private int[] parseIndices(String args) throws IllegalArgumentException {
		String[] indexStrings = args.split(" ");
		int[] indices = new int[indexStrings.length];

		for (int i = 0; i < indexStrings.length; i++) {
			String index = indexStrings[i].trim();
			
			if (!StringUtil.isUnsignedInteger(index)) {
				throw new IllegalArgumentException(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
			}
			else {
				indices[i] = Integer.parseInt(index);
			}
		}

		return indices;
	}
	
	private Set<String> toSet(Optional<List<String>> tagsOptional) {
        List<String> tags = tagsOptional.orElse(Collections.emptyList());
        return new HashSet<>(tags);
    }

	public static void main(String[] args) {
		Parser p = new Parser(new ModelManager());
//		p.parseCommand("add 'dd' by 5pm today");
		p.replaceAliases("find k");
	}
}
```
###### \java\seedu\address\model\Model.java
``` java
    /** Saves the state of the model in case the user wishes to undo an action. */
    void saveState();
    
    /** Removes the last state of the model. */
    void undoSaveState();
    
    /** Reverts back to previous task and tag list before the last command was executed. */
    void loadPreviousState();
    
    /** Redoes an action after an undo. */
    void loadNextState();
```
###### \java\seedu\address\model\Model.java
``` java
    /** Returns the internal list of aliases stored in the alias manager */
	List<Alias> getAliasList();
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    public void saveState() {
    	stateHistory.push(new TaskManager(taskManager));
    	// Allow redos only if the previous action is an undo
    	undoHistory.clear();
    }
    
    public void undoSaveState() {
    	stateHistory.pop();
    }
    
    public void loadPreviousState() throws EmptyStackException {
    	TaskManager oldTaskManager = stateHistory.pop();
    	
    	undoHistory.push(new TaskManager(taskManager));
    	
    	taskManager.setTasks(oldTaskManager.getFilteredTasks());
    	taskManager.setTags(oldTaskManager.getTagList());
    	
    	indicateTaskManagerChanged();
    }
    
    public void loadNextState() throws EmptyStackException {
    	TaskManager oldTaskManager = undoHistory.pop();

    	stateHistory.push(new TaskManager(taskManager));
    	
    	taskManager.setTasks(oldTaskManager.getFilteredTasks());
    	taskManager.setTags(oldTaskManager.getTagList());
    	
    	indicateTaskManagerChanged();
    }
    
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void checkForOverdueTasks() {
    	LocalDateTime now = LocalDateTime.now();
    	
    	for (Task task : taskManager.getUniqueTaskList().getInternalList()) {
    		
    		if (!task.getStatus().isDone() && task.getEndDate().orElse(LocalDateTime.MAX).isBefore(now)) {
    			System.out.println("now: " + now);
    			System.out.println("endDateee: " + task.getEndDate());
    			task.setStatus(new Status("overdue"));
    		} 
    		else if (task.getStatus().isOverdue() && task.getEndDate().orElse(LocalDateTime.MIN).isAfter(now)) {
    			task.setStatus(new Status("pending"));
    		}
    	}
    }

```
###### \java\seedu\address\model\task\Name.java
``` java
	@Override
	public int compareTo(Name other) {
		return this.value.compareTo(other.value);
	}

}
```
###### \java\seedu\address\model\task\Status.java
``` java
    // overdue < not done < done
	@Override
	public int compareTo(Status other) {
		if (this.equals(other)) {
			return 0;
		}
		else if (this.isOverdue() || other.isDone()) {
			return -1;
		}
		else {
			return 1;
		}
	}
}
```
###### \java\seedu\address\model\TaskManager.java
``` java
    private void sortTasks() {
    	Collections.sort(tasks.getInternalList());
    }
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
        
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
    		@Override
    		public void handle(KeyEvent event) {
    			if (event.getCode().equals(KeyCode.UP)) {
    				handleUpKey();
    			}
    			else if (event.getCode().equals(KeyCode.DOWN)) {
    				handleDownKey();
    			}
    		}
        });
    }
    
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * Show previous command string input in history entered commands
     */
    private void handleUpKey() {
    	String prevCommand = commandHistoryManager.getPreviousCommand();
    	commandTextField.setText(prevCommand);
    }
    
    /**
     * Show next command string input in history of entered commands
     */
    private void handleDownKey() {
    	String nextCommand = commandHistoryManager.getNextCommand();
    	commandTextField.setText(nextCommand);
    }

```
###### \java\seedu\address\ui\CommandHistoryManager.java
``` java
public class CommandHistoryManager {
	
	private static CommandHistoryManager instance;
	
	private Stack<String> previousCommands = new Stack<>();;
	private Stack<String> nextCommands = new Stack<>();;
	private String firstEnteredCommand = "";
	private boolean isFirstCommand = true;
	
	private CommandHistoryManager() {}
	
	public static CommandHistoryManager getInstance() {
		if (instance == null) {
            instance = new CommandHistoryManager();
        }
        return instance;
	}
	
	public void rememberCommand(String command) {
		if (isFirstCommand) {
			firstEnteredCommand = command;
			isFirstCommand = false;
		}
		
		previousCommands.push(command);
		nextCommands.clear();
	}
	
	public String getPreviousCommand() {		
		if (previousCommands.isEmpty()) {
			return firstEnteredCommand;
		}
		else {
			String cmd = previousCommands.pop();			
			nextCommands.push(cmd);
			return cmd;
		}
	}
	
	public String getNextCommand() {
		if (nextCommands.isEmpty()) {
			return "";
		}
		else {
			String cmd = nextCommands.pop();
			previousCommands.push(cmd);
			return cmd;
		}
	}
}
```
