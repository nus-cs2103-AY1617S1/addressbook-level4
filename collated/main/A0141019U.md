# A0141019U
###### \java\seedu\address\commons\util\StringUtil.java
``` java
    /**
     * Returns number of occurrences of the character in a string
     */
    public static int countOccurrences(char character, String string) {
    	int numOccurrences = 0;
    	char[] charArray = string.toCharArray();
    	
    	for (int i=0; i<charArray.length; i++) {
    		if (charArray[i] == character) {
    			numOccurrences += 1;
    		}
    	}
    	
    	return numOccurrences;
    }
    
    /**
	 * @param arguments
	 *            an input command string that may contain 0 or 2 single quotes
	 *            that surround a task name
	 * @return the name of the task enclosed by single quotes if it exists, an
	 *         empty string otherwise
	 */
	public static String getQuotedText(String s) {
		Prefix quotePrefix = new Prefix("'");
		
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(quotePrefix);
		argsTokenizer.tokenize(s);
		
		Optional<List<String>> maybeName = argsTokenizer.getAllValues(quotePrefix);
		
		if (maybeName.isPresent()) {
			return "'" + maybeName.get().get(0) + "'";
		}
		else {
			return "";
		}
	}

	
	/**
	 * @param arguments
	 *            an input command string that may contain 0 or 2 single quotes
	 *            that surround a task name
	 * @return the arguments before the quoted text concatenated with the
	 *         arguments after the quotes text
	 */
	public static String getNonQuotedText(String s) {
		Prefix quotePrefix = new Prefix("'");
		
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(quotePrefix);
		argsTokenizer.tokenize(s);
		
		String argsBeforeQuotes = argsTokenizer.getPreamble().orElse("");
		String argsAfterQuotes = argsTokenizer.getValue(quotePrefix).orElse("");
		
		return argsBeforeQuotes + " " + argsAfterQuotes;
	}
	
	
	public static String removeFirstAndLastChars(String s) {
		return s.substring(1, s.length()-1);
	}
}
```
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
    public AddCommand(String name, String taskType, Optional<LocalDateTime> startDate, Optional<LocalDateTime> endDate, Set<String> tags) 
    		throws IllegalValueException, IllegalArgumentException {
    	
    	final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
    	
    	this.toAdd = new Task(
        		new Name(name),
        		new TaskType(taskType),
        		new Status("pending"), 
        		startDate, 
        		endDate,
        		new UniqueTagList(tagSet)
         );
    }
    
    /**
     * Copy constructor.
     */
    public AddCommand(ReadOnlyTask source) {
        this.toAdd = new Task(source);
    }


    @Override
    public CommandResult execute() {
    	assert model != null;
        try {
        	EventsCenter.getInstance().post(new DisplayTaskListEvent(model.getFilteredTaskList()));
        	model.saveState();
            model.addTask(toAdd);
            raiseJumpToTaskEvent(toAdd);
            model.checkForOverdueTasks();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
        	// If adding was unsuccessful, then the state should not be saved - no change was made.
        	model.undoSaveState();
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }
    
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
public class RedoCommand extends Command {
	public static final String COMMAND_WORD = "redo";

	public static final String MESSAGE_REDO_SUCCESS = "Redid last undo successfully";
	public static final String MESSAGE_REDO_FAIL = "No actions to redo";

	public RedoCommand() {}

	@Override
	public CommandResult execute() {
		try {
			model.loadNextState();
			return new CommandResult(MESSAGE_REDO_SUCCESS);
		}
		catch (EmptyStackException e) {
			return new CommandResult(MESSAGE_REDO_FAIL);
		}
	}
}
```
###### \java\seedu\address\logic\commands\TabCommand.java
``` java
public class TabCommand extends Command {
	
	public static final String COMMAND_WORD = "tab";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows the tab on the right hand pane "
            + "corresponding to the time period input.\n"
            + "Parameters: (today | tomorrow | tmr | week | month | someday | sd)\n"
            + "Example: " + COMMAND_WORD + " tomorrow";
    
    public static final String MESSAGE_SUCCESS = "Switched to %1$s tab.";
    public static final String MESSAGE_FAIL = "Invalid tab name.";
    
    public static enum TabName {
    	TODAY, TOMORROW, WEEK, MONTH, SOMEDAY
    }
    
    TabName tabTo;
    public TabCommand(TabName tabTo) {
    	this.tabTo = tabTo;
    }

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new ViewTabRequestEvent(tabTo));
    	switch (tabTo) {
    	case TODAY:
    		return new CommandResult(String.format(MESSAGE_SUCCESS, tabTo.name().toLowerCase()));
    	case TOMORROW:
    		return new CommandResult(String.format(MESSAGE_SUCCESS, tabTo.name().toLowerCase()));
    	case WEEK:
    		return new CommandResult(String.format(MESSAGE_SUCCESS, tabTo.name().toLowerCase()));
    	case MONTH:
    		return new CommandResult(String.format(MESSAGE_SUCCESS, tabTo.name().toLowerCase()));
    	case SOMEDAY:
    		return new CommandResult(String.format(MESSAGE_SUCCESS, tabTo.name().toLowerCase()));
    	default:
    		return new CommandResult(MESSAGE_FAIL);
    	}
    }

}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {
	public static final String COMMAND_WORD = "undo";

	public static final String MESSAGE_UNDO_SUCCESS = "Undid last command successfully";
	public static final String MESSAGE_UNDO_FAIL = "No actions to undo";

	public UndoCommand() {}

	@Override
	public CommandResult execute() {
		model.checkForOverdueTasks();
		try {
			model.loadPreviousState();
			return new CommandResult(MESSAGE_UNDO_SUCCESS);
		}
		catch (EmptyStackException e) {
			return new CommandResult(MESSAGE_UNDO_FAIL);
		}
	}
}
```
###### \java\seedu\address\logic\parser\DateParser.java
``` java
public class DateParser {

	private static final Pattern[] STANDARD_DATE_FORMATS = new Pattern[] {
			Pattern.compile("(?<day>\\d{1,2})(-|/)(?<month>\\d{1,2})(-|/)(?<year>\\d{4})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MM-yyyy HH:mm am
			Pattern.compile("(?<year>\\d{4})(-|/)(?<month>\\d{1,2})(-|/)(?<day>\\d{1,2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // yyyy-MM-dd HH:mmpm
			Pattern.compile("(?<day>\\d{1,2})(-|/)(?<month>\\d{1,2})(-|/)(?<year>\\d{2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MM-yy HH:mm pm
			Pattern.compile("(?<day>\\d{1,2})(-|/)(?<month>[a-z]{3})(-|/)(?<year>\\d{4})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MMM-yyyy HH:mm am
			Pattern.compile("(?<day>\\d{1,2})(-|/)(?<month>[a-z]{3})(-|/)(?<year>\\d{2})\\s(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // dd-MMM-yy HH:mm am

			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})(-|/)(?<month>\\d{1,2})(-|/)(?<year>\\d{4})"), // HH:mm am dd-MM-yyyy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<year>\\d{4})(-|/)(?<month>\\d{1,2})(-|/)(?<day>\\d{1,2})"), // HH:mmpm yyyy-MM-dd 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})(-|/)(?<month>\\d{1,2})(-|/)(?<year>\\d{2})"), // HH:mm pm dd-MM-yy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})(-|/)(?<month>[a-z]{3})(-|/)(?<year>\\d{4})"), // HH:mm am dd-MMM-yyyy 
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s(?<day>\\d{1,2})(-|/)(?<month>[a-z]{3})(-|/)(?<year>\\d{2})") // HH:mm am dd-MMM-yy 
	};

	private static final Pattern[] NATURAL_LANGUAGE = new Pattern[] {
			Pattern.compile("(?<day>[a-zA-Z\\s]+)?\\s*(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?"), // tomorrow 2:30 pm
			Pattern.compile("(?<hour>\\d{1,2}):*(?<minute>\\d{2})?\\s*(?<meridiem>am|pm)?\\s*(?<day>[a-zA-Z\\s]+)?") // 2pm tomorrow
	};

	private static final Logger logger = LogsCenter.getLogger(DateParser.class);
	
	
	/**
	 * Parses a string into a LocalDateTime.
	 * 
	 * @return LocalDateTime if date format is valid.
	 * @throws ParseException if unable to parse.
	 */
	public static LocalDateTime parse(String dateString) throws ParseException {
		dateString = dateString.trim().toLowerCase();
		
		LocalDateTime dateTime = parseNaturalLanguage(dateString);
		if (dateTime == null) {
			dateTime = parseStandardFormat(dateString);
		}
		
		if (dateTime == null) {
			throw new ParseException("Failed to parse date and time.", -1);
		}
		else {
			logger.log(Level.INFO, "Date parser result: " + dateTime);
			return dateTime;
		}
	}
	
	/**
	 * Checks whether a given string contains a date, either in a standard
	 * format like `31-10-16` or in natural language like `today`.
	 * 
	 * @param dateString
	 *            a string that may contain a date.
	 * @return true if a date is present, false otherwise. If only a time is
	 *         given, false is returned.
	 */
	public static boolean containsDate(String dateString) {
		dateString = dateString.trim().toLowerCase();
		LocalDateTime dateTime;
		
		try {
			dateTime = parse(dateString);
		}
		catch (ParseException e) {
			return false;
		}
		
		return !isTodayInferred(dateString, dateTime);
	}

	/**
	 * Checks whether the date was inferred from an input string. This occurs
	 * when only the time is supplied and results in a date of today.
	 * 
	 * @param dateString
	 *            string that was parsed
	 * @param parsedDateTime
	 *            parsed date from dateString
	 * @return true if date was inferred, false if date was specified
	 */
	private static boolean isTodayInferred(String dateString, LocalDateTime parsedDateTime) {
		LocalDateTime nowWithHhmmReplaced = LocalDateTime.now()
				.withHour(parsedDateTime.getHour())
				.withMinute(parsedDateTime.getMinute())
				.truncatedTo(ChronoUnit.MINUTES);
		
		// If date parsed is today, and
		// string does not contain explicit identifiers for today 
		// ("today" or standard date format symbol "-"), date was inferred
		if (parsedDateTime.equals(nowWithHhmmReplaced)
				&& !(dateString.contains("today") || dateString.contains("-"))) {
			return true;
		} 
		else {
			return false;
		}
	}
	
	
	/**
	 * Attempts to parse a string using regex matching natural language words
	 * like `today` and `sunday`. Returns null if unable to parse.
	 * 
	 * @param dateString
	 *            a string containing a date.
	 * @return a LocalDateTime if string was parsed successfully, null
	 *         otherwise.
	 * @throws ParseException
	 */
	private static LocalDateTime parseNaturalLanguage(String dateString) throws ParseException {
		ArrayList<Matcher> matchers = new ArrayList<>();
		for (int i=0; i<NATURAL_LANGUAGE.length; i++) {
			matchers.add(NATURAL_LANGUAGE[i].matcher(dateString));
		}
		
		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				Optional<String> dayOpt = Optional.ofNullable(matcher.group("day"));
				System.out.println(dayOpt);
				String dayWord = dayOpt.orElse("today");
				LocalDateTime dayMonthYear = parseDayWord(dayWord);
				
				Optional<String> meridiemOpt = Optional.ofNullable(matcher.group("meridiem"));
				int hour = parseHour(matcher.group("hour"), meridiemOpt.orElse(""));
				
				Optional<String> minuteOpt = Optional.ofNullable(matcher.group("minute"));
				int minute = parseMinute(minuteOpt.orElse("0"));

				return LocalDateTime.of(dayMonthYear.getYear(), dayMonthYear.getMonth(), dayMonthYear.getDayOfMonth(), hour, minute);
			}
		}

		// if matcher did not match
		return null;
	}

	/**
	 * Attempts to parse a string using regex matching the standard date formats
	 * dd-mm-yy, dd-MMM-yy, yyyy-mm-dd, dd-mm-yyyy and dd-MMM-yyyy and time in
	 * the HH:mm, hh:mm am/pm format. The hyphens in the date may be replaced by
	 * forward slashes an the colon in the time format may be omitted. Returns
	 * null if unable to parse.
	 * 
	 * @param dateString
	 *            a string containing a date.
	 * @return a LocalDateTime
	 * @throws ParseException
	 */
	private static LocalDateTime parseStandardFormat(String dateString) throws ParseException {
		ArrayList<Matcher> matchers = new ArrayList<>();
		for (int i=0; i<STANDARD_DATE_FORMATS.length; i++) {
			matchers.add(STANDARD_DATE_FORMATS[i].matcher(dateString));
		}

		for (Matcher matcher : matchers) {
			if (matcher.matches()) {
				int year = parseYear(matcher.group("year"));
				int month = parseMonth(matcher.group("month"));
				int day = parseDayNumber(matcher.group("day"));
				
				Optional<String> meridiemOpt = Optional.ofNullable(matcher.group("meridiem"));
				int hour = parseHour(matcher.group("hour"), meridiemOpt.orElse(""));

				Optional<String> minuteOpt = Optional.ofNullable(matcher.group("minute"));
				int minute = parseMinute(minuteOpt.orElse("0"));
				
				try {
					return LocalDateTime.of(year, month, day, hour, minute);
				}
				catch (DateTimeException e) {
					throw new ParseException("Date '" + Integer.toString(day) + "' is invalid for month entered.", -1);
				}
			}
		}

		// if matcher did not match
		return null;
	}
	

	private static int parseYear(String yearString) {
		yearString = yearString.trim();
		
		int year;
		if (yearString.length() == 2) {
			year = 2000 + Integer.parseInt(yearString);
		}
		else {
			year = Integer.parseInt(yearString);
		}

		return year;
	}

	private static int parseMonth(String monthString) throws ParseException {
		monthString = monthString.trim();
		
		try {
			int month = Integer.parseInt(monthString);

			if (month < 1 || month > 12) {
				throw new ParseException("Month is not within valid bounds 1 - 12 inclusive", -1);
			}
			else {
				return month;
			}
		}
		// if monthString is not a number
		catch (NumberFormatException e) {

			switch (monthString.toLowerCase()) {
			case "jan":
				return 1;
			case "feb":
				return 2;
			case "mar":
				return 3;
			case "apr":
				return 4;
			case "may":
				return 5;
			case "jun":
				return 6;
			case "jul":
				return 7;
			case "aug":
				return 8;
			case "sep":
				return 9;
			case "oct":
				return 10;
			case "nov":
				return 11;
			case "dec":
				return 12;
			default:
				throw new ParseException("Month is not an integer or one of the standard 3 letter abbreviations.", -1);
			}

		}
	}
	
	private static LocalDateTime parseDayWord(String dayString) throws ParseException {
		dayString = dayString.trim();
		
		LocalDateTime now = LocalDateTime.now();
		
		switch (dayString.toLowerCase()) {
		case "today":
			return now;
		case "tmr":
		case "tomorrow":
			return now.plusDays(1);
		case "next week":
			return now.plusDays(7);
		
		case "mon":
		case "monday":
			return now.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
		case "tue":
		case "tuesday":
			return now.with(TemporalAdjusters.next(DayOfWeek.TUESDAY));
		case "wed":
		case "wednesday":
			return now.with(TemporalAdjusters.next(DayOfWeek.WEDNESDAY));
		case "thu":
		case "thursday":
			return now.with(TemporalAdjusters.next(DayOfWeek.THURSDAY));
		case "fri":
		case "friday":
			return now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY));
		case "sat":
		case "saturday":
			return now.with(TemporalAdjusters.next(DayOfWeek.SATURDAY));
		case "sun":
		case "sunday":
			return now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
		default:
			throw new ParseException("Day is not today, tomorrow, next week or day of week.", -1);
		}
	}

	private static int parseDayNumber(String dayString) throws ParseException {
		dayString = dayString.trim();
		
		int day = Integer.parseInt(dayString);

		if (day < 1 || day > 31) {
			throw new ParseException("Day is not within valid bounds 1 - 31 inclusive", -1);
		}
		else {
			return day;
		}
	}

	private static int parseHour(String hour12, String meridiem) throws ParseException {
		hour12 = hour12.trim();
		meridiem = meridiem.trim();
		
		meridiem = meridiem.toLowerCase();
		int hour;
		
		if (meridiem.equals("am") && hour12.equals("12")) {
			hour = 0;
		}
		else if (meridiem.equals("pm") && !hour12.equals("12")) {
			hour = 12 + Integer.parseInt(hour12);
		}
		else {
			hour = Integer.parseInt(hour12);
		}

		if (hour > 23) {
			throw new ParseException("Hour is not within valid bounds 0 - 23 inclusive", -1);
		}
		else {
			return hour;
		}
	}

	private static int parseMinute(String minuteString) throws ParseException {
		minuteString = minuteString.trim();
		
		int minute = Integer.parseInt(minuteString);

		if (minute < 0 || minute > 60) {
			throw new ParseException("Minute is not within valid bounds 0 - 60 inclusive", -1);
		}
		else {
			return minute;
		}
	}
	
}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Model model;
	
	private static final Logger logger = LogsCenter.getLogger(Parser.class);
	
	private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");
	private static final Pattern ADD_ALIAS_COMMAND_FORMAT = Pattern
			.compile("\\s*(?<alias>(\\s*\\S+)+)\\s*=\\s*(?<originalPhrase>(\\s*\\S+)+)\\s*");
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private static final Prefix startDateTimePrefix = new Prefix("from ");
	private static final Prefix endDateTimePrefix = new Prefix("to ");
	private static final Prefix dlEndDateTimePrefix = new Prefix("by ");
	private static final Prefix datePrefix = new Prefix("on ");
	private static final Prefix tagsPrefix = new Prefix("#");
	
	public Parser(Model model) {
		this.model = model;
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private String replaceAliases(String userInput) throws IllegalArgumentException {	
		if (StringUtil.countOccurrences('\'', userInput) != 2 && StringUtil.countOccurrences('\'', userInput) != 0) {
			throw new IllegalArgumentException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
		
		String quotedText = StringUtil.getQuotedText(userInput);
		String inputWithNameRemoved = StringUtil.getNonQuotedText(userInput);
		
		Map<String, String> aliasMap = getAliasMap();
		
		for (String alias : aliasMap.keySet()) {			
			// Does not replace arguments in find command, any alias commands or within quotes			
			if (inputWithNameRemoved.contains(alias) 
					&& !(inputWithNameRemoved.contains("find") || inputWithNameRemoved.contains("-alias"))) {
				
				String original = aliasMap.get(alias);
				inputWithNameRemoved = inputWithNameRemoved.replace(alias, original);
			}
		}		
		
		return inputWithNameRemoved + " " + quotedText;
	}
		
	private Map<String, String> getAliasMap() {
		List<ReadOnlyAlias> aliasList = this.model.getFilteredAliasList();
		Map<String, String> aliases = new HashMap<>();

		for (ReadOnlyAlias aliasObj : aliasList) {
			aliases.put(aliasObj.getAlias(), aliasObj.getOriginalPhrase());
		}

		return aliases;
	}
	
	
	private Command prepareAdd(String arguments) {
		if (StringUtil.countOccurrences('\'', arguments) != 2) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
		
		String taskNameWithoutQuotes = getTaskName(arguments);
		String args = StringUtil.getNonQuotedText(arguments);

		System.out.println("name: " + taskNameWithoutQuotes);
		System.out.println("args: " + args);
		
		String argsLowerCase = args.toLowerCase();	
		
		if (argsLowerCase.contains("on")
				&& argsLowerCase.contains("from") 
				&& argsLowerCase.contains("to")) {
			logger.finest("Calling prepareAddEventSameDay");
			return prepareAddEventSameDay(taskNameWithoutQuotes, "event", args);
		}
		else if (argsLowerCase.contains("from")
				&& argsLowerCase.contains("to")) {
			logger.finest("Calling prepareAddEventDifferentDays");
			return prepareAddEventDifferentDays(taskNameWithoutQuotes, "event", args);
		}
		else if (argsLowerCase.contains("by")) {
			logger.finest("Calling prepareAddDeadline");
			return prepareAddDeadline(taskNameWithoutQuotes, "deadline", args);
		}
		// if args is either empty or contains only #tags
		else if (args.matches("\\s*(#.+)*\\s*")) {
			logger.finest("Calling prepareAddSomeday");
			return prepareAddSomeday(taskNameWithoutQuotes, "someday", args);
		}
		else {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
	}
	

	/**
	 * Return an AddCommand for an event task with start and end times on
	 * different days. The parameters for the AddCommand are taken from the
	 * arguments supplied to this method.
	 * 
	 * @param taskName
	 *            name of the task to be added.
	 * @param taskType
	 *            type of the task to be added.
	 * @param arguments
	 *            the user input string corresponding to adding an event, after
	 *            the command word 'add' and the task name have been removed.
	 *            'on' cannot be a part of the command string. Both times
	 *            supplied must contain the date as well. eg. `from 9:00am today
	 *            to 10pm tomorrow #happy` is valid but `from 9:00am today to
	 *            10pm #happy is not.
	 * @return an AddCommand for an event task
	 */
	private Command prepareAddEventDifferentDays(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(startDateTimePrefix, endDateTimePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		String startDateTimeString = argsTokenizer.getValue(startDateTimePrefix).get();
		String endDateTimeString = argsTokenizer.getValue(endDateTimePrefix).get();
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));

		return getAddCommand(taskName, taskType, startDateTimeString, endDateTimeString, tagSet);
	}
	
	/**
	 * Return an AddCommand for an event task with start and end times on
	 * the same day. The parameters for the AddCommand are taken from the
	 * arguments supplied to this method.
	 * 
	 * @param taskName
	 *            name of the task to be added.
	 * @param taskType
	 *            type of the task to be added.
	 * @param arguments
	 *            the user input string corresponding to adding an event, after
	 *            the command word 'add' and the task name have been removed.
	 *            'on' should be a part of the command string to signify both
	 *            times are on the same date. 
	 *            eg. `from 9:00am to 10pm on 30-10-16 #happy` is valid.
	 * @return an AddCommand for an event task
	 */
	private Command prepareAddEventSameDay(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(startDateTimePrefix, endDateTimePrefix, datePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		String dateString = argsTokenizer.getValue(datePrefix).get();
		String startDateTimeString = argsTokenizer.getValue(startDateTimePrefix).get() + " " + dateString;
		String endDateTimeString = argsTokenizer.getValue(endDateTimePrefix).get() + " " + dateString;
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));

		return getAddCommand(taskName, taskType, startDateTimeString, endDateTimeString, tagSet);
	}

	/**
	 * Return an AddCommand for a deadline task with parameters taken from the
	 * arguments supplied to the method.
	 * 
	 * @param taskName
	 *            name of the task to be added.
	 * @param taskType
	 *            type of the task to be added.
	 * @param arguments
	 *            the user input string corresponding to adding a deadline,
	 *            after the command word 'add' and the task name have been
	 *            removed. The string must contain 'by' for the tokeniser to
	 *            find the due by date. eg. `by 600`
	 * @return an AddCommand
	 */
	private Command prepareAddDeadline(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(dlEndDateTimePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		String endDateTimeString = argsTokenizer.getValue(dlEndDateTimePrefix).get();
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));
		
		return getAddCommand(taskName, taskType, null, endDateTimeString, tagSet);
	}
	
	/**
	 * Return an AddCommand for a someday task with parameters taken from the
	 * arguments supplied to the method.
	 * 
	 * @param taskName
	 *            name of the task to be added.
	 * @param taskType
	 *            type of the task to be added.
	 * @param arguments
	 *            the user input string corresponding to adding a someday,
	 *            after the command word 'add' and the task name have been
	 *            removed. It can either be empty or contain one or more tags.
	 *            eg. `#bob #gg` and `` are valid inputs.
	 * @return
	 */
	private Command prepareAddSomeday(String taskName, String taskType, String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(dlEndDateTimePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		
		Set<String> tagSet = toSet(argsTokenizer.getAllValues(tagsPrefix));

		return getAddCommand(taskName, taskType, null, null, tagSet);
	}
	
	/**
	 * Return an AddCommand from the arguments supplied.
	 * 
	 * @param taskName
	 *            name of the task to be added.
	 * @param taskType
	 *            type of the task to be added.
	 * @param startDateTimeString
	 *            start date of the task to be added. If null, start date parsed
	 *            is Optional.empty()
	 * @param endDateTimeString
	 *            end date of the task to be added. If null, end date parsed is
	 *            Optional.empty()
	 * @param tagSet
	 *            tags of the task to be added.
	 * @return an AddCommand if all inputs are valid, IncorrectCommand
	 *         otherwise.
	 */
	private Command getAddCommand(String taskName, String taskType, String startDateTimeString, String endDateTimeString, Set<String> tagSet) {
		Optional<LocalDateTime> startDateTimeOpt, endDateTimeOpt;

		try {
			if (startDateTimeString == null) {
				startDateTimeOpt = Optional.empty();
			}
			else {
				startDateTimeOpt = Optional.of(DateParser.parse(startDateTimeString));
			}
			
			if (endDateTimeString == null) {
				endDateTimeOpt = Optional.empty();
			}
			else {
				endDateTimeOpt = Optional.of(DateParser.parse(endDateTimeString));
			}
			
			return new AddCommand(taskName, taskType, startDateTimeOpt, endDateTimeOpt, tagSet);
		} catch (ParseException e) {
			return new IncorrectCommand(e.getMessage());
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		} catch (IllegalArgumentException e) {
			return new IncorrectCommand(String.format(e.getMessage()));
		}
	}
	
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Returns a FindCommand that finds all tasks with keyphrases supplied to
	 * the method.
	 *
	 * @param args
	 *            keyphrases separated by commmas
	 * @return a FindCommand
	 */
    private Command prepareFind(String args) {
        if (args.equals("")) {
        	return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
    	
    	// Keyphrases delimited by commas
        final String[] keyphrases = args.trim().split("\\s*,\\s*");
        final Set<String> keyphraseSet = new HashSet<>(Arrays.asList(keyphrases));
        
        logger.finest("Keyphrases for find command: " + keyphraseSet.toString());
        
        return new FindCommand(keyphraseSet);
    }

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Returns a DeleteCommand that deletes all tasks with indices supplied to
	 * the method.
	 * 
	 * @param a valid argument is one or more integers separated by spaces, corresponding to tasks
	 * displayed on the screen.
	 * @return a DeleteCommand if the argument string is valid, IncorrectCommand otherwise.
	 */
	private Command prepareDelete(String arguments) {
		int[] indices;
		try {
			indices = parseIndices(arguments);
		} catch (IllegalArgumentException e) {
			return new IncorrectCommand(e.getMessage());
		}
		return new DeleteCommand(indices);
	}

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * @return a TabCommand with argument corresponding to the name 
     * of the tab to switch to.
     * An IncorrectCommand is returned for inputs other than
     * today, tomorrow, week, month, someday (case-insensitive)
     */
    private Command prepareTabCommand(String arguments) {
    	switch (arguments.trim().toLowerCase()) {
    	case "today":
    		return new TabCommand(TabCommand.TabName.TODAY);
    	case "tmr":
    	case "tomorrow":
    		return new TabCommand(TabCommand.TabName.TOMORROW);
    	case "week":
    		return new TabCommand(TabCommand.TabName.WEEK);
    	case "month":
    		return new TabCommand(TabCommand.TabName.MONTH);
    	case "sd":
    	case "someday":
    		return new TabCommand(TabCommand.TabName.SOMEDAY);
    	default: 
    		return new IncorrectCommand("Invalid tab name input.");
    	}
    }
    
    
	/**
	 * @return an array of the specified indices in the {@code command} if
	 * positive unsigned integers are given. 
	 * @throws IllegalArgumentException otherwise
	 */
	private int[] parseIndices(String args) throws IllegalArgumentException {
		String[] indexStrings = args.split(" ");
		int[] indices = new int[indexStrings.length];

		for (int i = 0; i < indexStrings.length; i++) {
			String index = indexStrings[i].trim();
			
			if (!StringUtil.isUnsignedInteger(index)) {
				throw new IllegalArgumentException(MESSAGE_INVALID_DISPLAYED_INDEX);
			}
			else {
				indices[i] = Integer.parseInt(index);
			}
		}

		return indices;
	}
	
	private Set<String> toSet(Optional<List<String>> tagsOptional) {
		List<String> tags = tagsOptional.orElse(Collections.emptyList());
        return new HashSet<>(tags);
    }

	public static void main(String[] args) {
		Parser p = new Parser(new ModelManager());
//		p.parseCommand("add 'dd' by 5pm today");
//		System.out.println(p.getQuotedText("ad 'a' ddk d"));
	}
}
```
###### \java\seedu\address\model\Model.java
``` java
    /** Saves the state of the model in case the user wishes to undo an action. */
    void saveState();
    
    /** Removes the last state of the model. */
    void undoSaveState();
    
    /** Reverts back to previous task and tag list before the last command was executed. */
    void loadPreviousState();
    
    /** Redoes an action after an undo. */
    void loadNextState();
    
    /** Returns the state history of the task manager. Use for testing only. */
    public Stack<TaskManager> getStateHistoryStack();
    
    /** Returns the undo history of the task manager. Use for testing only. */
    public Stack<TaskManager> getUndoHistoryStack();
```
###### \java\seedu\address\model\Model.java
``` java
    /** Returns the internal list of tasks stored in the task manager*/
	List<ReadOnlyTask> getInternalTaskList();
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    public void saveState() {
    	stateHistory.push(new TaskManager(taskManager));
    	// Allow redos only if the previous action is an undo
    	undoHistory.clear();
    }
    
    public void undoSaveState() {
    	stateHistory.pop();
    }
    
    public void loadPreviousState() throws EmptyStackException {
    	TaskManager oldTaskManager = stateHistory.pop();
    	
    	undoHistory.push(new TaskManager(taskManager));
    	
    	taskManager.setTasks(oldTaskManager.getFilteredTasks());
    	taskManager.setTags(oldTaskManager.getTagList());
    	
    	indicateTaskManagerChanged();
    }
    
    public void loadNextState() throws EmptyStackException {
    	TaskManager oldTaskManager = undoHistory.pop();

    	stateHistory.push(new TaskManager(taskManager));
    	
    	taskManager.setTasks(oldTaskManager.getFilteredTasks());
    	taskManager.setTags(oldTaskManager.getTagList());
    	
    	indicateTaskManagerChanged();
    }
    
    @Override
    public Stack<TaskManager> getStateHistoryStack() {
    	return this.stateHistory;
    }
    
    @Override
    public Stack<TaskManager> getUndoHistoryStack() {
    	return this.undoHistory;
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public synchronized void checkForOverdueTasks() {
    	LocalDateTime now = LocalDateTime.now();
    	
    	for (Task task : taskManager.getUniqueTaskList().getInternalList()) {
    		
    		if (!task.getStatus().isDone() && task.getEndDate().orElse(LocalDateTime.MAX).isBefore(now)) {
    			task.setStatus(new Status("overdue"));
    		} 
    		else if (task.getStatus().isOverdue() && task.getEndDate().orElse(LocalDateTime.MIN).isAfter(now)) {
    			task.setStatus(new Status("pending"));
    		}
    	}
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public List<ReadOnlyTask> getInternalTaskList() {
    	return taskManager.getTaskList();
    }    
```
###### \java\seedu\address\model\task\Name.java
``` java
	@Override
	public int compareTo(Name other) {
		return this.value.compareTo(other.value);
	}

}
```
###### \java\seedu\address\model\task\Status.java
``` java
    // overdue < not done < done
	@Override
	public int compareTo(Status other) {
		if (this.equals(other)) {
			return 0;
		}
		else if (this.isOverdue() || other.isDone()) {
			return -1;
		}
		else {
			return 1;
		}
	}
}
```
###### \java\seedu\address\model\TaskManager.java
``` java
    private void sortTasks() {
    	Collections.sort(tasks.getInternalList());
    }
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    private void setKeyPressHandler() {
    	commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
    		@Override
    		public void handle(KeyEvent event) {
    			if (event.getCode().equals(KeyCode.UP)) {
    				handleUpKey();
    			}
    			else if (event.getCode().equals(KeyCode.DOWN)) {
    				handleDownKey();
    			}
    		}
        });
    }
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * Show previous command string input in history entered commands
     */
    private void handleUpKey() {
    	String prevCommand = commandHistoryManager.getPreviousCommand();
    	commandTextField.setText(prevCommand);
    }
    
    /**
     * Show next command string input in history of entered commands
     */
    private void handleDownKey() {
    	String nextCommand = commandHistoryManager.getNextCommand();
    	commandTextField.setText(nextCommand);
    }

```
###### \java\seedu\address\ui\CommandHistoryManager.java
``` java
public class CommandHistoryManager {
	
	private static CommandHistoryManager instance;
	
	private Stack<String> previousCommands = new Stack<>();;
	private Stack<String> nextCommands = new Stack<>();;
	private String firstEnteredCommand = "";
	private boolean isFirstCommand = true;
	
	private CommandHistoryManager() {}
	
	public static CommandHistoryManager getInstance() {
		if (instance == null) {
            instance = new CommandHistoryManager();
        }
        return instance;
	}
	
	public void rememberCommand(String command) {
		if (isFirstCommand) {
			firstEnteredCommand = command;
			isFirstCommand = false;
		}
		
		previousCommands.push(command);
		nextCommands.clear();
	}
	
	public String getPreviousCommand() {		
		if (previousCommands.isEmpty()) {
			return firstEnteredCommand;
		}
		else {
			String cmd = previousCommands.pop();			
			nextCommands.push(cmd);
			return cmd;
		}
	}
	
	public String getNextCommand() {
		if (nextCommands.isEmpty()) {
			return "";
		}
		else {
			String cmd = nextCommands.pop();
			previousCommands.push(cmd);
			return cmd;
		}
	}
}
```
