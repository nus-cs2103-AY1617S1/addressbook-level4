# A0139817U
###### /java/w15c2/tusk/commons/util/DateUtil.java
``` java
public class DateUtil {
	// Format for displaying dates
	public static final SimpleDateFormat dateFormat = new SimpleDateFormat("dd.MM.yyyy");
	public static final SimpleDateFormat dateFormatWithTime = new SimpleDateFormat("dd.MM.yyyy hh:mma");
	
	// Valid words that can be used to describe dates. Unsigned integers are valid as well.
	// Used to check if the user date inputs are valid.
	public static final HashSet<String> validWords;
	
	// Words used to describe a date relative to the current date.
	// Used to check if the user date inputs are relative.
	public static final HashSet<String> relativeWords;
	
	// Putting the list of valid and relative words into hashsets for faster access
	static { 
		validWords = new HashSet<String>();
		String[] validWordsArray = {
			"today", "tomorrow", "tmr", "next", "this", "following", "the", "day", "before", "after", "from",  			// Descriptors
			"jan", "january", "feb", "february", "mar", "march", "apr", "april", "may", "jun", "june", 					// Months
			"jul", "july", "aug", "august", "sep", "september", "oct", "october", "nov", "november", "dec", "december",
			"mon", "monday", "tue", "tues", "tuesday", "wed", "wednesday", "thu", "thurs", "thursday", "fri", "friday", // Days of the week 
			"sat", "saturday", "sun", "sunday", 										
			"1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th", 										// Days of the month
			"11th", "12th", "13th", "14th", "15th", "16th", "17th", "18th", "19th", "20th",
			"21st", "22nd", "23rd", "24th", "25th", "26th", "27th", "28th", "29th", "30th", "31st",
			"pm", "am"  // Time
		};
		for (int i = 0; i < validWordsArray.length; i++) {
			validWords.add(validWordsArray[i]);
		}
		
		relativeWords = new HashSet<String>();
		String[] relativeWordsArray = { 
    			"today", "tdy", "tomorrow", "tmr", "mon", "monday", "tue", "tues", "tuesday", "wed", "wednesday", 
    			"thu", "thurs", "thursday", "fri", "friday", "sat", "saturday", "sun", "sunday"	
    	};
		for (int i = 0; i < relativeWordsArray.length; i++) {
			relativeWords.add(relativeWordsArray[i]);
		}
	}
	
	/**
	 * Creates a Date object that is "daysAfterToday" days from today's date for testing relative dates.
	 * Hours and minutes of the Date object can also be specified.
	 */
	public static Date createDateAfterToday(int daysAfterToday, int hours, int minutes) {
		Calendar newDate = Calendar.getInstance();
		newDate.add(Calendar.DATE, daysAfterToday);
		newDate.set(Calendar.AM_PM, Calendar.AM);
		newDate.set(Calendar.HOUR, hours);
		newDate.set(Calendar.MINUTE, minutes);
		return newDate.getTime();
	}
	
	/**
     * Given a dateString, will return whether the words in the string are all valid words
     */
    public static boolean areValidWords(String dateString) {
    	// Add spaces between numbers and words before processing
    	dateString = StringUtil.addSpacesBetweenNumbersAndWords(dateString).trim().toLowerCase();
    	
    	String[] tokens = dateString.split(" ");
    	for (String token : tokens) {
    		// For it to be valid, token string must either be found in the validWords set 
    		// or it must be an unsigned integer
    		// or it must be a valid time format
    		if (!validWords.contains(token) && !StringUtil.isUnsignedInteger(token) && !isValidTimeFormat(token)) {
    			return false;
    		}
    	}
    	return true;
    }
    
    /**
     * Checks if a string follows a valid time format.
     * A valid time format is 
     * 
     * The follow examples are all valid time formats:
     * 1) Colon or full stop separating hours (0 <= hours < 24) and minutes (0 <= mins < 60). 
     * ("00:00" or "00.00". "23:59" or "23.59").
     * 2) Hours and minutes followed by morning or night descriptor.
     * ("12 am", "12:30am", "1.35 pm", "23.59pm")
     */
    public static boolean isValidTimeFormat(String timeString) {
    	// Time should not have more than 2 tokens
    	if (timeString.split(" ").length > 2) {
    		return false;
    	}
    	
    	// Remove all am and pm decorators
    	timeString = timeString.replaceAll("[a|p][m]", "").trim();
    	
    	String[] splitByColon = timeString.split(":");
    	String[] splitByDot = timeString.split("\\.");
    	
    	// After splitting by ":" or ".", the String array will be of length 2 if it is of format "HH:MM" or "HH.MM"
    	if (splitByColon.length == 2) {
    		// Check that HH and MM are within appropriate range
    		return isWithinHoursRange(splitByColon[0]) && isWithinMinutesRange(splitByColon[1]);
    		
    	} else if (splitByDot.length == 2) {
    		// Check that HH and MM are within appropriate range
    		return isWithinHoursRange(splitByDot[0]) && isWithinMinutesRange(splitByDot[1]);
    		
    	} else if (StringUtil.isUnsignedInteger(timeString)) {
    		// Time is of format "1am", "2pm", "11pm".
    		// Check that it lies between 1 (inclusive) and 12 (inclusive)
    		int val = Integer.parseInt(timeString);
    		return (val >= 1) && (val <= 12);
    		
    	} else {
    		return false;
    	}
    }
    
    /**
     * Checks if a String lies between 0 (inclusive) and 59 (inclusive)
     */
    public static boolean isWithinMinutesRange(String timeString) {
    	try {
    		int val = Integer.parseInt(timeString);
    		return (val >= 0) && (val <= 59);
    	} catch (NumberFormatException nfe) {
    		return false;
    	}
    }
    
    /**
     * Checks if a String lies between 0 (inclusive) and 23 (inclusive)
     */
    public static boolean isWithinHoursRange(String timeString) {
    	try {
    		int val = Integer.parseInt(timeString);
    		return (val >= 0) && (val <= 23);
    	} catch (NumberFormatException nfe) {
    		return false;
    	}
    }
    
    /**
     * Given 2 dates, retrieve the date from the first date and the time from the second date to
     * form a new date
     */
    public static Date retrieveDateTime(Date first, Date second) {
    	Calendar start = Calendar.getInstance();
		start.setTime(first);
		
		Calendar end = Calendar.getInstance();
		end.setTime(second);
		end.set(start.get(Calendar.YEAR), start.get(Calendar.MONTH), start.get(Calendar.DAY_OF_MONTH));
		
		return end.getTime();
    }
	
	/**
     * Checks if a string follows a valid date format.
     * 
     * The following examples are all valid and similar dates: 
     * "Oct 31". "31 Oct".
     * "31 Oct 2016". "Oct 31 2016".
     */
    public static boolean isValidDateFormat(String dateString) {
    	Date date = getDate(dateString);
    	// date has a value (not null) if dateString is a valid format
    	return (date != null);
    }
    
    /**
     * Checks if a string follows a valid format (using "to" or "-") to show start date and end date.
     * 
     * The following examples are all valid and similar illustrations: 
     * "Sep 31 - Oct 31". "31 Sep 2016 - 31 Oct 2016". 
     * "Sep 31 to Oct 31". "31 Sep 2016 to 31 Oct 2016".
     */
    public static boolean isValidStartDateToEndDateFormat(String dateString) {
    	Date[] dates = getStartAndEndDates(dateString);
    	// dates is null if dateString is not a valid format
    	if (dates == null) {
    		return false;
    	}
    	Date startDate = dates[0];
    	Date endDate = dates[1];
    	
    	// Format is valid only if end date is after the start date
    	return endDate.after(startDate);
    }
    
    /**
     * After receiving a Date from Natty, do a sanity check to ensure that the Date given by Natty is sensible
     * and not overly flexible by taking the <day> value of the Date and making sure that it exists within the
     * tokens of a date string.
     * 
     * However, if the dateString given to Natty contains relative dates (E.g. "next monday", "tomorrow", "the
     * day after tomorrow") instead of absolute dates (E.g. "31 Oct", "1 August 2017"), we will not need to 
     * perform such checks. 
     * 
     * Caution: This is just a heuristic to check if Natty processed properly
     */
    public static boolean isDateSensible(Date date, String dateString) {
    	// If it is a valid time format, the date will be sensible
    	if (isValidTimeFormat(dateString)) {
    		return true;
    	}
    	
    	String[] tokens = dateString.split(" ");
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		String day = Integer.toString(cal.get(Calendar.DAY_OF_MONTH));
		
    	for (String token : tokens) {
    		// Check if any token is a relative date word
    		if (relativeWords.contains(token)) {
    			return true;
    		}
    		
    		// Removes any 1st/2nd/3rd etc from the date input
    		if (token.replaceAll("st|nd|rd|th", "").equals(day)) {
    			return true;
    		}
    	}
    	return false;
    }

    /**
     * Retrieve the date from a string that represents some date using Natty library.
     */
    public static Date getDate(String dateString) {
    	// Add spaces between numbers and words in order for Natty to process it correctly
    	dateString = StringUtil.addSpacesBetweenNumbersAndWords(dateString).trim().toLowerCase();
    	
    	// Reject if there are any invalid words
    	if (!areValidWords(dateString)) {
    		return null;
    	}
    	
    	// Using the Natty library to parse the dateString
    	Parser parser = new Parser();
    	List<DateGroup> groups = parser.parse(dateString);

    	// String is valid date format only if there is only 1 DateGroup within
    	if (groups.size() != 1) {
    		return null;
    	}
    	
    	DateGroup firstDateGroup = groups.get(0);
    	List<Date> dates = firstDateGroup.getDates();

    	// String is valid date format only if there is only 1 date value within
    	if (dates.size() != 1) {
    		return null;
    	}
    	
    	// Set default time to be 12am if no time is given by user
    	if (firstDateGroup.isTimeInferred()) {
    		Date toRetrieveTime = createDateAfterToday(0, 0, 0);		   // Today 12am
    		Date newDate = retrieveDateTime(dates.get(0), toRetrieveTime); // Retrieve the date portion
    		dates.set(0, newDate);
    	}
    	
    	// Validate that date is sensible before returning
    	if (isDateSensible(dates.get(0), dateString)) {
    		return dates.get(0);
    	} else {
    		return null;
    	}
	}
    
    /**
     * Retrieve the start date and end date from a string that says "from (start date) to/- (end date)".
     * Stores the dates in a Date[] with start date as the 1st value and end date as the 2nd value.
     */
	public static Date[] getStartAndEndDates(String dateString) {
		Date[] dates = new Date[2];
    	String[] splitByTo = dateString.split("(?![cC])to(?!([bB]|(day )))"); // Make sure "to" is not part of "ocTOber" or "TOday"
    	String[] splitByDash = dateString.split("-");
    	
    	// After splitting by "to" or "-", the String array must be of length 2 (hold start date and end date)
    	if (splitByTo.length == 2) {
    		dates[0] = getDate(splitByTo[0]);
    		dates[1] = getDate(splitByTo[1]);
    	} else if (splitByDash.length == 2) {
    		dates[0] = getDate(splitByDash[0]);
    		dates[1] = getDate(splitByDash[1]);
    	} else {
    		return null;
    	}
    	
    	// If either dates are null, it means that dateString is not a valid format, return null
		if (dates[0] == null || dates[1] == null) {
			return null;
		}
		
		/* User may not provide the date for the end date (E.g. "from 1 Nov 5pm - 6pm" instead of "from 1 Nov 5pm - 1 Nov 6pm") 
		 * and this will cause an error because the date is taken as the current date (since "6pm" is the input)
    	 * 
    	 * Manually set the date of the end date to that of the start date
    	 */
    	if (splitByTo.length == 2 && isValidTimeFormat(splitByTo[1])) {
    		dates[1] = retrieveDateTime(dates[0], dates[1]);
    	} else if (splitByDash.length == 2 && isValidTimeFormat(splitByDash[1])) {
    		dates[1] = retrieveDateTime(dates[0], dates[1]);
    	}
		
    	return dates;
	}
}
```
###### /java/w15c2/tusk/commons/events/model/NewTaskListEvent.java
``` java
public class NewTaskListEvent extends BaseEvent {

	public final UniqueItemCollection<Task> newTasks;
    public final FilteredList<Task> filteredTasks;

    public NewTaskListEvent(UniqueItemCollection<Task> newTasks, FilteredList<Task> filteredTasks){
        this.newTasks = newTasks;
        this.filteredTasks = filteredTasks;
    }

    @Override
    public String toString() {
        return "number of tasks " + newTasks.getInternalList().size();
    }
}
```
###### /java/w15c2/tusk/commons/collections/UniqueItemCollection.java
``` java
    /**
     * Duplicates an existing UniqueItemCollection
     */
    @SuppressWarnings("unchecked")
	public UniqueItemCollection<T> copyCollection()  {
    	UniqueItemCollection<T> copiedCollection = new UniqueItemCollection<T>();
    	for (T item : internalList) {
    		try {
	    		if (item instanceof Copiable) {
	    			Copiable<T> copiableItem = (Copiable<T>) item;
	    			copiedCollection.add(copiableItem.copy());
	    		} else {
	    			assert false : "The items in the list must implement the Copiable interface";
	    		}
    		} catch (DuplicateItemException die) {
    			assert false : "There should be no duplicate items in the UniqueItemCollection";
    		}
    	}
    	return copiedCollection;
    }

```
###### /java/w15c2/tusk/commons/collections/UniqueItemCollection.java
``` java
    /**
     * Replaces an item to remove with an item to add from the list.
     * 
     * @throws ItemNotFoundException if the item to be removed cannot be found in the list.
     */
    public boolean replace(T toRemove, T toAdd) throws ItemNotFoundException {
    	assert toRemove != null && toAdd != null;
    	for (int i = 0; i < internalList.size(); i++) {
    		if (internalList.get(i) == toRemove) {
    			internalList.remove(i);
    			internalList.add(i, toAdd);
    			return true;
    		}
    	}
    	throw new ItemNotFoundException();
    }

```
###### /java/w15c2/tusk/logic/parser/ClearCommandParser.java
``` java
public class ClearCommandParser extends CommandParser{
	public static final String COMMAND_WORD = ClearTaskCommand.COMMAND_WORD;
	public static final String ALTERNATE_COMMAND_WORD = ClearTaskCommand.ALTERNATE_COMMAND_WORD;
	
	 /**
     * Parses arguments in the context of the clear task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    public TaskCommand prepareCommand(String arguments) {
    	if(!arguments.equals("")){
        	return new IncorrectTaskCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearTaskCommand.MESSAGE_USAGE));
        }
        return new ClearTaskCommand();
    }
}
```
###### /java/w15c2/tusk/logic/parser/AddCommandParser.java
``` java
public class AddCommandParser extends CommandParser{
    public static final String COMMAND_WORD = AddTaskCommand.COMMAND_WORD;
    public static final String ALTERNATE_COMMAND_WORD = AddTaskCommand.ALTERNATE_COMMAND_WORD;

	/**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
	public TaskCommand prepareCommand(String arguments) {
		try {
			// Call the appropriate AddTaskCommand constructor based on the arguments
			return createAppropriateAddTaskCommand(arguments);
		} catch (IllegalValueException ive) {
            return new IncorrectTaskCommand(ive.getMessage());
        }
	}
	
	/**
     * Based on the description for the add command, determines if it is a FloatingTask, DeadlineTask or EventTask to be added.
     * Then, return the appropriate addTaskCommand by calling the corresponding constructor.
     */
    private AddTaskCommand createAppropriateAddTaskCommand(String description)
    			throws IllegalValueException {
    	// If there are double inverted commas at the start and end, it means that it is a FloatingTask
    	if (description.length() > 1 && description.endsWith("\"") && description.startsWith("\"")) {
    		return new AddTaskCommand(description);
    	}
    	
    	// Determine if it is DeadlineTask (which has "by" or "on") or EventTask (which has "from")
    	// Spaces needed before "from", "by" and "on" to ensure they are separate words
    	int finalIndex = -1;
    	String finalString = null;
    	int indexOfLastFrom = description.lastIndexOf(" from ");
    	int indexOfLastBy = description.lastIndexOf(" by ");
    	int indexOfLastOn = description.lastIndexOf(" on ");
    	
    	if (indexOfLastFrom > finalIndex) {
    		finalIndex = indexOfLastFrom;
    		finalString = " from ";
    	}
    	if (indexOfLastBy > finalIndex) {
    		finalIndex = indexOfLastBy;
    		finalString = " by ";
    	}
    	if (indexOfLastOn > finalIndex) {
    		finalIndex = indexOfLastOn;
    		finalString = " on ";
    	}
    	
    	if (finalIndex == -1) {
    		// If all keywords ("from", "by", "on") are missing, it means it is a Floating task
    		return new AddTaskCommand(description);
    	} else {
    		// Create an AddTaskCommand based on the keywords
    		return createAddTaskCommandBasedOnDateString(description, finalIndex, finalString);
    	} 
    }
    
    /**
     * Checks if the string from "substringFrom" to the end of description corresponds to a valid date format or 
     * a valid start date to end date format.
     * 
     * With the results, decide whether the task to add is a DeadlineTask, EventTask or FloatingTask.
     */
    private AddTaskCommand createAddTaskCommandBasedOnDateString(String description, int substringFrom, String keyword) 
    			throws IllegalValueException {
    	// Separate description into task description and the date string
    	String taskDescription = description.substring(0, substringFrom).trim();
    	String dateString = description.substring(substringFrom + keyword.length(), description.length()).trim();
    	
    	if ((keyword.equals(" by ") || keyword.equals(" on ")) && DateUtil.isValidDateFormat(dateString)) {
    		// dateString represents task's deadline
    		Date deadline = DateUtil.getDate(dateString);
			return new AddTaskCommand(taskDescription, deadline);
			
    	} else if (keyword.equals(" from ") && DateUtil.isValidStartDateToEndDateFormat(dateString)) {	
			// dateString represents task's start date and end date
    		Date[] startAndEndDates = DateUtil.getStartAndEndDates(dateString);
    		Date startDate = startAndEndDates[0];
    		Date endDate = startAndEndDates[1];
			return new AddTaskCommand(taskDescription, startDate, endDate);
			
		} else {
			// Floating task since sentence after "from" is not a valid date
			return new AddTaskCommand(description);
		}
    }
}
```
###### /java/w15c2/tusk/logic/parser/UpdateCommandParser.java
``` java
public class UpdateCommandParser extends CommandParser {
	public static final String COMMAND_WORD = UpdateTaskCommand.COMMAND_WORD;
    public static final String ALTERNATE_COMMAND_WORD = UpdateTaskCommand.ALTERNATE_COMMAND_WORD;

    private static final Pattern UPDATE_COMMAND_FORMAT = Pattern.compile("(?<targetIndex>\\S+) (?<updateType>\\S+) (?<arguments>.+)");
    private Matcher matcher;
    
    public static final String MESSAGE_INVALID_UPDATE_TYPE = "Update type must be either task, description or date\n Examples: \n"
    		+ "1) update INDEX task Meeting with colleagues by 20 Oct \n"
    		+ "2) update INDEX description \n"
    		+ "3) update INDEX date 20 Oct to 31 Oct";
    
    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
	public TaskCommand prepareCommand(String arguments) {
		TaskCommand taskCommand;
		
		// Matches the arguments to the update command format
        matcher = UPDATE_COMMAND_FORMAT.matcher(arguments.trim());
        
        // Checks validity of index and update type using the matcher
        taskCommand = checkIndexAndUpdateType();
        if (taskCommand != null) {
        	return taskCommand;
        }

        try {
	        // Creates an appropriate UpdateTaskCommand or IncorrectTaskCommand using the matcher
		    taskCommand = createAppropriateTaskCommand();
        } catch (IllegalValueException ive) {
        	return new IncorrectTaskCommand(ive.getMessage());
        }
	    
	    return taskCommand;
	}
	
	/**
	 * Based on the arguments provided to the update command, determine if the user wants to change
	 * the task, description or date.
	 * Then, return the appropriate UpdateTaskCommand by calling the corresponding constructor or
	 * the IncorrectTaskCommand.
	 */
	private TaskCommand createAppropriateTaskCommand() throws IllegalValueException {
		TaskCommand taskCommand = null;
		int index = Integer.parseInt(matcher.group("targetIndex"));
		String updateType = matcher.group("updateType");
		String arguments = matcher.group("arguments");
		
		// Depending on the update type, choose an appropriate TaskCommand
		if (updateType.equals("task")) {
			taskCommand = createTaskUpdateTaskCommand(index, arguments);
			
		} else if (updateType.equals("description")) {
			taskCommand = createDescriptionUpdateTaskCommand(index, arguments);
			
		} else if (updateType.equals("date")) {
			taskCommand = createDateUpdateTaskCommand(index, arguments);
			
		} else {
			assert false : MESSAGE_INVALID_UPDATE_TYPE;
		}
		
		return taskCommand;
	}
	
	/**
	 * Creates an UpdateTaskCommand to update the entire task
	 */
	private TaskCommand createTaskUpdateTaskCommand(int index, String arguments) throws IllegalValueException {
		// Use AddCommandParser to create the new task that the user wants
		AddCommandParser parser = new AddCommandParser();
		Task task = ((AddTaskCommand) parser.prepareCommand(arguments)).getTask();
		return new UpdateTaskCommand(index, task);
	}
	
	/**
	 * Creates an UpdateTaskCommand to update the description
	 */
	private TaskCommand createDescriptionUpdateTaskCommand(int index, String arguments) throws IllegalValueException {
		Description description = new Description(arguments);
		return new UpdateTaskCommand(index, description);
	}
	
	/**
	 * Creates an UpdateTaskCommand to update the date
	 */
	private TaskCommand createDateUpdateTaskCommand(int index, String arguments) throws IllegalValueException {
		// Check if the arguments that the user provided is a valid date or a valid date range.
		// Then, call the appropriate UpdateTaskCommands or throw an exception (if date is invalid).
		if (DateUtil.isValidDateFormat(arguments)) {
			Date newDeadline = DateUtil.getDate(arguments);
			return new UpdateTaskCommand(index, newDeadline);
			
		} else if (DateUtil.isValidStartDateToEndDateFormat(arguments)) {
    		Date[] startAndEndDates = DateUtil.getStartAndEndDates(arguments);
    		Date newStartDate = startAndEndDates[0];
    		Date newEndDate = startAndEndDates[1];
			return new UpdateTaskCommand(index, newStartDate, newEndDate);
			
		} else {
			throw new IllegalValueException(MESSAGE_INVALID_DATE_FORMAT);
		}
	}
	
	/**
	 * Determines if the index and update type is valid. If it is, return null.
	 * Else, return an IncorrectTaskCommand.
	 */
	private IncorrectTaskCommand checkIndexAndUpdateType() {
		if (!matcher.matches()) {
            return new IncorrectTaskCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateTaskCommand.MESSAGE_USAGE));
        }

        // Check if the index that user gave is valid
        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return new IncorrectTaskCommand(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        // Check if the updateType that user gave is valid
        String updateType = matcher.group("updateType");
        if(!updateType.equals("task") && !updateType.equals("description") && !updateType.equals("date")) {
        	return new IncorrectTaskCommand(MESSAGE_INVALID_UPDATE_TYPE);
        }
        return null;
	}
}
```
###### /java/w15c2/tusk/logic/parser/RedoCommandParser.java
``` java
public class RedoCommandParser extends CommandParser{
    public static final String COMMAND_WORD = RedoTaskCommand.COMMAND_WORD;
    public static final String ALTERNATE_COMMAND_WORD = RedoTaskCommand.ALTERNATE_COMMAND_WORD;


    @Override
    public TaskCommand prepareCommand(String arguments) {
    	if(!arguments.equals("")){
        	return new IncorrectTaskCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RedoTaskCommand.HELP_MESSAGE_USAGE));
        }
        return new RedoTaskCommand();
    }
}
```
###### /java/w15c2/tusk/logic/parser/UndoCommandParser.java
``` java
public class UndoCommandParser extends CommandParser{
    public static final String COMMAND_WORD = UndoTaskCommand.COMMAND_WORD;
    public static final String ALTERNATE_COMMAND_WORD = UndoTaskCommand.ALTERNATE_COMMAND_WORD;

    @Override
    public TaskCommand prepareCommand(String arguments) {
    	if(!arguments.equals("")){
        	return new IncorrectTaskCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoTaskCommand.HELP_MESSAGE_USAGE));
        }
        return new UndoTaskCommand();
    }
}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/UpdateTaskCommand.java
``` java
public class UpdateTaskCommand extends TaskCommand {

	public static final String COMMAND_WORD = "update";
    public static final String ALTERNATE_COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the task identified by the index number used in the last task listing.\n"
            + "Depending on whether 'task', 'description' or 'date' is stated, the task will be updated accordingly.\n"
            + "1) Parameters: INDEX (must be a positive integer) task UPDATED_VALUE\n"
            + "Example: " + COMMAND_WORD + " 1 task Meeting from Oct 31 to Nov 1\n"
            + "2) Parameters: INDEX (must be a positive integer) description UPDATED_VALUE\n"
            + "Example: " + COMMAND_WORD + " 1 description Meeting in town\n"
            + "3) Parameters: INDEX (must be a positive integer) date UPDATED_VALUE\n"
            + "Example: " + COMMAND_WORD + " 1 date Oct 31 to Nov 1";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated task: %1$s";
    public static final String MESSAGE_CANNOT_UPDATE_TASK = "Selected task's description cannot be updated";
    
    public static final String TASK_DETAILS_UPDATE_TASK = "[Update Task][Task: %s]";
    public static final String TASK_DETAILS_UPDATE_DESCRIPTION = "[Update Task][Description: %s]";
    public static final String TASK_DETAILS_UPDATE_DEADLINE = "[Update Task][Deadline: %s]";
    public static final String TASK_DETAILS_UPDATE_START_END_DATE = "[Update Task][Start date: %s][End date: %s]";
    
    public final int targetIndex;
    private Task updatedTask;
    
    // Values that are to be updated. If it is not supposed to be updated, it will be null
    private Task newTask;
    private Description newDescription;
    private Date newDeadline;
    private Date newStartDate;
    private Date newEndDate;

    /**
     * This constructor is called by the user enters a command to replace the entire task.
     * 
     * Example: update 1 task Homework by 31 Oct 2016
     * (Replaces whatever task at index 1 to be a DeadlineTask with description as "Homework" and deadline by 31 Oct 2016)
     */
    public UpdateTaskCommand(int targetIndex, Task newTask) {
        this.targetIndex = targetIndex;
        this.newTask = newTask;
    }
    
    /**
     * This constructor is called by the user enters a command to update the description of a task.
     * 
     * Example: update 1 description Meeting
     * (Changes the description of the task at index 1 to be "Meeting")
     */
    public UpdateTaskCommand(int targetIndex, Description newDescription) {
        this.targetIndex = targetIndex;
        this.newDescription = newDescription;
    }
    
    /**
     * This constructor is called by the user enters a command to update the deadline of a task.
     * 
     * Example: update 1 date 31 Oct
     * (Changes the task at index 1 to have a deadline of 31 Oct 2016 (Whether or not it is a deadline task))
     */
    public UpdateTaskCommand(int targetIndex, Date newDeadline) {
        this.targetIndex = targetIndex;
        this.newDeadline = newDeadline;
    }
    
    /**
     * This constructor is called by the user enters a command to update the start date and end date of a task.
     * 
     * Example: update 1 date 31 Oct to 1 Nov
     * (Changes the task at index 1 to have a start date of 31 Oct and end date of 1 Nov (Whether or not it is an event task))
     */
    public UpdateTaskCommand(int targetIndex, Date newStartDate, Date newEndDate) {
        this.targetIndex = targetIndex;
        this.newStartDate = newStartDate;
        this.newEndDate = newEndDate;
    }
    
    /**
     * Given the task that is to be updated, create a new updatedTask to replace it
     * by retrieving the values to be updated
     */
    public void prepareUpdatedTask(Task taskToUpdate) throws IllegalValueException {
    	if (newTask != null) {
    		// User wants to change the entire task
    		updatedTask = newTask;
    		
    	} else if (newDescription != null) {
    		// User wants to change just the description
    		updatedTask = prepareUpdatedDescriptionForTask(taskToUpdate);
    		
    	} else if (newDeadline != null) {
    		// User wants to change the deadline of a Task
    		updatedTask = prepareUpdatedDeadlineForTask(taskToUpdate);

    	} else if ((newStartDate != null && newEndDate != null)) {
    		// User wants to change the start date and end date of a Task
    		updatedTask = prepareUpdatedStartEndDateForTask(taskToUpdate);
    		
    	} else {
    		assert false : "At least task, description or date should have new values";
    	}
    	
    	// Retain pin status
		if (taskToUpdate.isPinned()) {
			updatedTask.setAsPin();
		}
    }
    
    /**
     * Create a new task with a different description to replace taskToUpdate
     */
    public Task prepareUpdatedDescriptionForTask(Task taskToUpdate) throws IllegalValueException {
    	// Return a new Task based on the type of the task to be updated
		if (taskToUpdate instanceof FloatingTask) {
			return new FloatingTask(newDescription.getContent());
			
		} else if (taskToUpdate instanceof DeadlineTask) {
			DeadlineTask task = (DeadlineTask) taskToUpdate;
			return new DeadlineTask(newDescription.getContent(), task.getDeadline());
			
		} else if (taskToUpdate instanceof EventTask) {
			EventTask task = (EventTask) taskToUpdate;
			return new EventTask(newDescription.getContent(), task.getStartDate(), task.getEndDate());	
		
		} else {
			throw new IllegalValueException(MESSAGE_CANNOT_UPDATE_TASK);
		}	
    }
    
    /**
     * Create a new task with a different deadline to replace taskToUpdate
     */
    public Task prepareUpdatedDeadlineForTask(Task taskToUpdate) throws IllegalValueException {
    	// Create a deadline task to replace the original task
    	String description = taskToUpdate.getDescription().getContent();
		return new DeadlineTask(description, newDeadline);
    }
    
    /**
     * Create a new task with a different start and end date to replace taskToUpdate
     */
    public Task prepareUpdatedStartEndDateForTask(Task taskToUpdate) throws IllegalValueException {
    	// Create an event task to replace the original task
    	String description = taskToUpdate.getDescription().getContent();
		return new EventTask(description, newStartDate, newEndDate);
    }
    
    /**
     * Retrieve the details of the values (with or without time) to be updated for testing purposes
     */
    public String getTaskDetails(boolean withTime) {
    	SimpleDateFormat dateFormat;
    	// Decide which date format to use
    	if (withTime) {
    		dateFormat = DateUtil.dateFormatWithTime;
    	} else {
    		dateFormat = DateUtil.dateFormat;
    	}
    	
    	if (newTask != null) {
    		return String.format(TASK_DETAILS_UPDATE_TASK, newTask.getTaskDetails(withTime));
    	} else if (newDescription != null) {
    		return String.format(TASK_DETAILS_UPDATE_DESCRIPTION, newDescription);
    	} else if (newDeadline != null) {
    		return String.format(TASK_DETAILS_UPDATE_DEADLINE,
    				dateFormat.format(newDeadline));
    	} else if (newStartDate != null && newEndDate != null) {
    		return String.format(TASK_DETAILS_UPDATE_START_END_DATE, 
    				dateFormat.format(newStartDate), dateFormat.format(newEndDate));
    	} else {
    		return "Error";
    	}
    }


    @Override
    public CommandResult execute() {

	    ObservableList<Task> lastShownList = model.getCurrentFilteredTasks();

        if (lastShownList.size() < targetIndex || targetIndex <= 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        Task taskToUpdate = lastShownList.get(targetIndex - 1);

        try {
        	prepareUpdatedTask(taskToUpdate);
            model.updateTask(taskToUpdate, updatedTask);
        } catch (DuplicateItemException die) {
        	assert false : "Deletion of the original task (before addition of an updated task) has failed";
        } catch (IllegalValueException ive) {
        	return new CommandResult(ive.getMessage());
        } catch (ItemNotFoundException tnfe) {
            assert false : "The target item cannot be missing";
        } 

        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, updatedTask.getDescription().getContent()));
    }

}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/RedoTaskCommand.java
``` java
public class RedoTaskCommand extends TaskCommand {
    
    public static final String COMMAND_WORD = "redo";
    public static final String ALTERNATE_COMMAND_WORD = null;

    public static final String MESSAGE_REDO_TASK_SUCCESS = "Redo successful";
    public static final String MESSAGE_REDO_INVALID_STATE = "Redo is not successful because the previous successful command is not undo";

    public static final String HELP_MESSAGE_USAGE = COMMAND_WORD + ": \t redoes previous command.";
    
    public RedoTaskCommand() {}

    @Override
    public CommandResult execute() {
    	try {
    		model.redo();
    	} catch (IllegalStateException ise) {
    		return new CommandResult(MESSAGE_REDO_INVALID_STATE);
    	}
    	return new CommandResult(MESSAGE_REDO_TASK_SUCCESS);
    }
    
    @Override
    public String toString(){
        return MESSAGE_REDO_TASK_SUCCESS;
    }
}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/AddTaskCommand.java
``` java
public class AddTaskCommand extends TaskCommand {

    public static final String COMMAND_WORD = "add";
    public static final String ALTERNATE_COMMAND_WORD = null;

    public static final String HELP_MESSAGE_USAGE = "Add a task: \t" + "add <description> \n" +
            "Add a deadline: \t" + "add <description> by <date> \n" +
            "Add an event: \t" + "add <description> from <startDate> to <endDate>";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to TaskManager. \n"
            + "1) Parameters: DESCRIPTION \n"
            + "Example: " + COMMAND_WORD
            + " Finish V0.1 \n"
            + "2) Parameters: DESCRIPTION by DEADLINE \n"
            + "Example: " + COMMAND_WORD
            + " Finish V0.1 by Oct 31 \n"
            + "3) Parameters: DESCRIPTION from START_DATE to END_DATE \n"
            + "Example: " + COMMAND_WORD
            + " Software Demo from Oct 31 to Nov 1";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in TaskManager";
    public static final String MESSAGE_EMPTY_TASK = "Description to AddTaskCommand constructor is empty.\n";

    private Task toAdd;

    /**
     * A FloatingTask has only one parameter, description.
     * This AddTaskCommand constructor takes in a description and adds a FloatingTask.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddTaskCommand(String description)
            throws IllegalValueException {
    	if (description == null || description.isEmpty()) {
    		throw new IllegalValueException(MESSAGE_EMPTY_TASK + MESSAGE_USAGE);
    	}
    	this.toAdd = new FloatingTask(description);
    }
    
    /**
     * A DeadlineTask has only two parameters, description and a deadline.
     * This AddTaskCommand constructor takes in a description and a deadline, and adds a DeadlineTask.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddTaskCommand(String description, Date deadline)
            throws IllegalValueException {
    	if (description == null || description.isEmpty()) {
    		throw new IllegalValueException("Description to AddTaskCommand constructor is empty.");
    	}
    	this.toAdd = new DeadlineTask(description, deadline);
    }
    
    /**
     * An EventTask has only three parameter, description, startDate and endDate.
     * This AddTaskCommand constructor takes in a description, startDate and endDate, and adds an EventTask.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddTaskCommand(String description, Date startDate, Date endDate)
            throws IllegalValueException {
    	if (description == null || description.isEmpty()) {
    		throw new IllegalValueException("Description to AddTaskCommand constructor is empty.");
    	}
    	this.toAdd = new EventTask(description, startDate, endDate);
    }
    
    /**
     * Retrieve the details of the task (with or without time information) for testing purposes
     */
    public String getTaskDetails(boolean withTime) {
    	return toAdd.getTaskDetails(withTime);
    }
    
    /**
     * Retrieve the task to add
     */
    public Task getTask() {
    	return toAdd;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            model.clearTasksFilter();
            EventsCenter.getInstance().post(new HideHelpRequestEvent());
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateItemException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }

}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/UndoTaskCommand.java
``` java
public class UndoTaskCommand extends TaskCommand {
    
    public static final String COMMAND_WORD = "undo";
    public static final String ALTERNATE_COMMAND_WORD = null;
    
    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo successful";
    public static final String MESSAGE_UNDO_INVALID_STATE = "Undo is not successful because there is no previous command";
    public static final String HELP_MESSAGE_USAGE = COMMAND_WORD + ": \t undoes previous command.";

    
    public UndoTaskCommand() {}

    @Override
    public CommandResult execute() {
    	try {
    		model.undo();
    	} catch (IllegalStateException ise) {
    		return new CommandResult(MESSAGE_UNDO_INVALID_STATE);
    	}
    	EventsCenter.getInstance().post(new HideHelpRequestEvent());
    	return new CommandResult(MESSAGE_UNDO_TASK_SUCCESS);
    }
    
    @Override
    public String toString(){
        return MESSAGE_UNDO_TASK_SUCCESS;
    }
}
```
###### /java/w15c2/tusk/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends TaskCommand {
    
    public static final String COMMAND_WORD = "undo";
    public static final String ALTERNATE_COMMAND_WORD = null;
    
    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo successful";
    public static final String MESSAGE_UNDO_INVALID_STATE = "Undo is not successful because there is no previous command";

    public static final String HELP_MESSAGE_USAGE = COMMAND_WORD + ": \t undoes previous command.";
    
    public UndoCommand() {}

    @Override
    public CommandResult execute() {
    	try {
    		model.undo();
    	} catch (IllegalStateException ise) {
    		return new CommandResult(MESSAGE_UNDO_INVALID_STATE);
    	}
    	return new CommandResult(MESSAGE_UNDO_TASK_SUCCESS);
    }
}
```
###### /java/w15c2/tusk/model/task/DeadlineTask.java
``` java
public class DeadlineTask extends Task implements PinnableTask, CompletableTask {

	private Date deadline;

	public DeadlineTask(String descriptionText, Date deadline) {
		this.description = new Description(descriptionText);
		this.deadline = deadline;
	}
		
	public Date getDeadline() {
		return deadline;
	}
	
	@Override
	public DeadlineTask copy() {
		String newDescription = this.description.getContent();
		Date newDeadline = new Date(this.deadline.getTime());
		DeadlineTask newTask = new DeadlineTask(newDescription, newDeadline);
		
		// Copy pin status
		if (this.isPinned()) {
			newTask.setAsPin();
		} else {
			newTask.setAsNotPin();
		}
		
		// Copy completed status
		if (this.isCompleted()) {
			newTask.setAsComplete();
		} else {
			newTask.setAsUncomplete();
		}
		return newTask;
	}
	
	@Override
	public String toString() {
		return description.toString();
	}
	
	@Override
	// Return the specifics of each task (with or without time)
	public String getTaskDetails(boolean withTime) {
		if (withTime) {
			return String.format("[Deadline Task][Description: %s][Deadline: %s]", 
					description, DateUtil.dateFormatWithTime.format(deadline));
		} else {
			return String.format("[Deadline Task][Description: %s][Deadline: %s]", 
					description, DateUtil.dateFormat.format(deadline));
		}
	}
	
	@Override
	public boolean isOverdue() {
	    return deadline.before(new Date());
	}
}
```
###### /java/w15c2/tusk/model/task/TaskManager.java
``` java
	@Override
	public void undo() throws IllegalStateException {
		// Undoing task type command
		if (modelHistory.canUndoTasks()) {
			// Current values of tasks passed to undoManager to be stored to allow user to redo.
			// Tasks that will replace the current list is returned.
			UniqueItemCollection<Task> replacingTasks = modelHistory.undoTasks(tasks);
			
			// The current tasks have been reinstated to their older versions
			tasks = replacingTasks;
			
		// Undoing alias type command
		} else if (modelHistory.canUndoAliases()) {
			// Current values of aliases passed to undoManager to be stored to allow user to redo.
			// Aliases that will replace the current list is returned
			UniqueItemCollection<Alias> replacingAliases = modelHistory.undoAliases(aliases);
			
			// The current aliases have been reinstated to their older versions
			aliases = replacingAliases;
			
		} else { 
			throw new IllegalStateException("Unable to undo because there is no previous state to revert to"); 
		}
		// Clear old values of tasks & aliases
		modelHistory.clearOldCopies();
		
		// Save the old predicate before we reassign filteredTasks
		Predicate<? super Task> currentPredicate = filteredTasks.getPredicate();
		
		// Refresh the filtered tasks
		filteredTasks = new FilteredList<>(tasks.getInternalList());
		
		// Reapply the predicate
		filteredTasks.setPredicate(currentPredicate);
		
		// Raise the changes
		indicateNewTaskListEvent();
		indicateAliasChanged();
	}
	
	/**
	 * Redoes the command that has been undone
	 * (Can only be called if the previous successful command was a successful undo command)
	 */
```
###### /java/w15c2/tusk/model/task/TaskManager.java
``` java
	@Override
	public void redo() throws IllegalStateException {
		// Redoing task type command
		if (modelHistory.canRedoTasks()) {
			// Current values of tasks passed to undoManager to be stored to allow user to undo.
			// Tasks that will replace the current list is returned.
			UniqueItemCollection<Task> replacingTasks = modelHistory.redoTasks(tasks);
			
			// The current tasks have been reinstated to the versions before 'undo' has been called
			tasks = replacingTasks;
			
		// Undoing alias type command
		} else if (modelHistory.canRedoAliases()) {
			// Current values of aliases passed to undoManager to be stored to allow user to undo.
			// Aliases that will replace the current list is returned
			UniqueItemCollection<Alias> replacingAliases = modelHistory.redoAliases(aliases);
			
			// The current aliases have been reinstated to the versions before 'undo' has been called
			aliases = replacingAliases;
			
		} else { 
			throw new IllegalStateException("Unable to redo because the previous successful command was not an undo command"); 
		}
		// Clear values of tasks & aliases that have been stored due to 'undo'
		modelHistory.clearUndoneCopies();
		
		// Save the old predicate before we reassign filteredTasks
		Predicate<? super Task> currentPredicate = filteredTasks.getPredicate();
		
		// Refresh the filtered tasks
		filteredTasks = new FilteredList<>(tasks.getInternalList());
		
		// Reapply the predicate
		filteredTasks.setPredicate(currentPredicate);
		
		// Raise the changes
		indicateNewTaskListEvent();
		indicateAliasChanged();
	}
```
###### /java/w15c2/tusk/model/task/EventTask.java
``` java
public class EventTask extends Task implements PinnableTask, CompletableTask {

	private Date startDate;
	private Date endDate;

	public EventTask(String descriptionText, Date startDate, Date endDate) {
		this.description = new Description(descriptionText);
		this.startDate = startDate;
		this.endDate = endDate;
	}
	

	public Date getStartDate() {
		return startDate;
	}
	
	public Date getEndDate() {
		return endDate;
	}
	
	@Override
	public EventTask copy() {
		String newDescription = this.description.getContent();
		Date newStartDate = new Date(this.startDate.getTime());
		Date newEndDate = new Date(this.endDate.getTime());
		EventTask newTask = new EventTask(newDescription, newStartDate, newEndDate); 
		
		// Copy pin status
		if (this.isPinned()) {
			newTask.setAsPin();
		} else {
			newTask.setAsNotPin();
		}
		
		// Copy completed status
		if (this.isCompleted()) {
			newTask.setAsComplete();
		} else {
			newTask.setAsUncomplete();
		}
		
		return newTask;
	}
	
	@Override
	public String toString() {
		return description.toString();
	}
	
	@Override
	// Return the specifics of each task (with or without time)
	public String getTaskDetails(boolean withTime) {
		if (withTime) {
			return String.format("[Event Task][Description: %s][Start date: %s][End date: %s]", 
					description, DateUtil.dateFormatWithTime.format(startDate), DateUtil.dateFormatWithTime.format(endDate));
		} else {
			return String.format("[Event Task][Description: %s][Start date: %s][End date: %s]", 
					description, DateUtil.dateFormat.format(startDate), DateUtil.dateFormat.format(endDate));
		}
	}
	
    @Override
    public boolean isOverdue() {
        return startDate.before(new Date());
    }
}
```
###### /java/w15c2/tusk/model/ModelHistory.java
``` java
public class ModelHistory {
	// Collection to store the tasks / aliases after each command that changes tasks or aliases. Allows user to undo.
	private UniqueItemCollection<Task> oldTasks;
	private UniqueItemCollection<Alias> oldAliases;
	 
	// Collection to store the current tasks / aliases before an undo command. Allows user to redo.
	private UniqueItemCollection<Task> undoneTasks;
	private UniqueItemCollection<Alias> undoneAliases;
	
	public ModelHistory() {}
	
	
	// ============================ Supporting Undo ============================
	
	/**
	 * Stores the list of old tasks so that undo can be called later.
	 */
	public void storeOldTasks(UniqueItemCollection<Task> oldCopy) {
		oldTasks = oldCopy;
		oldAliases = null; // Null to signal that aliases have not been changed
		
		// No tasks and aliases have been undone
		undoneTasks = null;
		undoneAliases = null;
	}
	
	/**
	 * If oldTasks exist, it means that there are tasks to be undone
	 */
	public boolean canUndoTasks() {
		return oldTasks != null;
	}
	
	/**
	 * Stores the list of old aliases so that undo can be called later.
	 */
	public void storeOldAliases(UniqueItemCollection<Alias> oldCopy) {
		oldAliases = oldCopy;
		oldTasks = null; // Null to signal that tasks have not been changed
		
		// No tasks and aliases have been undone
		undoneTasks = null;
		undoneAliases = null;
	}
	
	/**
	 * If oldAliases exist, it means that there are aliases to be undone
	 */
	public boolean canUndoAliases() {
		return oldAliases != null;
	}
	
	/**
	 * Clear old copies of aliases and tasks after undo
	 */
	public void clearOldCopies() {
		// Can only undo once. Hence, oldTasks & oldAliases are set to null after one undo
		oldAliases = null;
		oldTasks = null;
	}
	
	/**
	 * Returns oldTasks which is the old state of the task list,
	 * Stores current value in undoneTasks in case user wants to reverse the undo (redo)
	 */
	public UniqueItemCollection<Task> undoTasks(UniqueItemCollection<Task> currentTasks) {
		// Before undoing task, undoneTasks is assigned the current list of tasks to allow user to redo
		undoneTasks = currentTasks;
		// Since no alias have been undone, undoneAliases set to null
		undoneAliases = null;
		
		// Return the old copy of tasks
		return oldTasks;
	}
	
	/**
	 * Returns oldAliases which is the old state of the alias list,
	 * Stores current value in undoneAliases in case user wants to reverse the undo (redo)
	 */
	public UniqueItemCollection<Alias> undoAliases(UniqueItemCollection<Alias> currentAliases) {
		// Before undoing task, undoneAliases is assigned the current list of tasks to allow user to redo
		undoneAliases = currentAliases;
		// Since no alias have been undone, undoneTasks set to null
		undoneTasks = null;
		
		// Return the old copy of Aliases
		return oldAliases;
	}
	
	// ============================ Supporting Redo ============================
	
	/**
	 * Stores the list of tasks that have been undone (so that redo can be called later).
	 */
	public void storeUndoneTasks(UniqueItemCollection<Task> currentCopy) {
		undoneTasks = currentCopy;
		undoneAliases = null; // Null to signal that aliases have not been undone
		
		// No tasks and aliases have been changed
		oldTasks = null;
		oldAliases = null;
	}
	
	/**
	 * If undoneTasks exist, it means that there are tasks to be redone
	 */
	public boolean canRedoTasks() {
		return undoneTasks != null;
	}
	
	/**
	 * Stores the list of aliases that have been undone (so that redo can be called later).
	 */
	public void storeUndoneAliases(UniqueItemCollection<Alias> currentCopy) {
		undoneAliases = currentCopy; 
		undoneTasks = null; // Null to signal that task have not been undone
		
		// No tasks and aliases have been changed
		oldTasks = null;
		oldAliases = null;
	}
	
	/**
	 * If undoneAliases exist, it means that there are aliases to be redone
	 */
	public boolean canRedoAliases() {
		return undoneAliases != null;
	}
	
	/**
	 * Clear copies of undone aliases and tasks after redo
	 */
	public void clearUndoneCopies() {
		// Can only redo once. Hence, undoneTasks & undoneAliases are set to null after one redo
		undoneAliases = null;
		undoneTasks = null;
	}
	
	/**
	 * Returns undoneTasks which is the state of the task list before 'undo' has been called,
	 * Stores current value in oldTasks in case user wants to reverse the redo (undo)
	 */
	public UniqueItemCollection<Task> redoTasks(UniqueItemCollection<Task> currentTasks) {
		// Before redoing task, oldTasks is assigned the current list of tasks to allow user to undo
		oldTasks = currentTasks;
		// Since no alias have been redone, oldAliases set to null
		oldAliases = null;
		
		// Return the tasks before undo has been called
		return undoneTasks;
	}
	
	/**
	 * Returns oldAliases which is the old state of the alias list,
	 * Stores current value in undoneAliases in case user wants to reverse the undo (redo)
	 */
	public UniqueItemCollection<Alias> redoAliases(UniqueItemCollection<Alias> currentAliases) {
		// Before undoing task, undoneAliases is assigned the current list of tasks to allow user to redo
		oldAliases = currentAliases;
		// Since no alias have been redone, undoneTasks set to null
		oldTasks = null;
		
		// Return the aliases before undo has been called
		return undoneAliases;
	}
	
}
```
###### /java/w15c2/tusk/model/Copiable.java
``` java
public interface Copiable<T> {
	/**
	 * This class allows the instance of another class to be copied to return a new instance of that class.
	 */
	 public T copy();
}
```
