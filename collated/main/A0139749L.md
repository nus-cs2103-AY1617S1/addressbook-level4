# A0139749L
###### \java\seedu\emeraldo\commons\exceptions\QualifierLogicalOperatorMismatch.java
``` java
/**
 * Signals that QualifierList and LogicalOperatorList does not have the right size
 * LogicalOperatorList size must always be 1 less than QualifierList size
 */
public class QualifierLogicalOperatorMismatch extends Exception {

    public QualifierLogicalOperatorMismatch(String message) {
        super(message);
    }
}
```
###### \java\seedu\emeraldo\logic\commands\AddCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task manager. "
            + "Parameters: \"TASK_DESCRIPTION\" [on DATE] [by DATE_TIME] [from START_DATE_TIME]"
            + "[to END_DATE_TIME] [#TAGS]...\n"
            + "Example: " + COMMAND_WORD
            + " \"CS2103T Lecture\" on 7 Oct 2016 #Important\n"
            + "                add \"Sports Camp\" from 12 Dec, 10am to 14 Dec, 8pm";
```
###### \java\seedu\emeraldo\logic\commands\ListAllCommand.java
``` java
/**
* Lists all tasks in Emeraldo to the user.
*/
public class ListAllCommand extends Command {

	public static final String COMMAND_WORD = "listall";

	public static final String MESSAGE_LIST_ALL = "All tasks are successfully listed!\n";
  
	public static final String MESSAGE_LIST_KEYWORD = "All tasks with tag '%s' successfully listed!\n";
  
	public static final String MESSAGE_LIST_TIMEPERIOD = "All tasks happening %s successfully listed!\n";
  
	public static final String MESSAGE_USAGE = "(1) " + COMMAND_WORD + " :  Lists all tasks\n"
			+ "(2) " + COMMAND_WORD + " [PRE-DEFINED KEYWORDS] :  Lists all tasks in the period specified\n"
			+ "(3) " + COMMAND_WORD + " [KEYWORD] :  Lists all tasks with tags containing the specified keyword\n"
			+ "Example:  " + COMMAND_WORD + "  |  " + COMMAND_WORD + " today  |  " + COMMAND_WORD + " tomorrow"
			+ "  |  " + COMMAND_WORD + " homework";

	private String keyword;
	private String successMessage;
	private TimePeriod timePeriod;
  
	public ListAllCommand(String keyword){
		this.keyword = keyword;
	}
  
	@Override
	public CommandResult execute() {
		if(keyword.isEmpty()){
			model.updateFilteredListToShowAll();
			this.successMessage = MESSAGE_LIST_ALL;
			
      	}else if(keywordSatifiesTimePeriod()){
      		model.updateFilteredTaskListWithCompleted(timePeriod);
      		this.successMessage = String.format(MESSAGE_LIST_TIMEPERIOD, keyword);
      	
      	}else{
      		model.updateFilteredTaskListWithCompleted(keyword);
      		this.successMessage = String.format(MESSAGE_LIST_KEYWORD, keyword.toLowerCase())
      				+ getMessageForTaskListShownSummary(model.getFilteredTaskList().size());
      	}
		return new CommandResult(successMessage);
	}
  
	private boolean keywordSatifiesTimePeriod(){
		boolean result;
		switch(this.keyword.toLowerCase()){
  			case "today":
  				this.timePeriod = TimePeriod.today;    			
  				result = true;
  				break;
  			case "tomorrow":
  				this.timePeriod = TimePeriod.tomorrow;
  				result = true;
  				break;
  			case "thisweek":
  				this.timePeriod = TimePeriod.thisWeek;
  				this.keyword = "this week";
  				result = true;
  				break;
  			case "nextweek":
  				this.timePeriod = TimePeriod.nextWeek;
  				this.keyword = "next week";
  				result = true;
  				break;
  			case "thismonth":
  				this.timePeriod = TimePeriod.thisMonth;
  				this.keyword = "this month";
  				result = true;
  				break;
  			case "nextmonth":
  				this.timePeriod = TimePeriod.nextMonth;
  				this.keyword = "next month";
  				result = true;
  				break;
  			default:
  				result = false;
		}
		return result;
	}
  
}
```
###### \java\seedu\emeraldo\logic\commands\ListCommand.java
``` java
/**
 * Lists uncompleted tasks in Emeraldo to the user base on the keyword specified.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    
    public static final String MESSAGE_LIST_UNCOMPLETED = "Tasks that are uncompleted are successfully listed!\n";
    
    public static final String MESSAGE_LIST_KEYWORD = "Uncompleted tasks with tag '%s' successfully listed!\n";
    
    public static final String MESSAGE_LIST_TIMEPERIOD = "Uncompleted tasks happening %s successfully listed!\n";
    
    public static final String MESSAGE_LIST_COMPLETED = "Tasks that are completed successfully listed!\n";
    
    public static final String MESSAGE_USAGE = "(1) " + COMMAND_WORD + " :  Lists all uncompleted tasks\n"
    		+ "(2) " + COMMAND_WORD + " [PRE-DEFINED KEYWORDS] :  Lists uncompleted tasks in the period specified\n"
            + "(3) " + COMMAND_WORD + " [KEYWORD] :  Lists uncompleted tasks with tags containing the specified keyword\n"
            + "Example:  " + COMMAND_WORD + "  |  " + COMMAND_WORD + " today  |  " + COMMAND_WORD + " tomorrow"
    		+ "  |  " + COMMAND_WORD + " homework";

    private String keyword;
    private String successMessage;
    private TimePeriod timePeriod;
    
    public ListCommand(String keyword){
        this.keyword = keyword;
    }
    
    @Override
    public CommandResult execute() {
        if(keyword.isEmpty()){
            model.updateFilteredListToShowUncompleted();
            this.successMessage = MESSAGE_LIST_UNCOMPLETED;
            
        }else if(keywordSatifiesTimePeriod()){
        	model.updateFilteredTaskList(timePeriod);
        	this.successMessage = String.format(MESSAGE_LIST_TIMEPERIOD, keyword);
        	
        }else if (keyword.equalsIgnoreCase("completed")){
        	model.updateFilteredTaskList(Completed.completed);
        	this.successMessage = String.format(MESSAGE_LIST_COMPLETED, keyword.toLowerCase());
        	
    	}else{
            model.updateFilteredTaskList(keyword);
            this.successMessage = String.format(MESSAGE_LIST_KEYWORD, keyword.toLowerCase())
            		+ getMessageForTaskListShownSummary(model.getFilteredTaskList().size());
        }
        return new CommandResult(successMessage);
    }
    
    private boolean keywordSatifiesTimePeriod(){
    	boolean result;
    	switch(this.keyword.toLowerCase()){
    		case "today":
    			this.timePeriod = TimePeriod.today;    			
    			result = true;
    			break;
    		case "tomorrow":
    			this.timePeriod = TimePeriod.tomorrow;
    			result = true;
    			break;
    		case "thisweek":
    			this.timePeriod = TimePeriod.thisWeek;
    			this.keyword = "this week";
    			result = true;
    			break;
    		case "nextweek":
    			this.timePeriod = TimePeriod.nextWeek;
    			this.keyword = "next week";
    			result = true;
    			break;
    		case "thismonth":
    			this.timePeriod = TimePeriod.thisMonth;
    			this.keyword = "this month";
    			result = true;
    			break;
    		case "nextmonth":
    			this.timePeriod = TimePeriod.nextMonth;
    			this.keyword = "next month";
    			result = true;
    			break;
    		default:
    			result = false;
    	}
    	return result;
    }
    
    public enum TimePeriod {today, tomorrow, thisWeek, nextWeek, thisMonth, nextMonth};
    public enum Completed {completed};
}
```
###### \java\seedu\emeraldo\logic\parser\Parser.java
``` java
    private static final Pattern TASK_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("\"(?<description>.+)\""
                    + "(?<dateTime>((( by )|( on )|( from ))[^#]+)?)"
                    + "(?<tagArguments>(?: #[^#]+)*)"); // variable number of tags
    
```
###### \java\seedu\emeraldo\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the list task command.
     *
     * @param args full command args string
     * @return the prepared command
     */    
    private Command prepareList(String args) {
        final Matcher matcher = LIST_KEYWORD_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ListCommand.MESSAGE_USAGE));
        }

        return new ListCommand(args.trim());
    }
    
    private Command prepareListAll(String args) {
        final Matcher matcher = LISTALL_KEYWORD_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ListAllCommand.MESSAGE_USAGE));
        }

        return new ListAllCommand(args.trim());
    }
}
```
###### \java\seedu\emeraldo\model\Model.java
``` java
    /** Updates the filter of the filtered task list to filter by the given keywords
     * without task with completed tag*/
    void updateFilteredTaskList(Set<String> keywords);
    
    /** Updates the filter of the filtered task list to filter by a single given keyword
     * without task with completed tag*/
    void updateFilteredTaskList(String keyword);
    
    /** Updates the filter of the filtered task list to filter by the given time period
     * without task with completed tag*/
    void updateFilteredTaskList(TimePeriod keywords);
    
    /** Updates the filter of the filtered task list to show all tasks without completed tag*/
    void updateFilteredListToShowUncompleted();
    
//=========== Filtered Task List that including completed ones ==============================================
    
    /** Updates the filter of the filtered task list to filter by the given keywords*/
	void updateFilteredTaskListWithCompleted(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by a single given keyword*/
	void updateFilteredTaskListWithCompleted(String keyword); 
    
    /** Updates the filter of the filtered task list to filter by the given time period*/
    void updateFilteredTaskListWithCompleted(TimePeriod keyword);
    
    /**Updates the filter of the filtered task list to filter by the keyword "completed*/
    void updateFilteredTaskList(Completed keyword);

}
```
###### \java\seedu\emeraldo\model\ModelManager.java
``` java
    private void updateFilteredTaskListWhenCompletedIsUsed(){
    	if(keywords == null || keywords.equals("show all")){
    		updateFilteredListToShowAll();
    	}else if(keywords.equals("show uncompleted")){
    		updateFilteredTaskListWithCompletedInPast10Seconds();
    	}else if(keywords instanceof Set<?>){
    		updateFilteredTaskListWithCompletedInPast10Seconds((Set<String>)keywords);
    	}else if(keywords instanceof String){
    		updateFilteredTaskListWithCompletedInPast10Seconds((String)keywords);
    	}else if(keywords instanceof TimePeriod){
    		updateFilteredTaskListWithCompletedInPast10Seconds((TimePeriod)keywords);
    	}
    }
```
###### \java\seedu\emeraldo\model\ModelManager.java
``` java
    //=========== Filtered Task List Accessors (Without completed tag) ========================================
    @Override
    public void updateFilteredListToShowUncompleted() {
    	this.keywords = "show uncompleted";
        updateFilteredTaskList(new PredicateExpression(new UncompletedQualifier()));
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords){
    	this.keywords = keywords;
        PredicateExpression predicateExpression = new PredicateExpression(new DescriptionQualifier(keywords), new UncompletedQualifier());
        predicateExpression.setLogicalOperatorList("and");
    	updateFilteredTaskList(predicateExpression);
    }
    
    @Override
    public void updateFilteredTaskList(String keyword){
    	this.keywords = keyword;
        PredicateExpression predicateExpression = new PredicateExpression(new TagQualifier(keyword), new UncompletedQualifier());
        predicateExpression.setLogicalOperatorList("and");
    	updateFilteredTaskList(predicateExpression);
    }
    
    @Override
    public void updateFilteredTaskList(TimePeriod keyword){
    	this.keywords = keyword;
        PredicateExpression predicateExpression = new PredicateExpression(new DateTimeQualifier(keyword), new UncompletedQualifier());
        predicateExpression.setLogicalOperatorList("and");
    	updateFilteredTaskList(predicateExpression);
    }
    
    //=========== Filtered Task List Accessors (With completed tag) ========================================
    @Override
    public void updateFilteredTaskListWithCompleted(Set<String> keywords){
        updateFilteredTaskList(new PredicateExpression(new DescriptionQualifier(keywords)));
    }
    
    @Override
    public void updateFilteredTaskListWithCompleted(String keyword){
        updateFilteredTaskList(new PredicateExpression(new TagQualifier(keyword)));
    }
    
    @Override
    public void updateFilteredTaskListWithCompleted(TimePeriod keyword){
        updateFilteredTaskList(new PredicateExpression(new DateTimeQualifier(keyword)));
    }
    
    //=========== Filtered Task List Accessors (With completed tag in past 10 sec) ========================
    
    public void updateFilteredTaskListWithCompletedInPast10Seconds(Set<String> keywords){
        PredicateExpression predicateExpression
        	= new PredicateExpression(new DescriptionQualifier(keywords),new Past10SecondsQualifier(),new UncompletedQualifier());
        updateFilteredTaskListWithCompletedInPast10Seconds(predicateExpression);
    }
    
    public void updateFilteredTaskListWithCompletedInPast10Seconds(String keyword){
        PredicateExpression predicateExpression
    		= new PredicateExpression(new TagQualifier(keyword),new Past10SecondsQualifier(),new UncompletedQualifier());
        updateFilteredTaskListWithCompletedInPast10Seconds(predicateExpression);
    }
    
    public void updateFilteredTaskListWithCompletedInPast10Seconds(TimePeriod keyword){
        PredicateExpression predicateExpression
    		= new PredicateExpression(new DateTimeQualifier(keyword),new Past10SecondsQualifier(),new UncompletedQualifier());
        updateFilteredTaskListWithCompletedInPast10Seconds(predicateExpression);
    }
    
    public void updateFilteredTaskListWithCompletedInPast10Seconds(){
        PredicateExpression predicateExpression = new PredicateExpression(new Past10SecondsQualifier(), new UncompletedQualifier());
        predicateExpression.setLogicalOperatorList("or");
    	updateFilteredTaskList(predicateExpression);
    }
    
    private void updateFilteredTaskListWithCompletedInPast10Seconds(Expression expression) {
        filteredTasks.setPredicate(expression::satisfiesPast10Seconds);
    }
```
###### \java\seedu\emeraldo\model\ModelManager.java
``` java
    private class PredicateExpression implements Expression {

        private ArrayList<Qualifier> qualifierList = new ArrayList<Qualifier>();
        private ArrayList<String> logicalOperatorList = new ArrayList<String>();
        
        PredicateExpression(Qualifier... qualifier) {
        	for(Qualifier q: qualifier)
        		qualifierList.add(q);
        }
        
        public void setLogicalOperatorList(String... logicalOperator){
        	for(String s: logicalOperator)
        		logicalOperatorList.add(s);
        }

        /*
         * Compares the boolean result from each qualifier using the logical operator in sequence
         */
        @Override
        public boolean satisfies(ReadOnlyTask task) {
        	try{
        		if(!isValidQualifierAndOperator())
        			throw new QualifierLogicalOperatorMismatch(String.format(MESSAGE_QUALIFIER_ERROR
        				, logicalOperatorList.size(), qualifierList.size()));
        	} catch(QualifierLogicalOperatorMismatch e) {
        		e.printStackTrace();
        	}
        	
        	int i = 0;
        	boolean result = qualifierList.get(0).run(task);
        	
        	for(i = 0; i < logicalOperatorList.size(); i++){
        		result = resultOfOperatorOnQualifiers(result, qualifierList.get(i+1), logicalOperatorList.get(i), task);
        	}
        	return result;
        }
        
        private boolean isValidQualifierAndOperator(){
        	return logicalOperatorList.size() == qualifierList.size()-1;
        }
        
        private boolean resultOfOperatorOnQualifiers(boolean prevResult, Qualifier qualifier, String operator, ReadOnlyTask task){
        	if(operator.equalsIgnoreCase("and")){
        		return prevResult && qualifier.run(task); 
        	}else if(operator.equalsIgnoreCase("or")){
        		return prevResult || qualifier.run(task); 
        	}else{
        		return false;
        	}
        }
        
        @Override
        public boolean satisfiesPast10Seconds(ReadOnlyTask task){
        	return (qualifierList.get(0).run(task) && qualifierList.get(1).run(task))
        			|| (qualifierList.get(0).run(task) && qualifierList.get(2).run(task));
        }
        
        @Override
        public String toString() {
        	StringBuilder qualifierString = new StringBuilder();
        	
        	for(Qualifier q: qualifierList)
        		qualifierString.append(q.toString());
            return qualifierString.toString();
        }
    }
```
###### \java\seedu\emeraldo\model\ModelManager.java
``` java
    /*
     *  Compare tasks tags with keywords
     */
    private class TagQualifier implements Qualifier {
        String tagKeyWord;

        TagQualifier(String keyWord) {
            this.tagKeyWord = keyWord;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            boolean tagMatcher = false;
            Tag tag;
            Iterator<Tag> tagIterator = task.getTags().iterator();
            while(tagIterator.hasNext()){
                tag = tagIterator.next();
                tagMatcher = tagMatcher || run(tag);
            }
            return tagMatcher;
        }
        
        private boolean run(Tag tag){
            return tag.tagName.equalsIgnoreCase(tagKeyWord);
        }

        @Override
        public String toString() {
            return "tag= " + tagKeyWord;
        }
    }
    
    /*
     *  Compare tasks dateTime with the period specified by the keyword
     */
    private class DateTimeQualifier implements Qualifier {
        TimePeriod dateTimeKeyWord;

        DateTimeQualifier(TimePeriod keyWord) {
            this.dateTimeKeyWord = keyWord;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
        	DateTime dateTime = task.getDateTime();
        	
        	if(dateTime.valueDate == null){				//For tasks without date specified
        		return false;
        	}else if(dateTime.valueDateEnd == null){	//For tasks without end date specified
        		return isWithinTimePeriodSpecified(dateTimeKeyWord,dateTime,false);
        	}else{										//For tasks with end date specified
        		return isWithinTimePeriodSpecified(dateTimeKeyWord,dateTime,true);
        	}
        }
        
        private boolean isWithinTimePeriodSpecified(TimePeriod dateTimeKeyWord,DateTime dateTime, boolean hasEndDate){
        	boolean result;
        	LocalDate startDate = dateTime.valueDate;
        	LocalDate endDate;
        	LocalDate dateForConsideration;
        	
        	if(!hasEndDate){
        		switch(dateTimeKeyWord){
					case today:
						result = startDate.equals(LocalDate.now());
						break;
					case tomorrow:
						result = startDate.equals(LocalDate.now().plusDays(1));
						break;
					case thisWeek:
						result = startDate.isAfter(dateOfThisWeekSunday().minusWeeks(1))
							&& startDate.isBefore(dateOfThisWeekSunday().plusDays(1));
						break;
					case nextWeek:
						result = startDate.isAfter(dateOfThisWeekSunday())
							&& startDate.isBefore(dateOfThisWeekSunday().plusDays(8));
						break;
					case thisMonth:
						result = startDate.getMonthValue() == LocalDate.now().getMonthValue();
						break;
					case nextMonth:
						result = startDate.getMonthValue() == LocalDate.now().plusMonths(1).getMonthValue();
						break;
					default:
						result = false;
        		}
        		
        	} else {
        		endDate = dateTime.valueDateEnd;
        		switch(dateTimeKeyWord){
					case today:
						dateForConsideration = LocalDate.now();
						result = startDate.equals(dateForConsideration) || endDate.equals(dateForConsideration)
							|| (startDate.isBefore(dateForConsideration) && endDate.isAfter(dateForConsideration));
						break;
					case tomorrow:
						dateForConsideration = LocalDate.now().plusDays(1);
						result = startDate.equals(dateForConsideration) || endDate.equals(dateForConsideration)
							|| (startDate.isBefore(dateForConsideration) && endDate.isAfter(dateForConsideration));
						break;
					case thisWeek:
						result = startDate.isBefore(dateOfThisWeekSunday().plusDays(1))
							&& endDate.isAfter(dateOfThisWeekSunday().minusWeeks(1));
						break;
					case nextWeek:
						result = startDate.isBefore(dateOfThisWeekSunday().plusDays(8))
							&& endDate.isAfter(dateOfThisWeekSunday());
						break;
					case thisMonth:
						result = startDate.getMonthValue() <= LocalDate.now().getMonthValue()
							&& endDate.getMonthValue() >= LocalDate.now().getMonthValue();
						break;
					case nextMonth:
						result = startDate.getMonthValue() <= LocalDate.now().plusMonths(1).getMonthValue()
							&& endDate.getMonthValue() >= LocalDate.now().plusMonths(1).getMonthValue();
						break;
					default:
						result = false;
        		}
        	}
        	
        	return result;
        }
        
        //Returns a LocalDate object with the date of this week's Sunday
        private LocalDate dateOfThisWeekSunday(){
        	int noOfDaysFromTodayToSunday = 7 - LocalDate.now().getDayOfWeek().getValue();
        	return LocalDate.now().plusDays(noOfDaysFromTodayToSunday);
        }

        @Override
        public String toString() {
            return "DateTime= " + dateTimeKeyWord;
        }
    }
    
    /*
     *  Compare tasks dateTime with the period specified by the keyword
     */
    private class Past10SecondsQualifier implements Qualifier {
        LocalDate completedValueDate;
        LocalTime completedValueTime;

        Past10SecondsQualifier() {}

        @Override
        public boolean run(ReadOnlyTask task) {
        	this.completedValueDate = task.getDateTime().completedValueDate;
        	this.completedValueTime = task.getDateTime().completedValueTime;
        	if(this.completedValueDate != null && this.completedValueTime != null && isCompletedInLast10Seconds()){
        		return true;
        	}else{
        		return false;
        	}
        }
        
        //Returns true if task is completed within the last 10 seconds
        private boolean isCompletedInLast10Seconds(){
    		return completedValueDate.equals(LocalDate.now())
        			&& completedValueTime.isAfter(LocalTime.now().minusSeconds(10));
        }

        @Override
        public String toString() {
            return "Completed Date and Time= " + completedValueDate.toString()
            	+ " " + completedValueTime.toString();
        }
    }
    
```
###### \java\seedu\emeraldo\model\task\DateTime.java
``` java
    public static final String MESSAGE_KEYWORD_FROM_CONSTRAINTS = "Invalid format! It should be "
            + "'from DD/MM/YYYY, HH:MM to DD/MM/YYYY, HH:MM'\n"
            + "Accepted date formats:  4/03/2016  |  4/03/16  |  4-03-16  |  4 March 16  |  4/03  |  4 Mar\n"
            + "Accepted time formats:  14:20  |  14.20  |  1420  |  2.20pm  |  2:20pm\n"
    		+ "Type 'help' to see the full list of accepted formats in the user guide";

    public static final String MESSAGE_KEYWORD_BY_CONSTRAINTS = "Invalid format! It should be "
            + "'by DD/MM/YYYY, HH:MM'\n"
            + "Accepted date formats:  4/03/2016  |  4/03/16  |  4-03-16  |  4 March 16  |  4/03  |  4 Mar\n"
            + "Accepted time formats:  14:20  |  14.20  |  1420  |  2.20pm  |  2:20pm\n"
    		+ "Type 'help' to see the full list of accepted formats in the user guide";

    public static final String MESSAGE_KEYWORD_ON_CONSTRAINTS = "Invalid format! It should be "
            + "'on DD/MM/YYYY'\n"
            + "Accepted date formats:  4/03/2016  |  4/03/16  |  4-03-16  |  4 March 16  |  4/03  |  4 Mar\n"
            + "Type 'help' to see the full list of accepted formats in the user guide";

    public static final String MESSAGE_DATETIME_CONSTRAINTS = "Command format is invalid! "
    		+ "It must be one of the following (type 'help' to see all accepted formats):\n"
            + "Keyword 'on' : on DD/MM/YYYY\n"
            + "Keyword 'by' : by DD/MM/YYYY, HH:MM\n"
            + "Keyword 'from' and 'to' : from DD/MM/YYYY, HH:MM to DD/MM/YYYY, HH:MM";

	public static final String MESSAGE_PERIOD_INVALID = "Start date/time is later or same as end date/time!";

    public final String value;
    public String context;
    public String overdueContext;
    public String eventContext;
    public String valueFormatted;
    public LocalDate valueDate;
    public LocalTime valueTime;
    public LocalDate valueDateEnd;
    public LocalTime valueTimeEnd;
    public LocalDate completedValueDate;
    public LocalTime completedValueTime;

    /**
     * Validates given date and time.
     *
     * @throws IllegalValueException if given date and time string is invalid.
     */
    public DateTime(String dateTime) throws IllegalValueException, DateTimeException{
        assert dateTime != null;
        final Matcher matcher = DateTimeParser.DATETIME_VALIDATION_REGEX.matcher(dateTime);
        
        if (!dateTime.isEmpty() && !matcher.matches()) {
            throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
        }
        
        this.completedValueDate = null;
        this.completedValueTime = null;
        
        if(dateTime.isEmpty()){
            this.valueDate = null;
            this.valueTime = null;
            this.valueDateEnd = null;
            this.valueTimeEnd = null;
            this.value = "";
            this.valueFormatted = "anytime";
            this.context = "";
            this.overdueContext = "";
            this.eventContext = "";
            
        } else {

            final String preKeyword = matcher.group("preKeyword").trim();
            
            if(preKeyword.equals("on")){
                if(!isValidFormatFor_GivenKeyword(dateTime, preKeyword))
                    throw new IllegalValueException(MESSAGE_KEYWORD_ON_CONSTRAINTS);
                
                this.valueDate = DateTimeParser.valueDateFormatter(matcher, preKeyword);
                this.context = setContext(valueDate, null);
                this.overdueContext = setOverdueContext(valueDate, null);
                this.eventContext = "";
                this.valueFormatted = DateTimeParser.valueFormatter(matcher, preKeyword) + context;
             
                this.valueTime = null;
                this.valueDateEnd = null;
                this.valueTimeEnd = null;
                
            }else if(preKeyword.equals("by")){
                if(!isValidFormatFor_GivenKeyword(dateTime, preKeyword))
                    throw new IllegalValueException(MESSAGE_KEYWORD_BY_CONSTRAINTS);
                 
                this.valueDate = DateTimeParser.valueDateFormatter(matcher, preKeyword);                
                this.valueTime = DateTimeParser.valueTimeFormatter(matcher, preKeyword); 
                this.context = setContext(valueDate, valueTime);
                this.overdueContext = setOverdueContext(valueDate, valueTime);  
                this.eventContext = "";
                this.valueFormatted = DateTimeParser.valueFormatter(matcher, preKeyword) + context;

                this.valueDateEnd = null;
                this.valueTimeEnd = null;
                
            }else if(preKeyword.equals("from")){
                if(!isValidFormatFor_GivenKeyword(dateTime, preKeyword))
                    throw new IllegalValueException(MESSAGE_KEYWORD_FROM_CONSTRAINTS);
                
                final String aftKeyword = matcher.group("aftKeyword").trim();
                
                this.valueDate = DateTimeParser.valueDateFormatter(matcher, preKeyword);                
                this.valueTime = DateTimeParser.valueTimeFormatter(matcher, preKeyword);
                this.context = setContext(valueDate, valueTime);

                this.valueDateEnd = DateTimeParser.valueDateFormatter(matcher, aftKeyword);
                this.valueTimeEnd = DateTimeParser.valueTimeFormatter(matcher, aftKeyword);
                
                if(!isStartDateTime_Before_EndDateTime(valueDate,valueTime,valueDateEnd,valueTimeEnd))
                    throw new IllegalValueException(MESSAGE_PERIOD_INVALID);
                
                this.overdueContext = setOverdueContext(valueDateEnd, valueTimeEnd); 
                this.eventContext = setEventContext(valueDate, valueTime, valueDateEnd, valueTimeEnd);
                
                this.valueFormatted = DateTimeParser.valueFormatter(matcher, preKeyword) + " "
                                    + DateTimeParser.valueFormatter(matcher, aftKeyword) + context + eventContext;                     
            }
            this.value = dateTime;
        }
    }

    public DateTime(String dateTime, String completedDateTime) throws IllegalValueException, DateTimeException{
    	this(dateTime);
    	setCompletedDateTime(completedDateTime);
    }
    
    /*
     * Converts completedDateTime from a String into LocalDate and LocalTime
     */
    private void setCompletedDateTime(String completedDateTime) throws IllegalValueException{	
    	if(completedDateTime.isEmpty()){
        	this.completedValueDate = null;
        	this.completedValueTime = null;       	
    	}else{   
    		final Matcher matcher = DateTimeParser.COMPLETED_DATE_TIME_REGEX.matcher(completedDateTime); 
    		if(!matcher.matches()){
    			throw new IllegalValueException("Error in format of completedDateTime stored in Xml");
    		}
    		this.completedValueDate = DateTimeParser.valueDateCompletedFormatter(matcher); 
    		this.completedValueTime = DateTimeParser.valueTimeCompletedFormatter(matcher);
    		this.valueFormatted = completedDateTime;
    	}
    }
    
    private boolean isValidFormatFor_GivenKeyword(String dateTime, String keyword){
        switch(keyword){
            case "on":
                return dateTime.matches(DateTimeParser.ON_KEYWORD_VALIDATION_REGEX);
            case "by": 
                return dateTime.matches(DateTimeParser.BY_KEYWORD_VALIDATION_REGEX);
            case "from":
                return dateTime.matches(DateTimeParser.FROM_KEYWORD_VALIDATION_REGEX);
            default:
                return false;
        }
    }
    
    private boolean isStartDateTime_Before_EndDateTime(LocalDate startDate, LocalTime startTime,
    		LocalDate endDate, LocalTime endTime){
    	
    	//Condition returns true if startDate > endDate
    	if(startDate.isAfter(endDate)){
    		return false;
    	//Condition returns true if startDate == endDate and startTime >= endTime
    	}else if(startDate.isEqual(endDate) && (startTime.equals(endTime) || startTime.isAfter(endTime))){ 
    		return false;
    	}else{
    		return true;
    	}
    }
    

    /*
     * Used by XmlAdaptedTask to set its String completedDateTime 
     */
    public String completedDateTime_ToString(){
    	if(completedValueDate == null)
    		return "";
    	else
    		return this.toString();
    }
    
```
###### \java\seedu\emeraldo\model\task\DateTimeParser.java
``` java
/**
 * Parses the date and time, and check for the validity of the inputs
 */
public class DateTimeParser {

    public static final String ON_KEYWORD_VALIDATION_REGEX = "on "
            + "(?<day>([12][0-9]|3[01]|0?[1-9]))"
            + "(?:( |/|-))"
            + "(?<monthInNumbers>([1][0-2]|0?[1-9])?)"
            + "(?<monthInWords>([\\p{Alpha}]{3,})?)"
            + "(?<year>(( |/|-)(([0-9][0-9])?[0-9][0-9]))?)";

    public static final String BY_KEYWORD_VALIDATION_REGEX = "by "
            + "(?<day>([12][0-9]|3[01]|0?[1-9]))"
            + "(?:( |/|-))"
            + "(?<monthInNumbers>([1][0-2]|0?[1-9])?)"
            + "(?<monthInWords>([\\p{Alpha}]{3,})?)"
            + "(?<year>(( |/|-)(([0-9][0-9])?[0-9][0-9]))?)"
            + "(\\s*,\\s*(?<hour>([1][0-9]|[2][0-3]|0?[0-9])))"
            + "(?:(:|\\.|)?)"
            + "(?<minute>([0-5][0-9])?)"
            + "(?<timePostFix>(([a]|[p])[m])?)";

    public static final String FROM_KEYWORD_VALIDATION_REGEX = "from "
            + "(?<day>([12][0-9]|3[01]|0?[1-9]))"
            + "(?:( |/|-))"
            + "(?<monthInNumbers>([1][0-2]|0?[1-9])?)"
            + "(?<monthInWords>([\\p{Alpha}]{3,})?)"
            + "(?<year>(( |/|-)(([0-9][0-9])?[0-9][0-9]))?)"
            + "(\\s*,\\s*(?<hour>([1][0-9]|[2][0-3]|0?[0-9])))"
            + "(?:(:|\\.|)?)"
            + "(?<minute>([0-5][0-9])?)"
            + "(?<timePostFix>(([a]|[p])[m])?)"
            + "( (?<aftKeyword>(to )))"
            + "(?<dayEnd>([12][0-9]|3[01]|0?[1-9]))"
            + "(?:( |/|-))"
            + "(?<monthEndInNumbers>([1][0-2]|0?[1-9])?)"
            + "(?<monthEndInWords>([\\p{Alpha}]{3,})?)"
            + "(?<yearEnd>(( |/|-)(([0-9][0-9])?[0-9][0-9]))?)"
            + "(\\s*,\\s*(?<hourEnd>([1][0-9]|[2][0-3]|0?[0-9])))"
            + "(?:(:|\\.|)?)"
            + "(?<minuteEnd>([0-5][0-9])?)"
            + "(?<timeEndPostFix>(([a]|[p])[m])?)";

    public static final Pattern DATETIME_VALIDATION_REGEX = Pattern.compile(
            "(?<preKeyword>((by )|(on )|(from )))"
            + "(?<day>([12][0-9]|3[01]|0?[1-9]))"
            + "(?:( |/|-|\\.))"
            + "(?<monthInNumbers>([1][0-2]|0?[1-9])?)"
            + "(?<monthInWords>([\\p{Alpha}]{3,})?)"
            + "(?<year>(( |/|-|\\.)(([0-9][0-9])?[0-9][0-9]))?)"
            + "(\\s*,\\s*(?<hour>([1][0-9]|[2][0-3]|0?[0-9])))?"
            + "(?:(:|\\.|)?)"
            + "(?<minute>([0-5][0-9])?)"
            + "(?<timePostFix>(([a]|[p])[m])?)"
            + "( (?<aftKeyword>(to )))?"
            + "(?<dayEnd>([12][0-9]|3[01]|0?[1-9]))?"
            + "(?:( |/|-|\\.))?"
            + "(?<monthEndInNumbers>([1][0-2]|0?[1-9])?)"
            + "(?<monthEndInWords>([\\p{Alpha}]{3,})?)"
            + "(?<yearEnd>(( |/|-)(([0-9][0-9])?[0-9][0-9]))?)"
            + "(\\s*,\\s*(?<hourEnd>([1][0-9]|[2][0-3]|0?[0-9])))?"
            + "(?:(:|\\.|)?)"
            + "(?<minuteEnd>([0-5][0-9])?)"
            + "(?<timeEndPostFix>(([a]|[p])[m])?)"
            );
    
    public static final Pattern COMPLETED_DATE_TIME_REGEX = Pattern.compile(
    		"Completed on "
    	    + "(?<day>(0?[1-9]|[12][0-9]|3[01]))"
            + "( )"
            + "(?<monthInWords>([\\p{Alpha}]{3}))"
            + "( )"
            + "(?<year>([0-9][0-9][0-9][0-9]))"
    		+ "( at )"
            + "(?<hour>([1][0-2]|0?[0-9]))"
            + "(?:(:|\\.))"
            + "(?<minute>([0-5][0-9]))"
            + "(?<timePostFix>(([a]|[p])[m]))"
    		);

	public static final String MESSAGE_INVALID_MONTH_IN_WORDS = "Invalid month! Check your spelling";

	public static final String MESSAGE_INVALID_DATE = "Invalid inputs for date! Check that the day, month and year matches\n"
			+ "Possible mistakes: having 31 as the day for a month with 30 days, e.g. 31 Nov";

	public static final String MESSAGE_TIME_FORMAT_UNINTERPRETABLE = "Invalid inputs for time!\n"
			+ " am or pm needs to be specified when only hour is entered";

	public static final String MESSAGE_INVALID_HOUR = "Invalid hour!\n"
			+ "Hour cannot be greater than 12 for time expressed in 12 hours format";
    
	/*
     * Format the date for creation of LocalDate object
     */
    public static LocalDate valueDateFormatter(Matcher matcher, String keyword)
    		throws IllegalValueException, DateTimeException{
        
        String day = matcher.group("day");
        String month = matcher.group("monthInNumbers");
        String year = matcher.group("year");
        int yearParsed;
        int monthParsed;
        int dayParsed;

        if(keyword.equals("to")){
            day = matcher.group("dayEnd");
            month = matcher.group("monthEndInNumbers");
            year = matcher.group("yearEnd");
        }

        if(month.isEmpty()){
            month = matcher.group("monthInWords").substring(0,3);
            if(keyword.equals("to"))
                month = matcher.group("monthEndInWords").substring(0,3);
            month = convertMonthFromWordsToNumbers(month);
        }

        if(year.isEmpty())
        	yearParsed = LocalDate.now().getYear();
        else{
        	year = year.substring(1);
        
        	if(Integer.parseInt(year) < 10)	//For years that are input with only the last 2 digits
        		yearParsed = Integer.parseInt(String.valueOf(LocalDate.now().getYear()).substring(0, 1) + "0" + year);
        	else if(Integer.parseInt(year) < 100)
        		yearParsed = Integer.parseInt(String.valueOf(LocalDate.now().getYear()).substring(0, 2) + year);
        	else
        		yearParsed = Integer.parseInt(year);
        }
        
        monthParsed = Integer.parseInt(month);
        dayParsed = Integer.parseInt(day);
        
        try {
        	return LocalDate.of(yearParsed, monthParsed, dayParsed);
        } catch (DateTimeException dte){
        	throw new DateTimeException(MESSAGE_INVALID_DATE);
        }
    }

    /* 
     * Format the time for creating a LocalTime object
     */
    public static LocalTime valueTimeFormatter(Matcher matcher, String keyword) throws DateTimeException{
        
        String hour = matcher.group("hour");
        String minute = matcher.group("minute");
        String timePostFix = matcher.group("timePostFix");
        
        int hourParsed;
        int minuteParsed;
        
        if(keyword.equals("to")){
            hour = matcher.group("hourEnd");
            minute = matcher.group("minuteEnd");
            timePostFix = matcher.group("timeEndPostFix");
        }
        
        if(timePostFix.isEmpty() && minute.isEmpty())
        	throw new DateTimeException(MESSAGE_TIME_FORMAT_UNINTERPRETABLE);
        
        if(minute.isEmpty())
        	minute = "00";
        
        hourParsed = Integer.parseInt(hour);
        minuteParsed = Integer.parseInt(minute);
        
        if(!timePostFix.isEmpty())
        	hourParsed = convert12HoursFormatTo24HoursFormat(hourParsed, timePostFix);
        
        	return LocalTime.of(hourParsed, minuteParsed);
    }
    
    /*
     * Formats the date and time for display
     */
    public static String valueFormatter(Matcher matcher, String keyword) throws IllegalValueException{
        
        String day = matcher.group("day");
        String month = matcher.group("monthInNumbers");
        String year = matcher.group("year");
        String hour = matcher.group("hour");
        String minute = matcher.group("minute");
        String timePostFix = matcher.group("timePostFix");

        if(keyword.equals("to")){
            day = matcher.group("dayEnd");
            month = matcher.group("monthEndInNumbers");
            year = matcher.group("yearEnd");
            hour = matcher.group("hourEnd");
            minute = matcher.group("minuteEnd");
            timePostFix = matcher.group("timeEndPostFix");
        }

        //Append the leading '0' if not present
        if(Integer.parseInt(day) < 10 && day.length() == 1)
        	day = "0" + day;
        
        //Check for month in words when month not in numbers
        if(month.isEmpty()){
            month = matcher.group("monthInWords").substring(0,3);
            if(keyword.equals("to"))
                month = matcher.group("monthEndInWords").substring(0,3);
            month = convertMonthFromWordsToNumbers(month);
        }
      
        int monthParsed = Integer.parseInt(month);

        //If no year is read in, the year will be current year
        if(year.isEmpty())
        	year = String.valueOf(LocalDate.now().getYear());
        else
        	year = year.substring(1);
        
        if (Integer.parseInt(year) < 10)	//For years that are input with only the last 2 digits
        	year = String.valueOf(LocalDate.now().getYear()).substring(0, 1) + "0" + year;
        else if (Integer.parseInt(year) < 100)
        	year = String.valueOf(LocalDate.now().getYear()).substring(0, 2) + year;
        
        //Format time in 24 hours format into 12 hours format for display
        String[] formattedInto12Hours = new String[2];
        if(timePostFix.isEmpty() && hour != null){
        	formattedInto12Hours = convert24HoursFormatTo12HoursFormat(hour);
        	hour = formattedInto12Hours[0];
        	timePostFix = formattedInto12Hours[1];
        }
        
        if(minute.isEmpty())
        	minute = "00";
        
        if(keyword.equals("on"))
            return keyword + " " + day + " " + convertMonthFromIntToWords(monthParsed) + " " + year;
        else{
            return keyword + " " + day + " " + convertMonthFromIntToWords(monthParsed) +  " " 
                    + year + ", " + hour + "." + minute + timePostFix;
        }
    }
    
    public static LocalDate valueDateCompletedFormatter(Matcher matcher) throws IllegalValueException{
        String day = matcher.group("day");
        String month = matcher.group("monthInWords");
        String year = matcher.group("year"); 
        month = convertMonthFromWordsToNumbers(month);

    	return LocalDate.of(Integer.parseInt(year), Integer.parseInt(month), Integer.parseInt(day));
    }
    
    public static LocalTime valueTimeCompletedFormatter(Matcher matcher) throws IllegalValueException{
        String hour = matcher.group("hour");
        String minute = matcher.group("minute");
        String timePostFix = matcher.group("timePostFix");
        
        int hourParsed = convert12HoursFormatTo24HoursFormat(Integer.parseInt(hour),timePostFix);
        
        return LocalTime.of(hourParsed, Integer.parseInt(minute));
    }
    
```
###### \java\seedu\emeraldo\model\task\DateTimeParser.java
``` java
    private static String convertMonthFromIntToWords(int monthParsed){
        String monthInWords;
        
        switch(monthParsed){
            case 1:
                monthInWords = "Jan";
                break;
            case 2:
                monthInWords = "Feb";
                break;
            case 3:
                monthInWords = "Mar";
                break;
            case 4:
                monthInWords = "Apr";
                break;
            case 5:
                monthInWords = "May";
                break;
            case 6:
                monthInWords = "Jun";
                break;
            case 7:
                monthInWords = "Jul";
                break;
            case 8:
                monthInWords = "Aug";
                break;
            case 9:
                monthInWords = "Sep";
                break;
            case 10:
                monthInWords = "Oct";
                break;
            case 11:
                monthInWords = "Nov";
                break;
            case 12:
                monthInWords = "Dec";
                break;             
            default: monthInWords = "Invalid month";
        }
        
        return monthInWords;
    }
    
    /**
     * Returns the month in numbers based on month in words
     * @throw IllegalValueException if month in words is not matchable
     **/
    private static String convertMonthFromWordsToNumbers(String monthInWords)  throws IllegalValueException{
        String monthInNumbers;
        switch(monthInWords.toLowerCase()){
            case "jan":
                monthInNumbers = "1";
                break;
            case "feb":
                monthInNumbers = "2";
                break;
            case "mar":
                monthInNumbers = "3";
                break;
            case "apr":
                monthInNumbers = "4";
                break;
            case "may":
                monthInNumbers = "5";
                break;
            case "jun":
                monthInNumbers = "6";
                break;
            case "jul":
                monthInNumbers = "7";
                break;
            case "aug":
                monthInNumbers = "8";
                break;
            case "sep":
                monthInNumbers = "9";
                break;
            case "oct":    
                monthInNumbers = "10";
                break;
            case "nov":
                monthInNumbers = "11";
                break;
            case "dec":
                monthInNumbers = "12";
                break;             
            default:
            	throw new IllegalValueException(MESSAGE_INVALID_MONTH_IN_WORDS);
        }
    
        return monthInNumbers;
    }
    
    /**
     * Convert hours in 12 hours format to 24 hours format
     * 
     * @param int hours
     * @param String timePostFix
     * @return int convertedHour
     */
    private static int convert12HoursFormatTo24HoursFormat(int hour, String timePostFix) throws DateTimeException{
    	
    	if(hour >= 13 || hour == 0)
    		throw new DateTimeException(MESSAGE_INVALID_HOUR);
    	
    	if(timePostFix.equalsIgnoreCase("pm") && hour != 12)
    		return hour + 12;
    	else if(timePostFix.equalsIgnoreCase("am") && hour == 12)
    		return 0;
    	else
    		return hour;
    }
    
    /**
     * Convert hours in 24 hours into 12 hours format
     * 
     * @param String hours
     * @param String timePostFix
     * @return String[] formattedInto12Hours
     */
    private static String[] convert24HoursFormatTo12HoursFormat(String hour){
    	int hourInInt = Integer.parseInt(hour);
    	String[] formattedInto12Hours = new String[2];
    	
    	if(hourInInt > 0 && hourInInt <= 11){
    		formattedInto12Hours[0] = String.valueOf(hourInInt);
    		formattedInto12Hours[1] = "am";
    	}else if(hourInInt == 0){
    		formattedInto12Hours[0] = "12";
    		formattedInto12Hours[1] = "am";
    	}else if(hourInInt == 12){
    		formattedInto12Hours[0] = String.valueOf(hourInInt);
    		formattedInto12Hours[1] = "pm";
    	}else{
    		formattedInto12Hours[0] = String.valueOf(hourInInt - 12);
    		formattedInto12Hours[1] = "pm";
    	}
    	
    	return formattedInto12Hours;
    }
   
}
```
###### \java\seedu\emeraldo\storage\XmlAdaptedTask.java
``` java
    @XmlElement (required = true)
    private String completedDateTime = "";
    
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        description = source.getDescription().fullDescription;
        dateTime = source.getDateTime().value.toString();
        completedDateTime = source.getDateTime().completedDateTime_ToString();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted Task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }

        final Description description = new Description(this.description);
        final DateTime dateTime = new DateTime(this.dateTime, this.completedDateTime);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(description, dateTime, tags);
    }
}
```
