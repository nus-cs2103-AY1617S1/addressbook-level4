# A0142325R
###### /java/seedu/toDoList/commons/exceptions/MissingRecurringDateException.java
``` java
package seedu.toDoList.commons.exceptions;


/**
 * Signals that the recurring task added does not have a recurring date.
 */
public class MissingRecurringDateException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public MissingRecurringDateException(String message) {
        super(message);
    }
}

```
###### /java/seedu/toDoList/commons/util/DateUtil.java
``` java

    /**
     * get the current date and time in LocalDate format
     * 
     * @return current LocalDate
     */
    public static LocalDate getCurrentLocalDate() {
        Calendar currentDateTime = Calendar.getInstance();
        LocalDate currentDate = LocalDate.parse(dateFormat.format(currentDateTime.getTime()).toString(),
                germanFormatter);
        return currentDate;
    }

    public static DateTimeFormatter getGermanFormatter() {
        return germanFormatter;
    }

    /**
     * format the LocalDate in "dd.MM.yyyy-XX" format
     * 
     * @param LocalDate
     *            date to be formatted
     * @return a string representing time in "dd.MM.yyyy-XX" format
     */
    public static String getFormattedDateString(LocalDate date) {
        return germanFormatter.format(date).toString();
    }

    /**
     * checks if the date string conforms to "dd.MM.yyyy" format
     * 
     * @param String
     *            date
     * @return true if the date string is "dd.MM.yyyy" format
     */
    public static boolean isDateFormat(String date) {
        return date.split(TIME_SEPERATOR).length == 1;

    }

    /**
     * checks if the date string conforms to "dd.MM.yyyy-XX" format
     * 
     * @param String
     *            date
     * @return true if the date string is "dd.MM.yyyy" format
     */
    public static boolean isDateTimeFormat(String date) {
        return date.split(TIME_SEPERATOR).length == 2;
    }

    /**
     * get ElapsedDays between current date and input date
     * 
     * @param LocalDate
     *            date
     * @return number of days
     */
    public static long getElapsedDaysFromCurrentDate(LocalDate date) {
        return ChronoUnit.DAYS.between(date, getCurrentLocalDate());
    }

    /**
     * Parse the given date if it does not adhere to the given date format
     * 
     * @param a
     *            string that represents a date ( i.e. yesterday, today, today
     *            at 4pm, etc)
     * @return a string that adhere to the given date format
     * @throws IndexOutOfBoundsException
     *             If the given date cannot be parsed
     */
    private static String parseNotFormattedDate(String date) throws IndexOutOfBoundsException {
        DateGroup dateGroup = new com.joestelmach.natty.Parser().parse(date).get(0);
        List<java.util.Date> parsedDate = dateGroup.getDates();
        if (dateGroup.isTimeInferred()) {
            return dateFormat.format(parsedDate.get(0));
        } else {
            return dateTimeFormat.format(parsedDate.get(0));
        }
    }

}
```
###### /java/seedu/toDoList/logic/commands/AddCommand.java
``` java

    /**
     * Convenience constructor using raw values.
     * 
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String deadline, Set<String> tags, String freq, int priorityLevel) throws Exception {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        if (isRecurringDeadlineTask(deadline, freq)) {
            this.toAdd = new Task(new Name(name), new Deadline(deadline), new UniqueTagList(tagSet),
                    new Recurring(freq), new Priority(priorityLevel));
        } else if (isNonRecurringDeadlineTask(deadline, freq)) {
            this.toAdd = new Task(new Name(name), new Deadline(deadline), new UniqueTagList(tagSet),
                    new Priority(priorityLevel));
        } else if (isFloatingTask(deadline, freq)) {
            this.toAdd = new Task(new Name(name), new UniqueTagList(tagSet), new Priority(priorityLevel));
        } else {
            this.toAdd = null;
            assert false;
        }
    }

    /**
     * Convenience constructor using raw values. Precondition: startDate and
     * endDate cannot be empty
     * 
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String startDate, String endDate, Set<String> tags, String freq, int priorityLevel)
            throws Exception {
        assert !startDate.isEmpty() && !endDate.isEmpty();
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        if (freq.isEmpty()) {
            this.toAdd = new Task(new Name(name), new EventDate(startDate, endDate), new UniqueTagList(tagSet),
                    new Priority(priorityLevel));
        } else {
            this.toAdd = new Task(new Name(name), new EventDate(startDate, endDate), new UniqueTagList(tagSet),
                    new Recurring(freq), new Priority(priorityLevel));
        }
    }

    public static String getSuccessMessage(Task toAdd) {
        if (toAdd.isEvent()) {
            return MESSAGE_EVENT_SUCCESS;
        } else {
            return MESSAGE_TASK_SUCCESS;
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        model.addTask(toAdd);
        String message = String.format(getSuccessMessage(toAdd), toAdd);
        model.saveState(message);

        return new CommandResult(message);

    }

    /**
     * checks if the task to be added is non-recurring deadline task
     * 
     * @param deadline
     * @param freq
     * @return
     */
    private boolean isNonRecurringDeadlineTask(String deadline, String freq) {
        return !deadline.isEmpty() && freq.isEmpty();
    }

    /**
     * checks if the task to be added is a floating task
     * 
     * @param deadline
     * @param freq
     * @return
     */
    private boolean isFloatingTask(String deadline, String freq) {
        return deadline.isEmpty() && freq.isEmpty();
    }

    /**
     * checks if the task to be added is a recurring deadline task
     * 
     * @param deadline
     * @param freq
     * @return
     */
    private boolean isRecurringDeadlineTask(String deadline, String freq) {
        return !deadline.isEmpty() && !freq.isEmpty();
    }

}
```
###### /java/seedu/toDoList/logic/commands/DeleteCommand.java
``` java

/**
 * Deletes a task identified using its last displayed index or name from the
 * toDoList.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the item identified by the index number or specific name used in the most recent listing.\n"
            + "Parameters: INDEX (must be a positive integer) or NAME\n" + "Example: " + COMMAND_WORD
            + " 1 or horror night";

    public static final String MESSAGE_DELETE_SAME_NAME = "Please select the item identified "
            + "by the index number.\n" + "Parameters: INDEX(must be a positive integer)\n" + "Example: " + COMMAND_WORD
            + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    public static final String MESSAGE_DELETE_EVENT_SUCCESS = "Deleted Event: %1$s";
    public static final String MESSAGE_DELETE_NOT_FOUND = "Item to delete is not found";
    public static final String MESSAGE_DELETE_INVALID_INDEX = "The index provided is invalid";
    // one or more keywords separated by whitespace
    private static final Pattern KEYWORDS_ARGS_FORMAT = Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)");

    public final int targetIndex;
    public final String name;

    /**
     * construct DeleteCommand by index. Precondition: targetIndex is a valid
     * non-negative integer.
     * 
     * @param targetIndex.
     */
    public DeleteCommand(int targetIndex) {
        assert targetIndex >= 0;
        this.targetIndex = targetIndex;
        this.name = null;
    }

    /**
     * construct DeleteCommand by name. Precondition: name is not null.
     * 
     * @param name.
     * @param k.
     */
    public DeleteCommand(String name) {
        assert name != null;
        this.name = name;
        this.targetIndex = Integer.MIN_VALUE;
    }

    @Override
    public CommandResult execute() {
        ReadOnlyTask taskToDelete = null;
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        if (targetIndex != Integer.MIN_VALUE) {
            if (lastShownList.size() < targetIndex) {
                indicateAttemptToExecuteIncorrectCommand();
                return new CommandResult(MESSAGE_DELETE_INVALID_INDEX);
            }
            taskToDelete = prepareDeleteTaskbyIndex(lastShownList);
            jumpToTaskBefore(targetIndex);
        } else {
            return prepareDeleteTaskWithName();
        }
        return deleteTask(taskToDelete);

    }

    /**
     * return taskToBeDeleted found by targetIndex.
     * 
     * @param lastShownList.
     * @return task to be deleted.
     */
    private ReadOnlyTask prepareDeleteTaskbyIndex(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        return lastShownList.get(targetIndex - 1);
    }

    /**
     * shown all task names with one or more occurrences of the input
     * parameters.
     * 
     * @return commandResult.
     */
    private CommandResult prepareDeleteTaskWithName() {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(name.trim());
        if ( ! matcher.matches()) {
            return new CommandResult(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        model.updateFilteredTaskList(keywordSet);
        if (model.getFilteredTaskList().size() == 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_DELETE_NOT_FOUND);
        } else {
            return new CommandResult(MESSAGE_DELETE_SAME_NAME);
        }
    }

    /**
     * delete the task specified
     * 
     * @param taskToDelete
     * @return commandResult
     */
    private CommandResult deleteTask(ReadOnlyTask taskToDelete) {
        try {
            model.deleteTask(taskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        String message = String.format(getDeleteSuccessMessage(taskToDelete), taskToDelete);
        model.saveState(message);
        return new CommandResult(message);
    }

    /**
     * return the correct delete success message depending on the whether it is
     * task or event
     * 
     * @param TaskToDelete
     * @return String
     */
    private static String getDeleteSuccessMessage(ReadOnlyTask TaskToDelete) {
        if (TaskToDelete.isEvent()) {
            return MESSAGE_DELETE_EVENT_SUCCESS;
        } else {
            return MESSAGE_DELETE_TASK_SUCCESS;
        }
    }
    
    /**
     * Jumps to the task before the deleted task.
     */
    private void jumpToTaskBefore(int index) {
        if (targetIndex >= 2) {
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 2));
        } else {
            EventsCenter.getInstance().post(new JumpToListRequestEvent(0));
        }
    }

}
```
###### /java/seedu/toDoList/logic/commands/DoneCommand.java
``` java

/**
 * Mark the specified task or event as done.
 */
public class DoneCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Mark the specified task or event as done \n "
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n" + "Example: " + COMMAND_WORD + " horror night";
    public static final String MARK_DONE_SUCCESS = "Marked as done: %1$s";
    public static final String MULTIPLE_TASK_SATISFY_KEYWORD = "Please select the item identified "
            + "by the index number.\n" + "Parameters: INDEX(must be a positive integer)\n" + "Example: " + COMMAND_WORD
            + " 1";
    public static final String TASK_NOT_FOUND = "Item not found: %1$s";

    private final Set<String> keywords;
    public final int targetIndex;
/**
 * create a DoneCommand by a set of keywords
 * Precon: keywords cannot be null
 * @param keywords
 */
    public DoneCommand(Set<String> keywords) {
        assert keywords != null;
        this.keywords = keywords;
        targetIndex = -1;
    }
    /**
     * create a DoneCommand with index
     * Precon: indexToMark should be non-negative integer
     * @param indexToMark
     */

    public DoneCommand(int indexToMark) {
        assert indexToMark >= 0;
        keywords = null;
        targetIndex = indexToMark;
    }

    @Override
    public CommandResult execute() {
        if (isMarkedByName()) {
            return markAsDoneByName();
        } else if (isMarkedByIndex()) {
            return markAsDoneByIndex();
        } else {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(DoneCommand.MESSAGE_USAGE);
        }
    }
    

    /**
     * mark a task done by name
     * 
     * @return commandResult
     */
    private CommandResult markAsDoneByName() {
        model.updateFilteredTaskList(keywords);
        if (model.getFilteredTaskList().size() == 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(TASK_NOT_FOUND);
        } else {
            return new CommandResult(MULTIPLE_TASK_SATISFY_KEYWORD);
        }
    }

    /**
     * mark a task done by index
     * 
     * @return commandResult
     */
       private CommandResult markAsDoneByIndex() {
        ReadOnlyTask taskToMark = null;
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        taskToMark = lastShownList.get(targetIndex - 1);
        jumpToTaskBefore(targetIndex);
        return markTaskDone(taskToMark);
    }

    /**
     * mark a task in the parameter input as done
     * Precon: task to be marked as done should not be null
     * @param task
     * @return
     */
    private CommandResult markTaskDone(ReadOnlyTask task) {
        assert task!=null;
        model.markTask(task);
        String message = String.format(MARK_DONE_SUCCESS, task);
        model.saveState(message);
        return new CommandResult(message);
    }

    /**
     * check if the mark command done by index request is issued
     * @return true if the DoneCommand is to mark an item as done by index
     */
    private boolean isMarkedByIndex() {
        return keywords == null && targetIndex != -1;
    }
    
    /**
     * check if the mark command done by name request is issued
     * @return true if the DoneCommand is to mark an item as done by name
     */
    private boolean isMarkedByName() {
        return keywords != null && targetIndex == -1;
    }
    
    /**
     * Jumps to the task before the task to be marked as done.
     */
    private void jumpToTaskBefore(int index) {
        if (targetIndex >= 2) {
            EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex - 2));
        } else {
            EventsCenter.getInstance().post(new JumpToListRequestEvent(0));
        }
    }
}
```
###### /java/seedu/toDoList/logic/commands/ListCommand.java
``` java

/**
 * Lists tasks or events in the task manager to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks and events" + "Parameters: [type]\n"
            + "Example: " + " list, list events, list tasks, list done, list undone";

    public static final String MESSAGE_SUCCESS = "Listed all tasks and events";
    public static final String MESSAGE_EVENT_SUCCESS = "Listed all events";
    public static final String MESSAGE_TASK_SUCCESS = "Listed all tasks";
    public static final String MESSAGE_LIST_DONE_TASK_SUCCESS = "Listed all done tasks or events";
    public static final String MESSAGE_LIST_UNDONE_TASK_SUCCESS = "Listed all undone tasks or events";

    public static final String MESSAGE_INVALID_LIST_COMMAND = "The list command argument provided is invalid."
            + MESSAGE_USAGE;

    private Types toList = null;

    public ListCommand() {
    }

    public ListCommand(String typeToList) {
        try {
            toList = Enum.valueOf(Types.class, typeToList.trim().toUpperCase());
        } catch (IllegalArgumentException e) {
            toList = Types.INVALID;
        }
    }

    @Override
    public CommandResult execute() {

        if (toList == null) {
            model.updateFilteredListToShowAll();
            return new CommandResult(MESSAGE_SUCCESS);
        }

        switch (toList) {
        case EVENTS:
            model.updateFilteredTaskListByType(toList);
            return new CommandResult(MESSAGE_EVENT_SUCCESS);
        case TASKS:
            model.updateFilteredTaskListByType(toList);
            return new CommandResult(MESSAGE_TASK_SUCCESS);
        case DONE:
            model.updateFilteredTaskListByType(toList);
            return new CommandResult(MESSAGE_LIST_DONE_TASK_SUCCESS);
        case UNDONE:
            model.updateFilteredTaskListByType(toList);
            return new CommandResult(MESSAGE_LIST_UNDONE_TASK_SUCCESS);
        default:
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_INVALID_LIST_COMMAND);
        }

    }
}
```
###### /java/seedu/toDoList/logic/commands/RefreshCommand.java
``` java

/**
 * Refresh tasks or events in the task manager to the user.
 * For outdated recurring tasks, its date and time will be shown based on its next occurrence 
 * from today's date and time
 */
public class RefreshCommand extends Command {

    public static final String COMMAND_WORD = "refresh";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Refresh tasks and events"
            + "Parameters: \n"
            + "Example: "
            + " refresh \n";

    public static final String MESSAGE_SUCCESS = "Refreshed all tasks and events";
    
    public static final String MESSAGE_INVALID_REFRESH_COMMAND = "The refresh command argument provided is invalid."
            + MESSAGE_USAGE;
    

    
    public RefreshCommand() {}
    
    @Override
    public CommandResult execute() {    
        model.refreshTask();
        return new CommandResult(MESSAGE_SUCCESS);
        
    }
}
```
###### /java/seedu/toDoList/logic/parser/ArgumentTokenizer.java
``` java
     
     public int getNumMappings(){
    	 return this.tokenizedArguments.size();
     }
     
     /**
      * check if a particular prefix is present in the map
      * @param prefix
      * @return boolean 
      */
     
     public boolean isPresent(Prefix prefix){
         return this.tokenizedArguments.containsKey(prefix);
     }
     
     /**
      * check if the parameters involved represent a floating task
      * @param start
      * @param end
      * @param deadline
      * @return boolean
      */
     
     public boolean isFloatingTask(Prefix start,Prefix end,Prefix deadline){
         return !isPresent(start)&&!isPresent(end)&&!isPresent(deadline);
     }
     
     /**
      * check if the parameters involved represent a deadline task
      * @param start
      * @param end
      * @param deadline
      * @return boolean
      */
     
     public boolean isDeadlineTask(Prefix start,Prefix end,Prefix deadline){
         return isPresent(deadline)&&!isPresent(start)&&!isPresent(end);
     }
     
     /**
      * check if the parameters involved represent an event
      * @param start
      * @param end
      * @param deadline
      * @return
      */
     
     public boolean isEvent(Prefix start,Prefix end,Prefix deadline){
         return isPresent(start)&&isPresent(end)&&!isPresent(deadline);
     }
 }
```
###### /java/seedu/toDoList/logic/parser/Parser.java
``` java
    public static final Prefix deadlinePrefix = new Prefix("d/");
    public static final Prefix tagPrefix = new Prefix("t/");
    public static final Prefix startDatePrefix = new Prefix("s/");
    public static final Prefix endDatePrefix = new Prefix("e/");
    public static final Prefix namePrefix = new Prefix("n/");
    public static final Prefix recurringPrefix = new Prefix("r/");
```
###### /java/seedu/toDoList/logic/parser/Parser.java
``` java

    /**
     * prepare to mark a task as done
     *
     * @param args
     * @return
     */
    private Command prepareMarkAsDone(String args) {
        Optional<Integer> index = parseIndex(args);
        String name = args;
        if ( ! index.isPresent()) {
            if (name == null || name.equals("")) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
            if ( ! matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
            }

            // keywords delimited by whitespace
            final String[] keywords = matcher.group("keywords").split("\\s+");
            final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
            return new DoneCommand(keywordSet);
        } else {
            return new DoneCommand(index.get());
        }
    }

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(deadlinePrefix, namePrefix, tagPrefix, startDatePrefix,
                endDatePrefix, recurringPrefix, priorityPrefix);
        argsTokenizer.tokenize(args);
        if ( ! argsTokenizer.isPresent(namePrefix)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return prepareAddTaskOrEvent(argsTokenizer);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (MissingRecurringDateException e) {
            return new IncorrectCommand(e.getMessage());
        } catch (Exception e) {
            return new IncorrectCommand(MESSAGE_INVALID_DATE);
        }
    }

    /**
     * prepare to add task or event based on different input parameters
     * 
     * @param argsTokenizer
     *            used to identify types of parameters present
     * @return AddCommmand or IncorrectCommand
     * @throws Exception
     */
    private Command prepareAddTaskOrEvent(ArgumentTokenizer argsTokenizer) throws Exception {
        if (argsTokenizer.isFloatingTask(startDatePrefix, endDatePrefix, deadlinePrefix)) {
            return prepareAddFloatingTaskCommand(argsTokenizer);
        } else if (argsTokenizer.isDeadlineTask(startDatePrefix, endDatePrefix, deadlinePrefix)) {
            return prepareAddDeadlineTaskCommand(argsTokenizer);
        } else if (argsTokenizer.isEvent(startDatePrefix, endDatePrefix, deadlinePrefix)) {
            return prepareAddEventCommand(argsTokenizer);
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

    /**
     * prepare to add a deadline task
     *
     * @param argsTokenizer
     * @return the addCommand
     * @throws Exception
     */
    private Command prepareAddDeadlineTaskCommand(ArgumentTokenizer argsTokenizer) throws Exception {
        if (argsTokenizer.isPresent(recurringPrefix)) {
            return prepareAddRecurringDeadlineTask(argsTokenizer);
        } else {
            return prepareAddNonRecurringDeadlineTask(argsTokenizer);
        }
    }

    /**
     * prepare to add a floating task
     *
     * @param argsTokenizer
     * @return the addCommand
     * @throws Exception
     */
    private Command prepareAddFloatingTaskCommand(ArgumentTokenizer argsTokenizer) throws Exception {
        if (argsTokenizer.isPresent(recurringPrefix)) {
            throw new MissingRecurringDateException(Recurring.RECURRING_MISSING_DATE);
        }
        if ( ! argsTokenizer.isPresent(priorityPrefix)) {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(), "",
                    toSet(argsTokenizer.getAllValues(tagPrefix)), "", 0);
        } else {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(), "",
                    toSet(argsTokenizer.getAllValues(tagPrefix)), "",
                    Integer.parseInt(argsTokenizer.getValue(priorityPrefix).get()));
        }
    }

    /**
     * prepare to add an event
     *
     * @param argsTokenizer
     * @return the addCommand
     * @throws Exception
     */
    private Command prepareAddEventCommand(ArgumentTokenizer argsTokenizer) throws Exception {
        if ( ! argsTokenizer.isPresent(recurringPrefix)) {
            return prepareAddRecurringEvent(argsTokenizer);
        } else {
            return prepareAddNonRecurringEvent(argsTokenizer);
        }
    }

    /**
     * prepare to add a recurring deadline task
     *
     * @param argsTokenizer
     * @return the addCommand
     * @throws Exception
     */
    private Command prepareAddRecurringDeadlineTask(ArgumentTokenizer argsTokenizer) throws Exception {
        if ( ! argsTokenizer.isPresent(priorityPrefix)) {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(deadlinePrefix).get(), toSet(argsTokenizer.getAllValues(tagPrefix)),
                    argsTokenizer.getValue(recurringPrefix).get(), 0);
        } else {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(deadlinePrefix).get(), toSet(argsTokenizer.getAllValues(tagPrefix)),
                    argsTokenizer.getValue(recurringPrefix).get(),
                    Integer.parseInt(argsTokenizer.getValue(priorityPrefix).get()));
        }
    }

    /**
     * prepare to add a recurring event
     *
     * @param argsTokenizer
     * @return the addCommand
     * @throws Exception
     */
    private Command prepareAddRecurringEvent(ArgumentTokenizer argsTokenizer) throws Exception {
        if ( ! argsTokenizer.isPresent(priorityPrefix)) {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(startDatePrefix).get(), argsTokenizer.getValue(endDatePrefix).get(),
                    toSet(argsTokenizer.getAllValues(tagPrefix)), "", 0);
        } else {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(startDatePrefix).get(), argsTokenizer.getValue(endDatePrefix).get(),
                    toSet(argsTokenizer.getAllValues(tagPrefix)), "",
                    Integer.parseInt(argsTokenizer.getValue(priorityPrefix).get()));
        }
    }

    /**
     * prepare to add a non recurring deadline task
     *
     * @param argsTokenizer
     * @return the addCommand
     * @throws Exception
     */
    private Command prepareAddNonRecurringDeadlineTask(ArgumentTokenizer argsTokenizer) throws Exception {
        if ( ! argsTokenizer.getTokenizedArguments().containsKey(priorityPrefix)) {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(deadlinePrefix).get(), toSet(argsTokenizer.getAllValues(tagPrefix)), "", 0);
        } else {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(deadlinePrefix).get(), toSet(argsTokenizer.getAllValues(tagPrefix)), "",
                    Integer.parseInt(argsTokenizer.getValue(priorityPrefix).get()));
        }
    }

    /**
     * prepare to add a non-recurring event
     *
     * @param argsTokenizer
     * @return the addCommand
     * @throws Exception
     */
    private Command prepareAddNonRecurringEvent(ArgumentTokenizer argsTokenizer) throws Exception {
        if ( ! argsTokenizer.isPresent(priorityPrefix)) {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(startDatePrefix).get(), argsTokenizer.getValue(endDatePrefix).get(),
                    toSet(argsTokenizer.getAllValues(tagPrefix)), argsTokenizer.getValue(recurringPrefix).get(), 0);
        } else {
            return new AddCommand(argsTokenizer.getValue(namePrefix).get(),
                    argsTokenizer.getValue(startDatePrefix).get(), argsTokenizer.getValue(endDatePrefix).get(),
                    toSet(argsTokenizer.getAllValues(tagPrefix)), argsTokenizer.getValue(recurringPrefix).get(),
                    Integer.parseInt(argsTokenizer.getValue(priorityPrefix).get()));
        }
    }

    private Set<String> toSet(Optional<List<String>> tagsOptional) {
        List<String> tags = tagsOptional.orElse(Collections.emptyList());
        return new HashSet<>(tags);
    }

    /**
     * Parses arguments in the context of the deleteCommand.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        Optional<Integer> index = parseIndex(args);
        String name = args;
        if ( ! index.isPresent()) {
            if (name == null || name.isEmpty()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            return new DeleteCommand(args);
        } else {
            return new DeleteCommand(index.get());
        }

    }
```
###### /java/seedu/toDoList/logic/parser/Parser.java
``` java

    /**
     * prepare to create list command
     *
     * @param args
     * @return
     */

    private Command prepareList(String args) {
        if (args.isEmpty()) {
            return new ListCommand();
        } else {
            return new ListCommand(args);
        }
    }

```
###### /java/seedu/toDoList/model/Model.java
``` java
    /** Updates the task manager to show all up-to-date tasks. */
    void refreshTask();
}
```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    @Override
    public synchronized void refreshTask(){
        taskManager.refreshTask();
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void markTask(ReadOnlyTask task) {
        taskManager.markTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListByType(Types type) {
        updateFilteredTaskList(getPredicateForType(type));
        Set<Types> types = new HashSet<>();
        types.add(type);
        raise(new UpdateFilterPanelEvent(types, new HashMap<Types, String>(), new HashSet<String>()));
    }

    private Expression getPredicateForType(Types type) {
        switch (type) {
        case EVENTS:
            return new PredicateExpression(new EventQualifier());
        case TASKS:
            return new PredicateExpression(new TaskQualifier());
        case DONE:
        case UNDONE:
            return new PredicateExpression(new DoneQualifier(type));
        default:
            assert false;
            return null;
        }
    }

```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    private class EventQualifier implements Qualifier {
        EventQualifier() {}

        @Override
        public boolean run(ReadOnlyTask task) {

            return task.isEvent();
        }

        @Override
        public String toString() {
            return "name";
        }

    }

    private class TaskQualifier implements Qualifier {
        TaskQualifier() {}

        @Override
        public boolean run(ReadOnlyTask task) {
            return !task.isEvent();
        }

        @Override
        public String toString() {
            return "name";
        }
    }

    private class DoneQualifier implements Qualifier {
        private boolean isDone;

        DoneQualifier(Types isDone) {
            this.isDone = isDone.equals(Types.DONE);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.isDone() == isDone;
        }

        @Override
        public String toString() {
            return "done=" + isDone;
        }
    }

```
###### /java/seedu/toDoList/model/ModelManager.java
``` java
    private class RecurringQualifier implements Qualifier {
        private String recurring;

        RecurringQualifier(String recurring) {
            this.recurring = recurring;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (recurring.isEmpty()) {
                return task.getRecurring() == null;
            } else {
                return task.getRecurring() != null && this.recurring.equals(task.getRecurring().recurringFrequency);
            }
        }

        @Override
        public String toString() {
            return "recurring=" + recurring;
        }
    }

```
###### /java/seedu/toDoList/model/task/Deadline.java
``` java

    /**
     * Override the updateRecurringDate method in Date interface. Change the
     * current date to "numOfDays" after the current value. Update this.date
     * value
     */
    @Override
    public void updateRecurringDate(long numOfDays) {
        LocalDate deadlineDate = getLocalDate().get(0);
        String upToDateDeadline = DateUtil.getFormattedDateString(deadlineDate.plusDays(numOfDays));
        updateDate(upToDateDeadline);

    }

    /**
     * Override getLocalDate in interface Date. Return date in LocalDate type as
     * an arrayList.
     */
    @Override
    public ArrayList<LocalDate> getLocalDate() {
        assert date != null;
        ArrayList<LocalDate> dateArray = new ArrayList<LocalDate>();
        dateArray.add(LocalDate.parse(date.substring(0, 10), DateUtil.getGermanFormatter()));
        return dateArray;
    }

    /**
     * Override the updateDate in interface Date. Update the date attribute of
     * this Deadline object.
     */
    @Override
    public void updateDate(String... deadline) {
        assert deadline.length == 1;
        assert getUpdateDeadline(deadline) != null;
        this.date = getUpdateDeadline(deadline);
    }

    /**
     * get updated deadline string with time value attached from the input
     * string
     * 
     * @param deadline
     *            with the up-to-date date value excluding time value
     * @return updated complete deadline string with time value attached if
     *         possible
     */
    private String getUpdateDeadline(String... deadline) {
        if (DateUtil.isDateFormat(date)) {
            return deadline[0];
        } else if (DateUtil.isDateTimeFormat(date)) {
            return deadline[0] + date.substring(10);
        } else {
            assert false;
            return null;
        }
    }

```
###### /java/seedu/toDoList/model/task/EventDate.java
``` java

    /**
     * Override the updateRecurringDate in Date interface. Change current date
     * value to "numOfDays" after. Update this.date value
     */
    @Override
    public void updateRecurringDate(long numOfDays) {
        LocalDate startDate = getLocalDate().get(0);
        LocalDate endDate = getLocalDate().get(1);
        String startDateToUpdate = DateUtil.getFormattedDateString(startDate.plusDays(numOfDays));
        String endDateToUpdate = DateUtil.getFormattedDateString(endDate.plusDays(numOfDays));
        updateDate(startDateToUpdate, endDateToUpdate);

    }

    /**
     * Override getLocalDate method in Date interface. return startDate and
     * endDate value in an arrayList of LocalDate
     */
    @Override
    public ArrayList<LocalDate> getLocalDate() {
        assert startDate != null && endDate != null;
        ArrayList<LocalDate> dateArray = new ArrayList<LocalDate>();
        dateArray.add(LocalDate.parse(startDate.substring(0, 10), DateUtil.getGermanFormatter()));
        dateArray.add(LocalDate.parse(endDate.substring(0, 10), DateUtil.getGermanFormatter()));
        return dateArray;
    }

    /**
     * Override the updateDate in Date interface. Update startDate, endDate, and
     * date attribute to the updated version
     */
    @Override
    public void updateDate(String... dateString) {
        assert dateString.length == 2;
        this.startDate = getUpdatedString(startDate, dateString[0]);
        this.endDate = getUpdatedString(endDate, dateString[1]);
        this.date = this.startDate + " to " + this.endDate;

    }

    /**
     * Get updated startTime and endTime string with time value attached if
     * necessary.
     * 
     * @param originalDate
     *            (i.e. startDate, or endDate)
     * @param up-to-date
     *            date value without time value attached
     * @return a string with update-to-date value with time value attached is
     *         necessary.
     */
    private String getUpdatedString(String originalDate, String date) {
        if (DateUtil.isDateFormat(originalDate)) {
            return date;
        } else if (DateUtil.isDateTimeFormat(originalDate)) {
            return date + originalDate.substring(10);
        } else {
            assert false;
            return null;
        }
    }

}
```
###### /java/seedu/toDoList/model/task/Recurring.java
``` java
/**
 * Represents a recurring task in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Recurring {

    public static final String MESSAGE_RECURRING_CONSTRAINTS = "Recurring frequency should be 'daily/weekly/monthly/yearly' ";
    public static final String[] FREQUENCY_VALUES = new String[] {"daily", "weekly", "monthly" };
    public static final Set<String> FREQUENCY_SET = new HashSet<String>(Arrays.asList(FREQUENCY_VALUES));
    public static final String RECURRING_MISSING_DATE = "Recurring task must have a deadline";
    
    public String recurringFrequency;

    /**
     * Validates given frequency.
     *
     * @throws IllegalValueException if given frequency string is invalid.
     */
    public Recurring(String freq) throws IllegalValueException {
        assert freq != null;
        recurringFrequency = freq.trim();
        if (!isValidFrequency(recurringFrequency)) {
            throw new IllegalValueException(MESSAGE_RECURRING_CONSTRAINTS);
        }
        this.recurringFrequency = freq;
    }

    /**
     * Returns true if a given string is a valid task recurring frequency.
     */
    public static boolean isValidFrequency(String test) {
        return FREQUENCY_SET.contains(test);
    }


    @Override
    public String toString() {
        return recurringFrequency;
    }
    
    public String getFrequency(){
        return recurringFrequency;
    }
    

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Recurring // instanceof handles nulls
                && this.recurringFrequency.equals(((Recurring) other).recurringFrequency)); // state check
    }

    @Override
    public int hashCode() {
        return recurringFrequency.hashCode();
    }

}
```
###### /java/seedu/toDoList/model/task/Task.java
``` java

    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDate(), source.getTags(), source.isDone(), source.isRecurring(),
                source.getPriorityLevel());
        if (source.isRecurring()) {
            this.recurring = source.getRecurring();
            recurringString.set(recurring.recurringFrequency);
        }
    }

    /**
     * update the recurring task to its next recurring date
     */
    public void updateRecurringTask() {

        LocalDate beginDate = date.getLocalDate().get(0);

        long elapsedDays = DateUtil.getElapsedDaysFromCurrentDate(beginDate);

        if (elapsedDays < RECURRING_UPDATE_THRESHOLD) {
            return;
        }
        switch (recurring.recurringFrequency) {
        case RECURDAILY:
            updateRecurringTask(elapsedDays);
            break;
        case RECURWEEKLY:
            long numWeek = ( elapsedDays - 1 ) / DAYS_OF_WEEK + 1;
            updateRecurringTask(numWeek * DAYS_OF_WEEK);
            break;
        case RECURMONTHLY:
            long numMonth = ( elapsedDays - 1 ) / DAYS_OF_MONTH + 1;
            updateRecurringTask(numMonth * DAYS_OF_MONTH);
            break;
        default:
            assert false;
            break;
        }
    }

    /**
     * update recurring task based on the number of days to update
     *
     * @param daysToUpdate,
     *            must be positive integer greater than the update threshold
     */
    private void updateRecurringTask(long daysToUpdate) {
        assert daysToUpdate >= RECURRING_UPDATE_THRESHOLD;
        date.updateRecurringDate(daysToUpdate);
        dateString.set(date.getValue());

    }

```
###### /java/seedu/toDoList/model/task/Task.java
``` java
    @Override
    public Recurring getRecurring() {
        // assert recurring!=null;
        return this.recurring;
    }

```
###### /java/seedu/toDoList/model/task/Task.java
``` java
    @Override
    public boolean isDone() {
        return isDone;
    }

    @Override
    public boolean isRecurring() {
        return isRecurring;
    }
```
###### /java/seedu/toDoList/model/task/Task.java
``` java
    @Override
    public void markAsDone() {
        isDone = true;
        done.set(true);
    }

```
###### /java/seedu/toDoList/model/TaskManager.java
``` java
    /**
     * Refreshes dates of tasks.
     */
    public void refreshTask(){
        for(Task e:tasks){
            if(e.isRecurring()){
            e.updateRecurringTask();
            }
        }
    }

```
