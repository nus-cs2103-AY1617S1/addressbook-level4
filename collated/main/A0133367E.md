# A0133367E
###### /java/seedu/agendum/commons/events/logic/AliasTableChangedEvent.java
``` java
package seedu.agendum.commons.events.logic;

import java.util.Hashtable;

import seedu.agendum.commons.events.BaseEvent;

/**
 * Indicate the alias table in {@link seedu.agendum.logic.commands.CommandLibrary} has changed
 */
public class AliasTableChangedEvent extends BaseEvent {

    public final Hashtable<String, String> aliasTable;
    private String message_;

    public AliasTableChangedEvent(String message, Hashtable<String, String> aliasTable) {
        this.aliasTable = aliasTable;
        this.message_ = message;
    }

    @Override
    public String toString() {
        return message_;
    }
}
```
###### /java/seedu/agendum/logic/commands/AliasCommand.java
``` java
/**
 * Creates an alias for a reserved command keyword
 */
public class AliasCommand extends Command {

    public static final String COMMAND_WORD = "alias";
    public static final String COMMAND_FORMAT = "alias <original command> <your command>";
    public static final String COMMAND_DESCRIPTION = "create your shorthand command";
    public static final String MESSAGE_SUCCESS = "New alias <%1$s> created for <%2$s>";
    public static final String MESSAGE_FAILURE_ALIAS_IN_USE = "<%1$s> is already an alias for <%2$s>";
    public static final String MESSAGE_FAILURE_RESERVED_COMMAND_WORD = "<%1$s> is a reserved command word";
    public static final String MESSAGE_FAILURE_NON_ORIGINAL_COMMAND =
            "We don't recognise <%1$s> as an Agendum Command";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " mark m";

    private String aliasValue;
    private String aliasKey;
    private CommandLibrary commandLibrary;
    
    public AliasCommand(String aliasKey, String aliasValue) {
        this.aliasKey = aliasKey;
        this.aliasValue = aliasValue;
    }

    public void setData(Model model, CommandLibrary commandLibrary) {
        this.model = model;
        this.commandLibrary = commandLibrary;
    }

    @Override
    public CommandResult execute() {
        if (commandLibrary.isReservedCommandKeyword(aliasKey)) {
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_RESERVED_COMMAND_WORD, aliasKey));
        }

        if (commandLibrary.isExistingAliasKey(aliasKey)) {
            String associatedValue = commandLibrary.getAliasedValue(aliasKey);
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_ALIAS_IN_USE, aliasKey, associatedValue));
        }

        if (!commandLibrary.isReservedCommandKeyword(aliasValue)) {
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_NON_ORIGINAL_COMMAND, aliasValue));
        }
        
        commandLibrary.addNewAlias(aliasKey, aliasValue);

        return new CommandResult(String.format(MESSAGE_SUCCESS, aliasKey, aliasValue));
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/commands/CommandLibrary.java
``` java
    /**
     * Replace the current commandLibrary's aliasTable with the new aliasTable provided
     */
    public void loadAliasTable(Hashtable<String, String> aliasTable) {
        this.aliasTable = aliasTable;
    }

    /**
     * Returns true if key is already an alias for a command keyword, false otherwise.
     */
    public boolean isExistingAliasKey(String key) {
        assert key != null;
        assert key.equals(key.toLowerCase());

        return aliasTable.containsKey(key);
    }

    /**
     * Returns the reserved command keyword that is aliased by key
     * 
     * @param key    An existing user-defined alias for a reserved command keyword
     * @return       The associated reserved command keyword
     */
    public String getAliasedValue(String key) {
        assert isExistingAliasKey(key);

        return aliasTable.get(key);
    }

    /**
     * Returns true if value is a reserved command keyword, false otherwise
     */
    public boolean isReservedCommandKeyword(String value) {
        assert value != null;
        assert value.equals(value.toLowerCase());

        return allCommandWords.contains(value);
    }

    /**
     * Pre-condition: key is a new unique alias and not a command keyword;
     * value is a reserved command keyword.
     * Saves the new alias relationship between key and value.
     * 
     * @param key       A valid and unique user-defined alias for a reserved command word
     * @param value     The target reserved command word
     */
    public void addNewAlias(String key, String value) {
        assert !isExistingAliasKey(key);
        assert !isReservedCommandKeyword(key);
        assert isReservedCommandKeyword(value);

        aliasTable.put(key, value);

        indicateAliasAdded(key, value);
    }

    /**
     * Destroy the alias relationship (key can no longer be used in place of command word)
     * 
     * @param key    An existing user-defined alias for a reserved command word
     */
    public void removeExistingAlias(String key) {
        assert isExistingAliasKey(key);

        String value = aliasTable.remove(key);

        indicateAliasRemoved(key, value);
    }

    /**
     * Raises an event to indicate that an alias has been added to aliasTable in the command library
     * 
     * @param key    The new user-defined alias key
     * @param value  The target reserved command word
     */
    private void indicateAliasAdded(String key, String value) {
        String message = "Added alias " + key + " for " + value;
        EventsCenter eventCenter = EventsCenter.getInstance();
        eventCenter.post(new AliasTableChangedEvent(message, aliasTable));
    }

    /**
     * Raises an event to indicate that an alias has been removed from aliasTable in the command library
     * 
     * @param key       The alias key to be removed
     * @param value     The associated reserved command word
     */
    private void indicateAliasRemoved(String key, String value) {
        String message = "Removed alias " + key + " for " + value;
        EventsCenter eventCenter = EventsCenter.getInstance();
        eventCenter.post(new AliasTableChangedEvent(message, aliasTable));
    }

}
```
###### /java/seedu/agendum/logic/commands/CommandResult.java
``` java
    /**
     * Pre-condition: tasks and originalIndices must be of the same size.
     * Returns a string containing each task in tasks
     * with the corresponding number in originalIndices prepended
     * 
     * @param tasks             List of tasks where each task is be prepended by an index
     * @param originalIndices   List of corresponding index for each task
     * @return                  String containing all tasks labeled with their corresponding index
     */
    public static String tasksToString(List<ReadOnlyTask> tasks, List<Integer> originalIndices) {
        final StringBuilder builder = new StringBuilder();
        builder.append("\n");
        for (int i = 0; i < tasks.size(); i++) {
            builder.append("#").append(originalIndices.get(i)).append(": ");
            builder.append(tasks.get(i).getAsText());
        }
        return builder.toString();
    }

}
```
###### /java/seedu/agendum/logic/commands/DeleteCommand.java
``` java
/**
 * Deletes task(s) identified using their last displayed indices from the task listing.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";
    public static final String COMMAND_FORMAT = "delete <id> <more ids>";
    public static final String COMMAND_DESCRIPTION = "delete task(s) from Agendum";
    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task(s): %1$s";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "(The id must be a positive number)\n"
            + "Example: " + COMMAND_WORD + " 7 10-11";

    private ArrayList<Integer> targetIndexes;
    private ArrayList<ReadOnlyTask> tasksToDelete;


    public DeleteCommand(Set<Integer> targetIndexes) {
        this.targetIndexes = new ArrayList<Integer>(targetIndexes);
        Collections.sort(this.targetIndexes);
        this.tasksToDelete = new ArrayList<ReadOnlyTask>();
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (isAnyIndexInvalid(lastShownList)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
 
        for (int targetIndex: targetIndexes) {
            ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
            tasksToDelete.add(taskToDelete);
        }

        try {
            model.deleteTasks(tasksToDelete);
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_MISSING_TASK);
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS,
                CommandResult.tasksToString(tasksToDelete, targetIndexes)));
    }

    private boolean isAnyIndexInvalid(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        return targetIndexes.stream().anyMatch(index -> index > lastShownList.size());
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }

}
```
###### /java/seedu/agendum/logic/commands/MarkCommand.java
``` java
/**
 * Mark task(s) identified using their last displayed indices in the task listing.
 */
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";    
    public static final String COMMAND_FORMAT = "mark <id> <more ids>";
    public static final String COMMAND_DESCRIPTION = "mark task(s) as completed";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task(s)!";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "(The id must be a positive number)\n"
            + "Example: " + COMMAND_WORD + " 1 3 5-6";

    private ArrayList<Integer> targetIndexes;
    private ArrayList<ReadOnlyTask> tasksToMark;


    public MarkCommand(Set<Integer> targetIndexes) {
        this.targetIndexes = new ArrayList<Integer>(targetIndexes);
        Collections.sort(this.targetIndexes);
        this.tasksToMark = new ArrayList<ReadOnlyTask>();
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (isAnyIndexInvalid(lastShownList)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
 
        for (int targetIndex: targetIndexes) {
            ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
            tasksToMark.add(taskToMark);
        }
        
        try {
            model.markTasks(tasksToMark);
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_MISSING_TASK);
        } catch (DuplicateTaskException pnfe) {
            model.resetDataToLastSavedList();
            return new CommandResult(Messages.MESSAGE_DUPLICATE_TASK);
        }

        return new CommandResult(MESSAGE_MARK_TASK_SUCCESS);
    }

    private boolean isAnyIndexInvalid(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        return targetIndexes.stream().anyMatch(index -> index > lastShownList.size());
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/commands/RenameCommand.java
``` java
/**
 * Renames the target task in the task listing.
 */
public class RenameCommand extends Command {

    public static final String COMMAND_WORD = "rename";
    public static final String COMMAND_FORMAT = "rename <id> <new name>";
    public static final String COMMAND_DESCRIPTION = "update the name of a task";
    public static final String MESSAGE_SUCCESS = "Task renamed: %1$s";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " 2 Watch Star Trek";

    private int targetIndex;
    private Name newTaskName;

    /**
     * Constructor for rename command
     * @throws IllegalValueException if the name is invalid
     */
    public RenameCommand(int targetIndex, String name) throws IllegalValueException {
        this.targetIndex = targetIndex;
        this.newTaskName = new Name(name);
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToRename = lastShownList.get(targetIndex - 1);

        try {
            Task renamedTask = new Task(taskToRename);
            renamedTask.setName(newTaskName);
            model.updateTask(taskToRename, renamedTask);
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(Messages.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            return new CommandResult(Messages.MESSAGE_MISSING_TASK);
        }
 
        return new CommandResult(String.format(MESSAGE_SUCCESS, newTaskName));

    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }

}
```
###### /java/seedu/agendum/logic/commands/UnaliasCommand.java
``` java
/**
 * Create an alias for a reserved command keyword
 */
public class UnaliasCommand extends Command {

    public static final String COMMAND_WORD = "unalias";
    public static final String COMMAND_FORMAT = "unalias <your command>";
    public static final String COMMAND_DESCRIPTION = "remove a shorthand command";
 
    public static final String MESSAGE_SUCCESS = "Removed alias <%1$s>";
    public static final String MESSAGE_FAILURE_NO_ALIAS_KEY = "The alias <%1$s> does not exist";
    public static final String MESSAGE_FAILURE_RESERVED_COMMAND_WORD = "<%1$s> is a reserved command word";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "Example: " + COMMAND_WORD + " m\n"
            + "(if m is aliased to mark)";

    private String aliasKey;
    private CommandLibrary commandLibrary;
    
    public UnaliasCommand(String aliasKey) {
        this.aliasKey = aliasKey;
    }

    public void setData(Model model, CommandLibrary commandLibrary) {
        this.model = model;
        this.commandLibrary = commandLibrary;
    }

    @Override
    public CommandResult execute() {
        if (commandLibrary.isReservedCommandKeyword(aliasKey)) {
            return new CommandResult(String.format(MESSAGE_FAILURE_RESERVED_COMMAND_WORD, aliasKey));
        }

        if (!commandLibrary.isExistingAliasKey(aliasKey)) {
            return new CommandResult(String.format(MESSAGE_FAILURE_NO_ALIAS_KEY, aliasKey));
        }
        
        commandLibrary.removeExistingAlias(aliasKey);
        return new CommandResult(String.format(MESSAGE_SUCCESS, aliasKey));
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/commands/UndoCommand.java
``` java
/**
 * Undo the last change to the to-do list
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String COMMAND_FORMAT = "undo";
    public static final String COMMAND_DESCRIPTION = "undo the last change to your to-do list";

    public static final String MESSAGE_SUCCESS = "Previous change undone!";
    public static final String MESSAGE_FAILURE = "Nothing to undo!";
	
    @Override
    public CommandResult execute() {
        assert model != null;
        
        try {
            model.restorePreviousToDoList();
        } catch (NoPreviousListFoundException nplfe) {
            return new CommandResult(MESSAGE_FAILURE);
        }

        return new CommandResult(MESSAGE_SUCCESS);
    }

    public static String getName() {
        return COMMAND_WORD;
    }
	
    public static String getFormat() {
        return COMMAND_FORMAT;
    }
	
    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/commands/UnmarkCommand.java
``` java
/**
 * Unmark task(s) identified using their last displayed indices in the task listing.
 */
public class UnmarkCommand extends Command {

    public static final String COMMAND_WORD = "unmark";    
    public static final String COMMAND_FORMAT = "unmark <id> <more ids>";
    public static final String COMMAND_DESCRIPTION = "unmark task(s) from completed";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task(s)!";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " - "
            + COMMAND_DESCRIPTION + "\n"
            + COMMAND_FORMAT + "\n"
            + "(The id must be a positive number)\n"
            + "Example: " + COMMAND_WORD + " 11-13 15";

    private ArrayList<Integer> targetIndexes;
    private ArrayList<ReadOnlyTask> tasksToUnmark;

```
###### /java/seedu/agendum/logic/commands/UnmarkCommand.java
``` java
    public UnmarkCommand(Set<Integer> targetIndexes) {
        this.targetIndexes = new ArrayList<>(targetIndexes);
        Collections.sort(this.targetIndexes);
        this.tasksToUnmark = new ArrayList<>();
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (isAnyIndexInvalid(lastShownList)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
 
        for (int targetIndex: targetIndexes) {
            ReadOnlyTask taskToUnmark = lastShownList.get(targetIndex - 1);
            tasksToUnmark.add(taskToUnmark);
        }
        
        try {
            model.unmarkTasks(tasksToUnmark);
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_MISSING_TASK);
        } catch (DuplicateTaskException pnfe) {
            model.resetDataToLastSavedList();
            return new CommandResult(Messages.MESSAGE_DUPLICATE_TASK);
        }

        return new CommandResult(MESSAGE_UNMARK_TASK_SUCCESS);
    }

    private boolean isAnyIndexInvalid(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        return targetIndexes.stream().anyMatch(index -> index > lastShownList.size());
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getFormat() {
        return COMMAND_FORMAT;
    }

    public static String getDescription() {
        return COMMAND_DESCRIPTION;
    }
}
```
###### /java/seedu/agendum/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the delete task(s) command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        Set<Integer> taskIds = parseIndexes(args);
        if (taskIds.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(taskIds);
    }

    /**
     * Parses arguments in the context of the mark task(s) command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareMark(String args) {
        Set<Integer> taskIds = parseIndexes(args);
        if (taskIds.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }

        return new MarkCommand(taskIds);
    }
 
    /**
     * Parses arguments in the context of the unmark task(s) command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUnmark(String args) {
        Set<Integer> taskIds = parseIndexes(args);
        if (taskIds.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }

        return new UnmarkCommand(taskIds);
    }

    /**
     * Parses arguments in the context of the rename task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareRename(String args) {
        final Matcher matcher = RENAME_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RenameCommand.MESSAGE_USAGE));
        }

        final String givenName = matcher.group("name").trim();
        final String givenIndex = matcher.group("targetIndex");
        Optional<Integer> index = parseIndex(givenIndex);

        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RenameCommand.MESSAGE_USAGE));
        }

        try {
            return new RenameCommand(index.get(), givenName);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the alias command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAlias(String args) {
        final Matcher matcher = ALIAS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, AliasCommand.MESSAGE_USAGE));
        }

        String aliasKey = matcher.group("shorthand").toLowerCase();
        String aliasValue = matcher.group("commandword").toLowerCase();

        return new AliasCommand(aliasKey, aliasValue);
    }

    /**
     * Parses arguments in the context of the unalias command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUnalias(String args) {
        final Matcher matcher = UNALIAS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnaliasCommand.MESSAGE_USAGE));
        }

        String aliasKey = matcher.group("shorthand").toLowerCase();

        return new UnaliasCommand(aliasKey);
    }

```
###### /java/seedu/agendum/logic/parser/Parser.java
``` java
    /**
     * Returns the specified indices in the {@code command} if positive unsigned integer(s) are given.
     * Returns an empty set otherwise.
     */
    private Set<Integer> parseIndexes(String args) {
        final Matcher matcher = TASK_INDEXES_ARGS_FORMAT.matcher(args.trim());
        Set<Integer> emptySet = new HashSet<Integer>();
        Set<Integer> taskIds = new HashSet<Integer>();

        if (!matcher.matches()) {
            return emptySet;
        }

        String replacedArgs = args.replaceAll("[ ]+", ",").replaceAll(",+", ",");

        String[] taskIdStrings = replacedArgs.split(",");
        for (String taskIdString : taskIdStrings) {
            if (taskIdString.matches("\\d+")) {
                taskIds.add(Integer.parseInt(taskIdString));
            } else if (taskIdString.matches("\\d+-\\d+")) {
                String[] startAndEndIndexes = taskIdString.split("-");
                int startIndex = Integer.parseInt(startAndEndIndexes[0]);
                int endIndex = Integer.parseInt(startAndEndIndexes[1]);
                taskIds.addAll(IntStream.rangeClosed(startIndex, endIndex)
                       .boxed().collect(Collectors.toList()));
            }
        }

        if (taskIds.remove(0)) {
            return emptySet;
        }

        return taskIds;
    }

```
###### /java/seedu/agendum/model/ModelManager.java
``` java
    /**
     * Signals that an operation to remove a list from the stack of previous lists would fail
     * as the stack must contain at least one list.
     */
    public static class NoPreviousListFoundException extends Exception {}
```
###### /java/seedu/agendum/model/ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyToDoList newData) {
        mainToDoList.resetData(newData);
        logger.fine("[MODEL] --- successfully reset data of the to-do list");
        backupCurrentToDoList();
        indicateToDoListChanged();
    }
```
###### /java/seedu/agendum/model/ModelManager.java
``` java
    @Override
    public synchronized void deleteTasks(List<ReadOnlyTask> targets) throws TaskNotFoundException {
        for (ReadOnlyTask target: targets) {
            mainToDoList.removeTask(target);
            removeTaskFromSyncManager(target);
        }

        logger.fine("[MODEL] --- successfully deleted all specified targets from the to-do list");
        backupCurrentToDoList();
        indicateToDoListChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        mainToDoList.addTask(task);    

        logger.fine("[MODEL] --- successfully added the new task to the to-do list");
        backupCurrentToDoList();
        updateFilteredListToShowAll();
        indicateToDoListChanged();
        addTaskToSyncManager(task);
    }
    
    @Override
    public synchronized void updateTask(ReadOnlyTask target, Task updatedTask)
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        mainToDoList.updateTask(target, updatedTask);

        logger.fine("[MODEL] --- successfully updated the target task in the to-do list");
        backupCurrentToDoList();
        updateFilteredListToShowAll();
        indicateToDoListChanged();

        addTaskToSyncManager(updatedTask);
        removeTaskFromSyncManager(target);
    }

    @Override
    public synchronized void markTasks(List<ReadOnlyTask> targets) 
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        for (ReadOnlyTask target: targets) {
            mainToDoList.markTask(target);
        }

        logger.fine("[MODEL] --- successfully marked all specified targets from the to-do list");
        backupCurrentToDoList();
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized void unmarkTasks(List<ReadOnlyTask> targets) 
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        for (ReadOnlyTask target: targets) {
            mainToDoList.unmarkTask(target);
        }

        logger.fine("[MODEL] --- successfully unmarked all specified targets from the to-do list");
        backupCurrentToDoList();
        indicateToDoListChanged();
    }

    /**
     * Restores the previous (second latest) list saved in the stack of previous lists.
     */
    @Override
    public synchronized void restorePreviousToDoList() throws NoPreviousListFoundException {            
        removeLastSavedToDoList();
        resetDataToLastSavedList();
        logger.fine("[MODEL] --- successfully restored the previous the to-do list from this session");
        indicateToDoListChanged();
    }

    /**
     * Resets the {@code mainToDoList} data to match the top list in the {@code previousLists} stack
     */
    @Override
    public void resetDataToLastSavedList() {
        assert !previousLists.empty();
        ToDoList lastSavedListFromHistory = previousLists.peek();
        mainToDoList.resetData(lastSavedListFromHistory);
    }
 
    private void backupCurrentToDoList() {
        ToDoList latestList = new ToDoList(this.getToDoList());
        previousLists.push(latestList);
    }

    private void clearAllPreviousToDoLists() {
        previousLists.clear();
    }

    /**
     * Pops the top list from the {@code previousLists} stack if there are more than 1 list present
     * @throws NoPreviousListFoundException if there is only 1 list in the stack
     */
    private void removeLastSavedToDoList() throws NoPreviousListFoundException {
        assert !previousLists.empty();

        if (previousLists.size() == 1) {
            throw new NoPreviousListFoundException();
        }

        previousLists.pop();
    }


```
###### /java/seedu/agendum/model/task/ReadOnlyTask.java
``` java
    /**
     * Format the tasks as text, showing all fine details including name, 
     * completion status, start and end time if any and last updated time
     */
    default String getDetailedText() {
        String completionStatus = (isCompleted()) ? "Completed" : "Incomplete";
        String startTime = (getStartDateTime().isPresent()) ? getStartDateTime().get().toString()
                                                            : "None";
        String endTime = (getEndDateTime().isPresent()) ? getEndDateTime().get().toString()
                                                        : "None";
        String lastUpdatedTime = getLastUpdatedTime().toString();

        final StringBuilder builder = new StringBuilder();
        builder.append("Task name: ")
               .append(getName())
               .append(" Completion Status: ")
               .append(completionStatus)
               .append(" Start Time: ")
               .append(startTime)
               .append(" End Time: ")
               .append(endTime)
               .append(" Last Updated Time: ")
               .append(lastUpdatedTime);
         return builder.toString();      
    }

}
```
###### /java/seedu/agendum/model/task/Task.java
``` java
/**
 * Represents a Task in the to do list.
 */
public class Task implements ReadOnlyTask, Comparable<Task> {

    private static final int UPCOMING_DAYS_THRESHOLD = 7;

    private Name name_;
    private boolean isCompleted_;
    private LocalDateTime startDateTime_;
    private LocalDateTime endDateTime_;
    private LocalDateTime lastUpdatedTime_;
    
    // ================ Constructor methods ==============================

    /**
     * Constructor for a floating task (with no deadline/start time or end time)
     */
    public Task(Name name) {
        assert CollectionUtil.isNotNull(name);
        this.name_ = name;
        this.isCompleted_ = false;
        this.startDateTime_ = null;
        this.endDateTime_ = null;
        setLastUpdatedTimeToNow();
    }
    
    /**
     * Constructor for a task with deadline only
     */
    public Task(Name name, Optional<LocalDateTime> deadline) {
        assert CollectionUtil.isNotNull(name);
        this.name_ = name;
        this.isCompleted_ = false;
        this.startDateTime_ = null;
        this.endDateTime_ = deadline.orElse(null);
        this.setLastUpdatedTimeToNow();
    }
    
    /**
     * Constructor for a task (event) with both a start and end time
     */
    public Task(Name name, Optional<LocalDateTime> startDateTime,
            Optional<LocalDateTime> endDateTime) {
        assert CollectionUtil.isNotNull(name);
        this.name_ = name;
        this.isCompleted_ = false;
        this.startDateTime_ = startDateTime.orElse(null);
        this.endDateTime_ = endDateTime.orElse(null);
        this.setLastUpdatedTimeToNow();
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getStartDateTime(), source.getEndDateTime());
        if (source.isCompleted()) {
            this.markAsCompleted();
        }
        this.setLastUpdatedTime(source.getLastUpdatedTime());
    }
    
    // ================ Getter methods ==============================

    @Override
    public Name getName() {
        return name_;
    }

    @Override
    public boolean isCompleted() {
        return isCompleted_;
    }

    /**
     * Returns true if a task is uncompleted and has a start/end time
     * that is after the current time but within some threshold amount of days
     */
    @Override
    public boolean isUpcoming() {
        if (isCompleted()) {
            return false;
        }

        if (!hasTime()) {
            return false;
        }

        LocalDateTime currentTime = LocalDateTime.now();
        LocalDateTime thresholdTime = currentTime.plusDays(UPCOMING_DAYS_THRESHOLD);
        boolean isBeforeUpcomingDaysThreshold = getTaskTime().isBefore(thresholdTime);
        boolean isAfterCurrentTime = getTaskTime().isAfter(currentTime);

        return isBeforeUpcomingDaysThreshold && isAfterCurrentTime;
    }

    /**
     * Returns true is a task is uncompleted and has a start/end time
     * that is before the current time
     */
    @Override
    public boolean isOverdue() {
        if (isCompleted()) {
            return false;
        }

        if (!hasTime()) {
            return false;
        }

        LocalDateTime currentTime = LocalDateTime.now();
        boolean isBeforeCurrentTime = getTaskTime().isBefore(currentTime);
                
        return isBeforeCurrentTime;
    }

    /**
     * Returns true if a task has a start time or an end time, false otherwise
     * This must be called to check if comparison of task's time is possible
     */
    @Override
    public boolean hasTime() {
        return getStartDateTime().isPresent() || getEndDateTime().isPresent();
    }

    /**
     * Returns true if the task has a start time and end time, false otherwise.
     */
    @Override
    public boolean isEvent() {
        return getStartDateTime().isPresent() && getEndDateTime().isPresent();
    }

    /**
     * Returns true if the task has a deadline (i.e. only a end time), false otherwise.
     */
    @Override
    public boolean hasDeadline() {
        return !getStartDateTime().isPresent() && getEndDateTime().isPresent();
    }

    @Override
    public Optional<LocalDateTime> getStartDateTime() {
        return Optional.ofNullable(startDateTime_);
    }

    @Override
    public Optional<LocalDateTime> getEndDateTime() {
        return Optional.ofNullable(endDateTime_);
    }

    /**
     * Returns the time the task is last updated.
     * e.g. created, renamed, rescheduled, marked or unmarked
     */
    @Override
    public LocalDateTime getLastUpdatedTime() {
        return lastUpdatedTime_;
    }

    /**
     * Pre-condition: Task has a start or end time.
     * Returns the start time if present, else returns the end time. 
     */
    private LocalDateTime getTaskTime() {
        assert hasTime();
        return getStartDateTime().orElse(getEndDateTime().get());
    }
    
    // ================ Setter methods ==============================
    
    public void setName(Name name) {
        this.name_ = name;
        setLastUpdatedTimeToNow();
    }
    
    public void markAsCompleted() {
        this.isCompleted_ = true;
        setLastUpdatedTimeToNow();
    }
    
    public void markAsUncompleted() {
        this.isCompleted_ = false;
        setLastUpdatedTimeToNow();
    }
    
    public void setStartDateTime(Optional<LocalDateTime> startDateTime) {
        this.startDateTime_ = startDateTime.orElse(null);
        setLastUpdatedTimeToNow();
    }
    
    public void setEndDateTime(Optional<LocalDateTime> endDateTime) {
        this.endDateTime_ = endDateTime.orElse(null);
        setLastUpdatedTimeToNow();
    }

    public void setLastUpdatedTime(LocalDateTime updatedTime) {
        this.lastUpdatedTime_ = updatedTime;
    }

    public void setLastUpdatedTimeToNow() {
        // nano-seconds is set to 0 for more consistent test results when (un)marking multiple tasks
        this.lastUpdatedTime_ = LocalDateTime.now().withNano(0);
    }

    // ================ Other methods ==============================

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    /**
     * Compares the current task with another Task other.
     * The current task is considered to be less than the other task if
     * 1) it is uncompleted and other is completed
     * 2) both tasks are completed but this task has a earlier start/end time associated
     * 3) both tasks are uncompleted but this task has a later updated time
     * 4) both tasks are uncompleted with the same updated time
     *    but this task has a lexicographically smaller name (useful when sorting tasks in testing)
     */
    @Override
    public int compareTo(Task other) {
        int comparedCompletionStatus = compareCompletionStatus(other);
        if (comparedCompletionStatus != 0) {
            return comparedCompletionStatus;
        }

        int comparedTaskTime = compareTaskTime(other);
        if (!isCompleted() && comparedTaskTime != 0) {
            return comparedTaskTime;
        }

        int comparedLastUpdatedTime = compareLastUpdatedTime(other);
        if (comparedLastUpdatedTime != 0) {
            return comparedLastUpdatedTime;
        }
        
        return compareName(other);
    }

    /**
     * Compares the completion status of current task with another Task other.
     * The current task is considered to be less than the other task if
     * it is uncompleted and other is completed
     */
    public int compareCompletionStatus(Task other) {
        return Boolean.compare(this.isCompleted(), other.isCompleted());
    }

    /**
     * Compares the earliest time of the current task with another Task other.
     * The current task is considered to be less than the other task if
     * 1) both tasks have a time associated but this task has a earlier time associated
     * 2) this task has a time associated but the other task does not.
     * Both tasks are equal if they have no time or the same earliest time associated.
     * Time refers to value returned by {@link #getTaskTime()}
     */
    public int compareTaskTime(Task other) {
        if (this.hasTime() && other.hasTime()) {
            return this.getTaskTime().compareTo(other.getTaskTime());
        } else if (this.hasTime()) {
            return -1;
        } else if (other.hasTime()) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Compares the current task with another Task other.
     * The current task is considered to be less than the other task if
     * it has a later updated time
     */
    public int compareLastUpdatedTime(Task other) {
        return other.getLastUpdatedTime().compareTo(this.getLastUpdatedTime());
    }

    /**
    * Compares the current task with another Task other.
    * The current task is considered to be less than the other task if
    * it has a lexicographically smaller name
    */
    public int compareName(Task other) {
        return this.getName().toString().compareTo(other.getName().toString());
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name_, isCompleted_, startDateTime_, endDateTime_);
    }

    public int syncCode() {
        return hashCode();
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### /java/seedu/agendum/model/task/UniqueTaskList.java
``` java
    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
 
        if (contains(toAdd)) {
            logger.fine("[TASK LIST] --- Duplicate Task: " + toAdd.getDetailedText());
            EventsCenter.getInstance().post(new JumpToListRequestEvent(toAdd, false));
            throw new DuplicateTaskException();
        }

        internalList.add(toAdd);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(toAdd, false));
        
        logger.fine("[TASK LIST] --- Added a Task: " + toAdd.getDetailedText());
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);

        if (!taskFoundAndDeleted) {
            logger.fine("[TASK LIST] --- Missing Task: " + toRemove.getDetailedText());
            throw new TaskNotFoundException();
        }

        logger.fine("[TASK LIST] --- Deleted a Task: " + toRemove.getDetailedText());

        return taskFoundAndDeleted;
    }
    
    /**
     * Replaces the equivalent task (to toUpdate) in the list with a new task (updatedTask).
     *
     * @throws TaskNotFoundException if no such task (toUpdate) could be found in the list.
     * @throws DuplicateTaskException if the updated task is a duplicate of an existing task in the list.
     */
    public boolean update(ReadOnlyTask toUpdate, Task updatedTask)
            throws TaskNotFoundException, DuplicateTaskException {
        assert toUpdate != null;
        assert updatedTask != null;

        final int taskIndex = internalList.indexOf(toUpdate);
        final boolean taskFoundAndUpdated = (taskIndex != -1);

        if (!taskFoundAndUpdated) {
            logger.fine("[TASK LIST] --- Missing Task: " + toUpdate.getDetailedText());
            throw new TaskNotFoundException();
        }

        if (contains(updatedTask)) {
            logger.fine("[TASK LIST] --- Duplicate Task: " + toUpdate.getDetailedText());
            EventsCenter.getInstance().post(new JumpToListRequestEvent(updatedTask, true));
            throw new DuplicateTaskException();
        }

        internalList.set(taskIndex, updatedTask);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(updatedTask, true));
        logger.fine("[TASK LIST] --- Updated Task: " + toUpdate.getDetailedText()
                + " updated to " + updatedTask.getDetailedText());

        return taskFoundAndUpdated;
    }

    /**
     * Marks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException if a duplicate will result from marking the task
     */
    public boolean mark(ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateTaskException {
        assert toMark != null;

        logger.fine("[TASK LIST] --- Attempt to Mark Task: " + toMark.getDetailedText());

        Task markedTask = new Task(toMark);
        markedTask.markAsCompleted();
        boolean taskFoundAndMarked = update(toMark, markedTask);
        
        return taskFoundAndMarked;
    }
    
    /**
     * Unmarks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException if a duplicate will result from unmarking the task
     */
    public boolean unmark(ReadOnlyTask toUnmark) throws TaskNotFoundException, DuplicateTaskException {
        assert toUnmark != null;

        logger.fine("[TASK LIST] --- Attempt to Unmark Task: " + toUnmark.getDetailedText());

        Task unmarkedTask = new Task(toUnmark);
        unmarkedTask.markAsUncompleted();
        boolean taskFoundAndUnmarked = update(toUnmark, unmarkedTask);

        return taskFoundAndUnmarked;
    }

```
###### /java/seedu/agendum/model/ToDoList.java
``` java
    /**
     * Updates an existing task in the to-do list.
     * 
     * @throws DuplicateTaskException if an equivalent task (to updatedTask) already exists.
     * @throws TaskNotFoundException if no such task (key) could be found in the list.
     */
    public boolean updateTask(ReadOnlyTask key, Task updatedTask)
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        return tasks.update(key, updatedTask);
    }

    /**
     * Marks an existing task in the to-do list.
     * 
     * @throws DuplicateTaskException if a duplicate task would result after marking key.
     * @throws TaskNotFoundException if no such task (key) could be found in the list.
     */
    public boolean markTask(ReadOnlyTask key) 
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        return tasks.mark(key);
    }

    /**
     * Unmarks an existing task in the to-do list.
     * 
     * @throws DuplicateTaskException if a duplicate task would result after unmarking key.
     * @throws TaskNotFoundException if no such task (key) could be found in the list.
     */
    public boolean unmarkTask(ReadOnlyTask key)
            throws UniqueTaskList.TaskNotFoundException, UniqueTaskList.DuplicateTaskException {
        return tasks.unmark(key);
    }
```
