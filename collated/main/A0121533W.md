# A0121533W
###### /java/tars/commons/events/ui/RsvTaskAddedEvent.java
``` java
/**
 * Indicates a task has been added
 */
public class RsvTaskAddedEvent extends BaseEvent {

    public final int targetIndex;
    public final RsvTask task;

    public RsvTaskAddedEvent(int targetIndex, RsvTask task) {
        this.targetIndex = targetIndex;
        this.task = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/tars/commons/util/DateTimeUtil.java
``` java
    /**
     * Checks if given endDateTime is within today and the end of this week
     */
    public static boolean isWithinWeek(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            LocalDateTime endThisWeek =
                    now.with(TemporalAdjusters.next(DayOfWeek.MONDAY))
                            .withHour(0).withMinute(0).withSecond(0);
            return endDateTime.isAfter(now)
                    && endDateTime.isBefore(endThisWeek);
        }
    }

```
###### /java/tars/commons/util/DateTimeUtil.java
``` java
    /**
     * Checks if given endDateTime is before the end of today
     */
    public static boolean isOverDue(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            return endDateTime.isBefore(now);
        }
    }

```
###### /java/tars/commons/util/StringUtil.java
``` java
    /**
     * Handles three different cases of strings and return them in the appropriate format
     */
    public static String indexString(String s)
            throws InvalidRangeException, IllegalValueException {
        if (s.isEmpty()) {
            return s;
        }
        if (isSingleNumber(s)) {
            return getIndexForSingleNumber(s);
        } else if (isListOfIndexes(s)) {
            return getIndexesForList(s);
        } else if (isRangeOfIndexes(s)) {
            return getIndexesForRange(s);
        } else {
            throw new IllegalValueException(
                    UNEXPECTED_ERROR_IN_GETING_INDEX_FROM_STRING);
        }
    }

    private static boolean isSingleNumber(String s) {
        return (s.indexOf(STRING_WHITESPACE) == INVALID_POSITION
                && !s.contains(RANGE_SEPARATOR));
    }

    /**
     * Returns a valid single index
     */
    private static String getIndexForSingleNumber(String s)
            throws IllegalValueException {
        if (!isUnsignedInteger(s)) {
            throw new IllegalValueException(INVALID_INDEX_ENTERED);
        }
        return s;
    }

    private static boolean isListOfIndexes(String s) {
        return (s.indexOf(STRING_WHITESPACE) != INVALID_POSITION
                && !s.contains(RANGE_SEPARATOR));
    }

```
###### /java/tars/commons/util/StringUtil.java
``` java
    /**
     * Returns a valid list of indexes
     */
    private static String getIndexesForList(String s)
            throws IllegalValueException {
        String indexString = EMPTY_STRING;
        String[] indexArray = s.split(STRING_WHITESPACE);
        for (int i = START_INDEX; i < indexArray.length; i++) {
            String index = getIndexForSingleNumber(indexArray[i]);
            indexString += index + STRING_WHITESPACE;
        }
        return indexString.trim();
    }

    private static boolean isRangeOfIndexes(String s) {
        return s.contains(RANGE_SEPARATOR);
    }

```
###### /java/tars/commons/util/StringUtil.java
``` java
    /**
     * Returns a list of indexes separated by white space from a range of indexes
     */
    private static String getIndexesForRange(String s)
            throws IllegalValueException, InvalidRangeException {
        String rangeToReturn = EMPTY_STRING;

        int toIndex = s.indexOf(RANGE_SEPARATOR);
        String start = s.substring(START_INDEX, toIndex);
        String end = s.substring(toIndex + RANGE_SEPARATOR.length());

        start = getIndexForSingleNumber(start);
        end = getIndexForSingleNumber(end);

        int startInt = Integer.parseInt(start);
        int endInt = Integer.parseInt(end);

        if (startInt > endInt) {
            throw new InvalidRangeException();
        }

        for (int i = startInt; i <= endInt; i++) {
            rangeToReturn += String.valueOf(i) + STRING_WHITESPACE;
        }

        return rangeToReturn.trim();
    }

}
```
###### /java/tars/logic/commands/DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from tars.
 */
public class DeleteCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "del";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task based on its index in the task list.\n"
            + "Parameters: <INDEX> [INDEX ...]\n" + "Example: "
            + COMMAND_WORD + " 1\n" + COMMAND_WORD + " 1..3";

    public static final String MESSAGE_DELETE_TASK_SUCCESS =
            "Deleted Task:\n%1$s";
    public static final String MESSAGE_UNDO = "Added Task:\n%1$s";
    public static final String MESSAGE_REDO = "Deleted Task:\n%1$s";

    private static final String MESSAGE_MISSING_TARGET_TASK =
            "The target task cannot be missing";

    private final String arguments;
    private ArrayList<ReadOnlyTask> deletedTasks =
            new ArrayList<ReadOnlyTask>();

    public DeleteCommand(String args) {
        this.arguments = args;
    }

    @Override
    public CommandResult execute() {
        ArrayList<ReadOnlyTask> tasksToDelete;
        try {
            tasksToDelete = getTasksFromIndexes(
                    this.arguments.split(StringUtil.STRING_WHITESPACE));
        } catch (InvalidTaskDisplayedException itde) {
            return new CommandResult(itde.getMessage());
        }
        for (ReadOnlyTask t : tasksToDelete) {
            try {
                model.deleteTask(t);
            } catch (TaskNotFoundException tnfe) {
                assert false : MESSAGE_MISSING_TARGET_TASK;
            }
            deletedTasks.add(t);
        }
        model.getUndoableCmdHist().push(this);
        String formattedTaskList = new Formatter().formatTaskList(deletedTasks);
        return new CommandResult(
                String.format(MESSAGE_DELETE_TASK_SUCCESS, formattedTaskList));
    }

    /**
     * Gets Tasks to delete from indexes
     */
    private ArrayList<ReadOnlyTask> getTasksFromIndexes(String[] indexes)
            throws InvalidTaskDisplayedException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList =
                model.getFilteredTaskList();
        ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();

        for (int i = StringUtil.START_INDEX; i < indexes.length; i++) {
            int targetIndex = Integer.parseInt(indexes[i]);
            if (lastShownList.size() < targetIndex) {
                indicateAttemptToExecuteIncorrectCommand();
                throw new InvalidTaskDisplayedException(
                        Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            ReadOnlyTask task =
                    lastShownList.get(targetIndex - StringUtil.LAST_INDEX);
            tasksList.add(task);
        }
        return tasksList;
    }

```
###### /java/tars/logic/commands/DoCommand.java
``` java
/**
 * Marks a task identified using it's last displayed index from tars as done.
 */
public class DoCommand extends Command {

    public static final String COMMAND_WORD = "do";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task based on its index in the task list as done.\n"
            + "Parameters: <INDEX> [INDEX ...]\n" + "Example: "
            + COMMAND_WORD + " 3 5 7\n" + "OR " + COMMAND_WORD + " 1..3";

    private String toDo;

    private MarkTaskUtil tracker;

    /**
     * Convenience constructor using raw values.
     * 
     * @throws InvalidRangeException
     */
    public DoCommand(String toDo) {
        this.toDo = toDo;
        this.tracker = new MarkTaskUtil();
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        try {
            handleMarkDone();
        } catch (InvalidTaskDisplayedException e) {
            return new CommandResult(e.getMessage());
        } catch (DuplicateTaskException dte) {
            return new CommandResult(dte.getMessage());
        }
        return new CommandResult(tracker.getResultFromTracker());
    }

    /**
     * Marks status of task in model as done
     */
    private void handleMarkDone()
            throws InvalidTaskDisplayedException, DuplicateTaskException {
        Status done = new Status(true);
        ArrayList<ReadOnlyTask> markDoneTasks = tracker.getTasksFromIndexes(
                model, this.toDo.split(StringUtil.STRING_WHITESPACE), done);
        model.mark(markDoneTasks, done);
    }

}
```
###### /java/tars/logic/commands/EditCommand.java
``` java
/**
 * Edits a task identified using it's last displayed index from tars.
 */
public class EditCommand extends UndoableCommand {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits any component of a particular task.\n"
            + "Parameters: <INDEX> [/n TASK_NAME] [/dt DATETIME] [/p PRIORITY] "
            + "[/ta TAG_TO_ADD ...] [/tr TAG_TO_REMOVE ...]\n" + "Example: " + COMMAND_WORD
            + " 1 /n Lunch with John /dt 10/09/2016 1200 to 10/09/2016 1300 /p l /ta lunch /tr dinner";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited task: %1$s";

    public static final String MESSAGE_UNDO = "Edited to %1$s to %1$s";
    public static final String MESSAGE_REDO = "Edited to %1$s to %1$s";
    
    private static final int DATETIME_INDEX_OF_ENDDATE = 1;
    private static final int DATETIME_INDEX_OF_STARTDATE = 0;

    public final int targetIndex;
    private ReadOnlyTask toBeReplacedTask;
    private Task editedTask;
    private ArgumentTokenizer argsTokenizer;

    private static final Prefix NAME_PREFIX = new Prefix("/n");
    private static final Prefix DATETIME_PREFIX = new Prefix("/dt");
    private static final Prefix PRIORITY_PREFIX = new Prefix("/p");
    private static final Prefix ADD_TAG_PREFIX = new Prefix("/ta");
    private static final Prefix REMOVE_TAG_PREFIX = new Prefix("/tr");

    /**
     * Convenience constructor using raw values.
     */
    public EditCommand(int targetIndex, ArgumentTokenizer argsTokenizer) {
        this.targetIndex = targetIndex;
        this.argsTokenizer = argsTokenizer;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList =
                model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        toBeReplacedTask = lastShownList
                .get(targetIndex - StringUtil.DISPLAYED_INDEX_OFFSET);
        editedTask = new Task(toBeReplacedTask);

        try {
            updateTask();
            model.replaceTask(toBeReplacedTask, editedTask);
            model.getUndoableCmdHist().push(this);
            return new CommandResult(
                    String.format(MESSAGE_EDIT_TASK_SUCCESS, editedTask));
        } catch (DateTimeException dte) {
            return new CommandResult(Messages.MESSAGE_INVALID_DATE);
        } catch (IllegalValueException | TagNotFoundException e) {
            return new CommandResult(e.getMessage());
        }
    }
    
```
###### /java/tars/logic/commands/MarkTaskUtil.java
``` java
/**
 * Tracks changes made (if any) during do and ud command
 */
public class MarkTaskUtil {

    private ArrayList<Integer> markDoneTasks;
    private ArrayList<Integer> markUndoneTasks;
    private ArrayList<Integer> alreadyDoneTasks;
    private ArrayList<Integer> alreadyUndoneTasks;

    public static final String SUCCESS_DONE =
            "Task: %1$s marked done successfully.\n";
    public static final String SUCCESS_UNDONE =
            "Task: %1$s marked undone successfully.\n";
    public static final String ALREADY_DONE =
            "Task: %1$s already marked done.\n";
    public static final String ALREADY_UNDONE =
            "Task: %1$s already marked undone.\n";

    /**
     * Constructor
     */
    public MarkTaskUtil() {
        this.markDoneTasks = new ArrayList<Integer>();
        this.markUndoneTasks = new ArrayList<Integer>();
        this.alreadyDoneTasks = new ArrayList<Integer>();
        this.alreadyUndoneTasks = new ArrayList<Integer>();
    }

    /**
     * Adds target index of task to relevant "To Mark List" based on status
     */
    public void addToMark(int targetIndex, Status status) {
        if (status.status) {
            addToMarkDoneTask(targetIndex);
        } else {
            addToMarkUndoneTask(targetIndex);
        }

    }

    /**
     * Adds target index of task to relevant "Already Marked List" based on status
     */
    public void addAlreadyMarked(int targetIndex, Status status) {
        if (status.status) {
            addToAlreadyDoneTasks(targetIndex);
        } else {
            addToAlreadyUndoneTasks(targetIndex);
        }
    }

    /**
     * Return string for each tasks index in the specific ArrayLists
     */
    public String getResult() {
        String markDoneTasksString = getIndexesString(markDoneTasks);
        String markUndoneTasksString = getIndexesString(markUndoneTasks);
        String alreadyDoneTasksString = getIndexesString(alreadyDoneTasks);
        String alreadyUndoneTasksString = getIndexesString(alreadyUndoneTasks);

        String result =
                formatResults(markDoneTasksString, markUndoneTasksString,
                        alreadyDoneTasksString, alreadyUndoneTasksString);

        return result;
    }

    /**
     * Main results formatter that will perform the formatting for all 4 cases
     * i.e. Mark Done, Mark Undone, Already Done and Already Undone
     */
    private String formatResults(String markDoneTasksString,
            String markUndoneTasksString, String alreadyDoneTasksString,
            String alreadyUndoneTasksString) {

        String markDoneResult =
                getResultFromString(markDoneTasksString, SUCCESS_DONE);
        String markUndoneResult =
                getResultFromString(markUndoneTasksString, SUCCESS_UNDONE);
        String alreadyDoneResult =
                getResultFromString(alreadyDoneTasksString, ALREADY_DONE);
        String aldreadyUndoneResult =
                getResultFromString(alreadyUndoneTasksString, ALREADY_UNDONE);

        return markDoneResult + markUndoneResult + alreadyDoneResult
                + aldreadyUndoneResult;
    }

    /**
     * Formats results of changes made
     */
    private String getResultFromString(String tasksString, String format) {
        String result = StringUtil.EMPTY_STRING;
        if (!tasksString.isEmpty()) {
            result = String.format(format, tasksString);
        }
        return result;
    }

    /**
     * Gets String of indexes separated by comma
     */
    private String getIndexesString(ArrayList<Integer> list) {
        String toReturn = StringUtil.EMPTY_STRING;
        if (!list.isEmpty()) {
            for (int i = StringUtil.START_INDEX; i < list.size() - 1; i++) {
                toReturn +=
                        Integer.toString(list.get(i)) + StringUtil.STRING_COMMA;
            }
            // Add last index
            toReturn += Integer.toString(list.get(list.size() - 1));
        }
        return toReturn;
    }

    private void addToMarkDoneTask(int index) {
        this.markDoneTasks.add(index);
    }

    private void addToMarkUndoneTask(int index) {
        this.markUndoneTasks.add(index);
    }

    private void addToAlreadyDoneTasks(int index) {
        this.alreadyDoneTasks.add(index);
    }

    private void addToAlreadyUndoneTasks(int index) {
        this.alreadyUndoneTasks.add(index);
    }

    /**
     * Returns feedback message of mark command to user
     */
    public String getResultFromTracker() {
        String commandResult = getResult();
        return commandResult;
    }

    /**
     * Gets Tasks to mark from indexes
     */
    public ArrayList<ReadOnlyTask> getTasksFromIndexes(Model model,
            String[] indexes, Status status)
            throws InvalidTaskDisplayedException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList =
                model.getFilteredTaskList();
        ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();

        for (int i = 0; i < indexes.length; i++) {
            int targetIndex = Integer.valueOf(indexes[i]);
            if (lastShownList.size() < targetIndex) {
                throw new InvalidTaskDisplayedException(
                        Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            ReadOnlyTask task = lastShownList.get(targetIndex - 1);
            if (!task.getStatus().equals(status)) {
                tasksList.add(task);
                addToMark(targetIndex, status);
            } else {
                addAlreadyMarked(targetIndex, status);
            }
        }
        return tasksList;
    }

}
```
###### /java/tars/logic/commands/UdCommand.java
``` java
/**
 * Marks a task identified using it's last displayed index from tars as undone.
 */
public class UdCommand extends Command {

    public static final String COMMAND_WORD = "ud";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task based on its index in the task list as undone.\n"
            + "Parameters: <INDEX> [INDEX ...]\n" + "Example: "
            + COMMAND_WORD + " 3 5 7" + "OR " + COMMAND_WORD + " 1..3\n";

    private String toUndo;

    private MarkTaskUtil tracker;

    /**
     * Convenience constructor using raw values.
     * 
     * @throws InvalidRangeException
     */
    public UdCommand(String toUndo) {
        this.toUndo = toUndo;
        this.tracker = new MarkTaskUtil();
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        try {
            handleMarkUndone();
        } catch (InvalidTaskDisplayedException e) {
            return new CommandResult(e.getMessage());
        } catch (DuplicateTaskException dte) {
            return new CommandResult(dte.getMessage());
        }
        return new CommandResult(tracker.getResultFromTracker());
    }

    /**
     * Marks status of task in model as undone
     */
    private void handleMarkUndone()
            throws InvalidTaskDisplayedException, DuplicateTaskException {
        Status undone = new Status(false);
        ArrayList<ReadOnlyTask> markUndoneTasks = tracker.getTasksFromIndexes(
                model, this.toUndo.split(StringUtil.STRING_WHITESPACE), undone);
        model.mark(markUndoneTasks, undone);
    }

}
```
###### /java/tars/logic/parser/EditCommandParser.java
``` java
/**
 * Edit command parser
 */
public class EditCommandParser extends CommandParser {

    private static final int START_INDEX = 0;
    private static final int EMPTY_SIZE = 0;

    /**
     * Parses arguments in the context of the edit task command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepareCommand(String args) {
        args = args.trim();
        int targetIndex = START_INDEX;
        if (args.indexOf(
                StringUtil.STRING_WHITESPACE) != StringUtil.INVALID_POSITION) {
            targetIndex = args.indexOf(StringUtil.STRING_WHITESPACE);
        }

        String index;
        try {
            index = StringUtil.indexString(
                    (args.substring(StringUtil.START_INDEX, targetIndex)));
        } catch (Exception e) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        if (index.isEmpty()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(namePrefix,
                priorityPrefix, dateTimePrefix, addTagPrefix, removeTagPrefix);
        argsTokenizer.tokenize(args);

        if (argsTokenizer.numPrefixFound() == EMPTY_SIZE) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        return new EditCommand(Integer.parseInt(index), argsTokenizer);
    }

}
```
###### /java/tars/model/Model.java
``` java
    /**
     * Marks tasks as done or undone.
     */
    void mark(ArrayList<ReadOnlyTask> toMarkList, Status status)
            throws DuplicateTaskException;
```
###### /java/tars/model/ModelManager.java
``` java
    @Override
    public synchronized void mark(ArrayList<ReadOnlyTask> toMarkList,
            Status status) throws DuplicateTaskException {
        tars.mark(toMarkList, status);
        indicateTarsChanged();
    }

```
###### /java/tars/model/Tars.java
``` java
    /**
     * Replaces task in tars internal list
     *
     * @throws DuplicateTaskException if replacement task is the same as the task to replace
     */
    public void replaceTask(ReadOnlyTask toReplace, Task replacement)
            throws DuplicateTaskException {
        if (toReplace.isSameStateAs(replacement)) {
            throw new DuplicateTaskException();
        }

        ObservableList<Task> list = this.tasks.getInternalList();
        for (int i = StringUtil.START_INDEX; i < list.size(); i++) {
            if (list.get(i).isSameStateAs(toReplace)) {
                syncTagsWithMasterList(replacement);
                list.set(i, replacement);
                break;
            }
        }
    }
```
###### /java/tars/model/Tars.java
``` java
    /**
     * Marks every task in respective lists as done or undone
     * 
     * @throws DuplicateTaskException
     */
    public void mark(ArrayList<ReadOnlyTask> toMarkList, Status status)
            throws DuplicateTaskException {
        for (ReadOnlyTask t : toMarkList) {
            if (!t.getStatus().equals(status)) {
                // prevent marking tasks which are already marked
                Task toMark = new Task(t);
                toMark.setStatus(status);
                replaceTask(t, toMark);
            }
        }
    }
```
###### /java/tars/ui/formatter/Formatter.java
``` java
    /**
     * Formats a given RsvTask dateTime list to display on rsvTaskCard
     */
    public static String formatDateTimeList(ArrayList<DateTime> dateTimeList) {
        String formatted = StringUtil.EMPTY_STRING;
        int count = 1;
        for (DateTime dt : dateTimeList) {
            formatted += String.format(DATETIME_FORMAT_STRING, count,
                    DateFormatter.formatDate(dt));
            count++;
        }
        return formatted;
    }

    /**
     * Formats a given tasks list to display on This Week Panel
     */
    public static String formatThisWeekPanelTasksList(
            List<ReadOnlyTask> overduedTasks) {
        String formatted = StringUtil.EMPTY_STRING;
        int count = INITIAL_COUNT;
        for (ReadOnlyTask t : overduedTasks) {
            String taskName = t.getName().toString();
            formatted += String.format(OVERDUED_TASKS_STRING, count, taskName);
            count++;
        }
        return formatted.trim();
    }
}
```
###### /java/tars/ui/HelpPanel.java
``` java
/**
 * UI Controller for a help page
 */
public class HelpPanel extends UiPart {
    private static final String FXML = "HelpPanel.fxml";
    private static final String USERGUIDE_URL = "/html/UserGuide.md.html";

    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private WebView browser = new WebView();

    public static HelpPanel load(Stage primaryStage,
            AnchorPane helpPanelPlaceHolder) {
        HelpPanel helpPanel = UiPartLoader.loadUiPart(primaryStage,
                helpPanelPlaceHolder, new HelpPanel());
        helpPanel.configure();
        return helpPanel;
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void configure() {
        addToPlaceholder();
        browser.getEngine().load(configureURL(UserGuide.DEFAULT));

    }

```
###### /java/tars/ui/MainWindowEventsHandler.java
``` java
/**
 * Handles all events that require main window.
 */
public class MainWindowEventsHandler {

    private static String LOG_MESSAGE_COMMAND_DETECTED = "%s command detected.";

    private double xOffset = 0;
    private double yOffset = 0;
    private final Logger logger = LogsCenter.getLogger(MainWindow.class);

    private VBox rootLayout;
    private TabPane tabPane;
    protected Stage primaryStage;

    public MainWindowEventsHandler(Stage primaryStage, VBox rootLayout,
            TabPane tabPane) {
        this.rootLayout = rootLayout;
        this.primaryStage = primaryStage;
        this.tabPane = tabPane;
        EventsCenter.getInstance().registerHandler(this);
    }

    public void addMouseEventHandler() {
        rootLayout.setOnMousePressed(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                xOffset = event.getSceneX();
                yOffset = event.getSceneY();
            }
        });
        rootLayout.setOnMouseDragged(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                primaryStage.setX(event.getScreenX() - xOffset);
                primaryStage.setY(event.getScreenY() - yOffset);
            }
        });
    }

    public void addTabPaneHandler() {
        rootLayout.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                if (event.getCode() == KeyCode.RIGHT) {
                    cycleTabPaneRight();
                    event.consume();
                } else if (event.getCode() == KeyCode.LEFT) {
                    cycleTabPaneLeft();
                    event.consume();
                }
            }
        });
    }

    @Subscribe
    private void KeyCombinationPressedEventHandler(
            KeyCombinationPressedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                event.getKeyCombination().getDisplayText()));
        if (event
                .getKeyCombination() == KeyCombinations.KEY_COMB_CTRL_RIGHT_ARROW) {
            cycleTabPaneRight();
        } else if (event
                .getKeyCombination() == KeyCombinations.KEY_COMB_CTRL_LEFT_ARROW) {
            cycleTabPaneLeft();
        }
    }

    @Subscribe
    private void CommandBoxTextFieldValueChangedEventHandler(
            CommandBoxTextFieldValueChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, String.format(
                LOG_MESSAGE_COMMAND_DETECTED, event.getTextFieldValue())));
        if (event.getTextFieldValue().equals(RsvCommand.COMMAND_WORD) || event
                .getTextFieldValue().equals(ConfirmCommand.COMMAND_WORD)) {
            tabPane.getSelectionModel()
                    .select(MainWindow.RSV_TASK_LIST_PANEL_TAB_PANE_INDEX);
        }
    }

    private void cycleTabPaneRight() {
        if (tabPane.getSelectionModel()
                .isSelected((MainWindow.HELP_PANEL_TAB_PANE_INDEX))) {
            tabPane.getSelectionModel().selectFirst();
        } else {
            tabPane.getSelectionModel().selectNext();
        }
    }

    private void cycleTabPaneLeft() {
        if (tabPane.getSelectionModel()
                .isSelected((MainWindow.OVERVIEW_PANEL_TAB_PANE_INDEX))) {
            tabPane.getSelectionModel().selectLast();
        } else {
            tabPane.getSelectionModel().selectPrevious();
        }
    }

```
###### /java/tars/ui/RsvTaskCard.java
``` java
/**
 * UI Controller for Reserve Task Card
 */
public class RsvTaskCard extends UiPart {

    private static final int PREF_SIZE_HEIGHT = 75;
    private static final int PREF_SIZE_WIDTH = 200;
    private static final String DATE_TIME_LIST_AREA = "dateTimeListArea";
    private static final String FXML = "RsvTaskListCard.fxml";
    private static final String DATETIMELIST_ID = "dateTimeList";

    private TextArea dateTimeListArea;
    private AnchorPane dateTimeListPane;

    private StringProperty dateTimeListdisplayed =
            new SimpleStringProperty(StringUtil.EMPTY_STRING);

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;

    private RsvTask rsvTask;
    private int displayedIndex;

    public RsvTaskCard() {

    }

    public static RsvTaskCard load(RsvTask rsvTask, int displayedIndex) {
        RsvTaskCard card = new RsvTaskCard();
        card.cardPane = new HBox();
        card.dateTimeListPane = new AnchorPane();

        card.rsvTask = rsvTask;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        name.setText(rsvTask.getName().taskName);
        id.setText(displayedIndex + StringUtil.STRING_FULLSTOP);
        setDateTimeList();
        configure();
    }

    public void configure() {
        dateTimeListArea = new TextArea();
        dateTimeListArea.setEditable(false);
        dateTimeListArea.setId(DATETIMELIST_ID);
        dateTimeListArea.getStyleClass().removeAll();
        dateTimeListArea.getStyleClass().add(DATE_TIME_LIST_AREA);
        dateTimeListArea.setWrapText(true);
        dateTimeListArea.setPrefSize(PREF_SIZE_WIDTH, PREF_SIZE_HEIGHT);
        dateTimeListArea.textProperty().bind(dateTimeListdisplayed);
        dateTimeListArea.autosize();

        dateTimeListPane.getChildren().add(dateTimeListArea);
        cardPane.getChildren().add(dateTimeListPane);
    }

    private void setDateTimeList() {
        ArrayList<DateTime> dateTimeList = rsvTask.getDateTimeList();
        Collections.sort(dateTimeList);
        String toSet = Formatter.formatDateTimeList(dateTimeList);
        dateTimeListdisplayed.setValue(toSet);
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
        dateTimeListPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### /java/tars/ui/RsvTaskListPanel.java
``` java
/**
 * UI Controller for panel containing the list of reserved tasks.
 */
public class RsvTaskListPanel extends UiPart {
    private static String LOG_MESSAGE_LAYOUT_UPDATING =
            "Updating layout for %s";
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static final String FXML = "RsvTaskListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;
    private static final int START_INDEX = 1;

    @FXML
    private ListView<RsvTask> rsvTaskListView;

    public RsvTaskListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static RsvTaskListPanel load(Stage primaryStage,
            AnchorPane rsvTaskListPlaceholder,
            ObservableList<RsvTask> rsvTaskList) {
        RsvTaskListPanel rsvTaskListPanel = UiPartLoader.loadUiPart(
                primaryStage, rsvTaskListPlaceholder, new RsvTaskListPanel());
        rsvTaskListPanel.configure(rsvTaskList);
        return rsvTaskListPanel;
    }

    private void configure(ObservableList<RsvTask> rsvTaskList) {
        setConnections(rsvTaskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<RsvTask> rsvTaskList) {
        rsvTaskListView.setItems(rsvTaskList);
        rsvTaskListView.setCellFactory(listView -> new RsvTaskListViewCell());
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            rsvTaskListView.scrollTo(index);
        });
    }

    class RsvTaskListViewCell extends ListCell<RsvTask> {
        private RsvTask newlyAddedRsvTask;

        public RsvTaskListViewCell() {
            registerAsAnEventHandler(this);
        }

        @Override
        protected void updateItem(RsvTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                RsvTaskCard card =
                        RsvTaskCard.load(task, getIndex() + START_INDEX);
                HBox layout = card.getLayout();
                if (this.newlyAddedRsvTask != null
                        && this.newlyAddedRsvTask.isSameStateAs(task)) {
                    layout.setStyle(UiColor.TASK_CARD_NEWLY_ADDED_BORDER);
                } else {
                    layout.setStyle(UiColor.TASK_CARD_DEFAULT_BORDER);
                }
                setGraphic(layout);
            }
        }

        @Subscribe
        private void handleRsvTaskAddedEvent(RsvTaskAddedEvent event) {
            logger.info(LogsCenter.getEventHandlingLogMessage(event,
                    String.format(LOG_MESSAGE_LAYOUT_UPDATING,
                            event.task.toString())));
            this.newlyAddedRsvTask = event.task;
        }
    }

}
```
###### /java/tars/ui/TaskCard.java
``` java
/**
 * UI Controller for Task Card
 */
public class TaskCard extends UiPart {

    private static final String FXML = "TaskListCard.fxml";

    private static final String STATUS_UNDONE = "Undone";
    private static final String STATUS_DONE = "Done";

    private static final String PRIORITY_HIGH = "h";
    private static final String PRIORITY_MEDIUM = "m";
    private static final String PRIORITY_LOW = "l";

    private static final String LABEL_HIGH = "H";
    private static final String LABEL_MEDIUM = "M";
    private static final String LABEL_LOW = "L";
    private static final String LABEL_DONE = "âœ”";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label date;
    @FXML
    private Label circleLabel;
    @FXML
    private Label tags;
    @FXML
    private Circle priorityCircle;

    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard() {

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex) {
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        card.registerAsAnEventHandler(card);
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        setName();
        setIndex();
        setDate();
        setTags();
        setCircle();
        setCardTextColorByStatus();
    }

    private void setName() {
        name.setText(task.getName().taskName);
    }

    private void setIndex() {
        id.setText(displayedIndex + StringUtil.STRING_FULLSTOP);
    }

    private void setDate() {
        date.setText(DateFormatter.formatDate(task.getDateTime()));
    }

    /**
     * Sets UI for Task Card Circle
     */
    private void setCircle() {
        String priority = task.getPriority().priorityLevel;
        String status = task.getStatus().toString();

        Color circleColor = getColorBasedOnPriorityAndStatus(priority, status);
        String label = getLabelBasedOnPriorityAndStatus(priority, status);

        priorityCircle.setFill(circleColor);

        circleLabel.setText(label);
        circleLabel.setStyle(UiColor.CIRCLE_LABEL_COLOR);
    }

```
###### /java/tars/ui/TaskCard.java
``` java
    /**
     * Gets color for circle based on task's priority and status
     */
    private Color getColorBasedOnPriorityAndStatus(String priority,
            String status) {
        if (status.equals(STATUS_DONE)) {
            return UiColor.CircleColor.DONE.getCircleColor();
        } else {
            switch (priority) {
                case PRIORITY_HIGH:
                    return UiColor.CircleColor.HIGH.getCircleColor();
                case PRIORITY_MEDIUM:
                    return UiColor.CircleColor.MEDIUM.getCircleColor();
                case PRIORITY_LOW:
                    return UiColor.CircleColor.LOW.getCircleColor();
                default:
                    return UiColor.CircleColor.NONE.getCircleColor();
            }
        }
    }

```
###### /java/tars/ui/TaskCard.java
``` java
    /**
     * Gets label for circle based on task's priority and status
     */
    private String getLabelBasedOnPriorityAndStatus(String priority,
            String status) {
        if (status.equals(STATUS_DONE)) {
            return LABEL_DONE;
        } else {
            switch (priority) {
                case PRIORITY_HIGH:
                    return LABEL_HIGH;
                case PRIORITY_MEDIUM:
                    return LABEL_MEDIUM;
                case PRIORITY_LOW:
                    return LABEL_LOW;
                default:
                    return StringUtil.EMPTY_STRING;
            }
        }
    }

    /**
     * Sets text to different color based on the status of a task
     */
    private void setCardTextColorByStatus() {
        String taskStatus = task.getStatus().toString();
        String color = StringUtil.EMPTY_STRING;
        switch (taskStatus) {
            case STATUS_UNDONE:
                color = UiColor.STATUS_UNDONE_TEXT_FILL_DARK;
                break;
            case STATUS_DONE:
                color = UiColor.STATUS_DONE_TEXT_FILL;
                break;
        }
        id.setStyle(color);
        name.setStyle(color);
        date.setStyle(color);
        tags.setStyle(color);

        if (taskStatus.equals(STATUS_UNDONE)) {
            date.setStyle(UiColor.STATUS_UNDONE_TEXT_FILL_LIGHT);
            tags.setStyle(UiColor.STATUS_UNDONE_TEXT_FILL_LIGHT);
        }
    }

    @Subscribe
    private void handleTarsChangeEvent(TarsChangedEvent event) {
        setCircle();
        setCardTextColorByStatus();
    }


    private void setTags() {
        tags.setText(task.tagsString());
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

}
```
###### /java/tars/ui/TaskListPanel.java
``` java
/**
 * UI Controller for panel containing the list of tasks.
 */
public class TaskListPanel extends UiPart {
    private static String LOG_MESSAGE_LAYOUT_UPDATING =
            "Updating layout for %s";

    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static final String FXML = "TaskListPanel.fxml";
    private AnchorPane placeHolderPane;
    private static final int START_INDEX = 1;

    @FXML
    private ListView<ReadOnlyTask> taskListView;
    @FXML
    private VBox panel;

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static TaskListPanel load(Stage primaryStage,
            AnchorPane taskListPlaceholder,
            ObservableList<ReadOnlyTask> taskList) {
        TaskListPanel taskListPanel = UiPartLoader.loadUiPart(primaryStage,
                taskListPlaceholder, new TaskListPanel());
        taskListPanel.configure(taskList);
        return taskListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {
        private ReadOnlyTask newlyAddedTask;

        public TaskListViewCell() {
            registerAsAnEventHandler(this);
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                TaskCard card = TaskCard.load(task, getIndex() + START_INDEX);
                HBox layout = card.getLayout();
                if (this.newlyAddedTask != null
                        && this.newlyAddedTask.isSameStateAs(task)) {
                    layout.setStyle(UiColor.TASK_CARD_NEWLY_ADDED_BORDER);
                } else {
                    layout.setStyle(UiColor.TASK_CARD_DEFAULT_BORDER);
                }
                setGraphic(layout);
            }
        }

        @Subscribe
        private void handleTaskAddedEvent(TaskAddedEvent event) {
            logger.info(LogsCenter.getEventHandlingLogMessage(event,
                    String.format(LOG_MESSAGE_LAYOUT_UPDATING,
                            event.task.toString())));
            this.newlyAddedTask = event.task;
        }
    }

}
```
###### /java/tars/ui/ThisWeekPanel.java
``` java
/**
 * UI Controller for this week panel
 */
public class ThisWeekPanel extends UiPart {
    private static final String LOG_MESSAGE_UPDATE_THIS_WEEK_PANEL =
            "Update this week panel";
    private static final Logger logger =
            LogsCenter.getLogger(ThisWeekPanel.class);
    private static final String FXML = "ThisWeekPanel.fxml";
    private static final String THISWEEK_PANEL_STYLE_SHEET = "thisWeek-panel";
    private static final String STATUS_UNDONE = "Undone";
    private static final String TASK_LIST_ELLIPSIS = "\n...\n";
    private static final DateFormat df = new SimpleDateFormat("E, MMM dd");

    private static List<ReadOnlyTask> list;
    private static List<ReadOnlyTask> upcomingTasks =
            new ArrayList<ReadOnlyTask>();
    private static List<ReadOnlyTask> overduedTasks =
            new ArrayList<ReadOnlyTask>();

    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private Label date;
    @FXML
    private Label numUpcoming;
    @FXML
    private Label numOverdue;
    @FXML
    private Label overduedTasksList;
    @FXML
    private Label upcomingTasksList;

    private static final int MIN_SIZE = 5;

    public static ThisWeekPanel load(Stage primaryStage,
            AnchorPane thisWeekPanelPlaceHolder, List<ReadOnlyTask> taskList) {
        ThisWeekPanel thisWeekPanel = UiPartLoader.loadUiPart(primaryStage,
                thisWeekPanelPlaceHolder, new ThisWeekPanel());
        list = taskList;
        thisWeekPanel.configure();
        return thisWeekPanel;
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void configure() {
        panel.getStyleClass().add(THISWEEK_PANEL_STYLE_SHEET);
        setDate();
        handleUpcomingTasks();
        handleOverdueTasks();
        addToPlaceholder();
        registerAsAnEventHandler(this);
    }

    private void setDate() {
        Date today = new Date();
        date.setText(df.format(today));
    }

    /**
     * Updates number of upcoming tasks and lists them
     */
    private void handleUpcomingTasks() {
        int count = 0;
        for (ReadOnlyTask t : list) {
            if (DateTimeUtil.isWithinWeek(t.getDateTime().getEndDate())
                    && t.getStatus().toString().equals(STATUS_UNDONE)) {
                count++;
                upcomingTasks.add(t);
            }
        }
        numUpcoming.setText(String.valueOf(count));
        if (count == 0) {
            upcomingTasksList.setText(StringUtil.EMPTY_STRING);
        } else {
            setThisWeekPanelTaskList(count, upcomingTasks, upcomingTasksList);
        }
    }

    /**
     * Updates number of overdued tasks and lists them
     */
    private void handleOverdueTasks() {
        int count = 0;
        for (ReadOnlyTask t : list) {
            if (DateTimeUtil.isOverDue(t.getDateTime().getEndDate())
                    && t.getStatus().toString().equals(STATUS_UNDONE)) {
                count++;
                overduedTasks.add(t);
            }
        }
        numOverdue.setText(String.valueOf(count));
        if (count == 0) {
            overduedTasksList.setText(StringUtil.EMPTY_STRING);
        } else {
            setThisWeekPanelTaskList(count, overduedTasks, overduedTasksList);
        }
    }

    /**
     * Set text for tasksLists to display top five tasks
     * 
     */
    private void setThisWeekPanelTaskList(int count,
            List<ReadOnlyTask> tasksList, Label taskListLabel) {
        List<ReadOnlyTask> topFiveTasks = tasksList.subList(
                StringUtil.START_INDEX, Math.min(tasksList.size(), MIN_SIZE));
        String list = Formatter.formatThisWeekPanelTasksList(topFiveTasks);
        if (tasksList.size() > MIN_SIZE) {
            list = list + TASK_LIST_ELLIPSIS;
        }
        taskListLabel.setText(list);
    }

    /**
     * Updates panel with latest data
     */
    private void updateThisWeekPanel() {
        upcomingTasks.clear();
        handleUpcomingTasks();
        overduedTasks.clear();
        handleOverdueTasks();
    }

    @Subscribe
    private void handleTarsChangedEvent(TarsChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                LOG_MESSAGE_UPDATE_THIS_WEEK_PANEL));
        updateThisWeekPanel();
    }

    @Subscribe
    private void handleTarsStorageChangeDirectoryEvent(
            TarsStorageDirectoryChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                LOG_MESSAGE_UPDATE_THIS_WEEK_PANEL));
        updateThisWeekPanel();
    }
}
```
###### /java/tars/ui/UiColor.java
``` java
 *
 */
public class UiColor {

    public static final String STATUS_UNDONE_TEXT_FILL_DARK =
            "-fx-text-fill: #212121";
    public static final String STATUS_UNDONE_TEXT_FILL_LIGHT =
            "-fx-text-fill: #757575";
    public static final String STATUS_DONE_TEXT_FILL =
            "-fx-text-fill: lightgrey";
    public static final String CIRCLE_LABEL_COLOR = "-fx-text-fill: white;";
    public static final String TASK_CARD_NEWLY_ADDED_BORDER =
            "-fx-border-color: #2E8AF7";
    public static final String TASK_CARD_DEFAULT_BORDER =
            "-fx-border-color: lightgrey";


    public enum CircleColor {
        HIGH(Color.RED), MEDIUM(Color.ORANGE), LOW(Color.GREEN), DONE(
                Color.LIGHTGREY), NONE(Color.TRANSPARENT);
        private Color circleColor;

        CircleColor(Color circleColor) {
            this.circleColor = circleColor;
        }

        Color getCircleColor() {
            return circleColor;
        }
    }
}
```
###### /resources/view/TarsTheme.css
``` css

/*
 * ====================================================================
 * ============================Fonts===================================
 * ====================================================================
 */

@font-face {
  font-family: Roboto;
  src: url("../fonts/roboto/Roboto-Regular.ttf");
}

@font-face {
  font-family: "Roboto Medium";
  src: url("../fonts/roboto/Roboto-Medium.ttf");
}

@font-face {
  font-family: "Roboto Light";
  src: url("../fonts/roboto/Roboto-Light.ttf");
}

@font-face {
  font-family: "Roboto Black";
  src: url("../fonts/roboto/Roboto-Black.ttf");
}

@font-face {
  font-family: "Roboto Bold";
  src: url("../fonts/roboto/Roboto-Bold.ttf");
}
 
.root {
	-fx-focus-color: transparent;
}

.background {
    -fx-background-color: #455A64;
}

.list-label {
	-fx-font-size: 18px;
	-fx-text-fill: #212121;
	-fx-background-color: white;
	-fx-font-family: "Roboto Black";
}

.error {
    -fx-background-color: #F44336;
}

/*
 * ====================================================================
 * ========================SplitPane===================================
 * ====================================================================
 */

.split-pane:horizontal .split-pane-divider {
    -fx-border-color: transparent;
    -fx-background-color: lightgrey;
    -fx-padding: 0 0.1 0 0.1;
}

.split-pane {
    -fx-border-radius: 0;
    -fx-border-width: 0;
    -fx-background-color: white;
}

/*
 * ====================================================================
 * ==========================TabPane===================================
 * ====================================================================
 */
 
.tab-pane {
    -fx-padding: 0 10 0 5;
}

.tab-pane .tab {
    -fx-background-color: white;
    -fx-border-width: 0 0 2 0;
}

.tab .tab-label {
	-fx-font-size: 18px;
	-fx-text-fill: #212121;
	-fx-font-family: "Roboto Black";
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.tab:selected {
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-background-color: white;
    -fx-border-width: 0 0 2 0;
    -fx-border-color: transparent transparent #2E8AF7 transparent;
}

.tab-pane:focused > .tab-header-area > .headers-region > .tab:selected .focus-indicator {
    -fx-focus-color: transparent;
    -fx-faint-focus-color: transparent;
}

.tab-pane *.tab-header-background {
    -fx-background-color: white;
    -fx-border-width: 1 0 1 0;
}


.thisWeek-panel {
	-fx-background-color: white;
}

.thisWeek-panel-label {
	-fx-font-size: 24px;
	-fx-text-fill: #212121;
}

.date-label {
	-fx-font-size: 32px;
	-fx-text-fill: #212121;
}

/*
 * ====================================================================
 * =========================CommandBox=================================
 * ====================================================================
 */
 
.text-field {
    -fx-font-size: 15px;
    -fx-border-color: transparent;
    -fx-font-family: "Roboto";
    -fx-background-insets: 0;       
}

.text-field:focused {
    -fx-focus-color: transparent;
}

/*
 * ====================================================================
 * ==============Results Display & RsvTask DateTimeList================
 * ====================================================================
 */
 
 .anchor-pane {
     -fx-background-color: #F6F6F6;
}

.result-display {
    -fx-background-color: #F6F6F6;
    -fx-border-color: transparent;
    -fx-focus-color: transparent;
    -fx-background-insets: 0;
}

.result-display .label {
    -fx-text-fill: #212121;
}
 
.text-area {
	-fx-background-insets: 0;
	-fx-background-color: transparent;
}

.text-area .content {
    -fx-background-color: #F6F6F6;
    -fx-border-color: transparent;
    -fx-background-insets: 0;
}

.dateTimeListArea .content {
	-fx-background-color: white;
}

/*
 * ====================================================================
 * ========ListView and ListCell for TaskList/RsvTaskList==============
 * ====================================================================
 */

.taskList {
	-fx-border-width: 1 0 0 0;
	-fx-border-color: lightgrey;
}

.list-view {
  -fx-background-color: white;
  -fx-background-insets: 0;
  -fx-padding: 0px;
}

#cardPane {
    -fx-background-color: white;
    -fx-border-color: lightgrey;
    -fx-border-width: 0 0 2 0;
}

.list-cell {
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
}

.list-cell:empty {
    -fx-background-color: white;
}
 
.cell_index_label {
	-fx-font-size: 16px;
	-fx-font-family: "Roboto Bold";
}

.cell_big_label {
    -fx-font-size: 16px;
    -fx-font-family: "Roboto";
    -fx-text-fill: #212121;
}

.cell_medium_label {
    -fx-font-size: 14px;
    -fx-font-family: "Roboto";
    -fx-text-fill: #757575;
}

.cell_small_label {
    -fx-font-size: 14px;
    -fx-text-fill: #757575;
    -fx-font-family: "Roboto";
}

.circle_label {
	-fx-font-weight: bold;
	-fx-font-size: 16px;
}


/*
 * ====================================================================
 * ===========================Status Bar===============================
 * ====================================================================
 */
 
 .status-bar {
    -fx-background-color: #2e8af7;
    -fx-text-fill: white;
}

.status-bar .label {
    -fx-text-fill: white;
    -fx-font-size: 12px;
}

/*
 * ====================================================================
 * ============================Dialog==================================
 * ====================================================================
 */

.dialog-pane {
    -fx-background-color: white;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: lightgrey;
}

.dialog-pane > *.label.content {
    -fx-font-size: 12px;
    -fx-font-weight: bold;
    -fx-text-fill: #212121;
    -fx-font-family: "Roboto";
}

.dialog-pane:header *.header-panel {
    -fx-background-color: white;
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 12px;
    -fx-font-style: italic;
    -fx-fill: lightgrey;
    -fx-text-fill: #212121;
    -fx-font-family: "Roboto";
}

/*
 * ====================================================================
 * =========================Scroll-Bar=================================
 * ====================================================================
 */

.scroll-bar .thumb {
    -fx-background-color: darkgrey;
    -fx-background-insets: 2;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 5 1 5;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 5 1 5 1;
}

```
