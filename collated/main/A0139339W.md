# A0139339W
###### \java\seedu\address\logic\commands\DoneCommand.java
``` java
/**
 * Set the tasks identified as done using it's last displayed index from the task manager.
 */
public class DoneCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Set the task identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (positive integer) [MORE_INDICES] ... \n"
            + "Example: " + COMMAND_WORD + " 1 3";
 
    public static final String MESSAGE_DONE_TASK_SUCCESS = "Task(s) done: %1$s";
    public static final String MESSAGE_NOT_DONE_TASK_SUCCESS = "Task(s) not done: %1$s";

    private final int[] doneIndices;
    private final int[] notDoneIndices;

    public DoneCommand(int[] doneIndices, int[] notDoneIndices) {
        this.doneIndices = doneIndices;
        this.notDoneIndices = notDoneIndices;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        UnmodifiableObservableList<ReadOnlyTask> fullList = model.getUnfilteredTaskList();

        String doneMessage = changeStatus(lastShownList, fullList, doneIndices, "done");
        String notDoneMessage = changeStatus(lastShownList, fullList, notDoneIndices, "pending");
        
        return new CommandResult(doneMessage + "\n" + notDoneMessage);
    }
    
    private String changeStatus(UnmodifiableObservableList<ReadOnlyTask> lastShownList,
    		UnmodifiableObservableList<ReadOnlyTask> fullList,
    		int[] indices, String status) {
    	
    	assert status.equals("done") || status.equals("pending");
    	model.saveState();
    	
    	ArrayList<ReadOnlyTask> tasksList = new ArrayList<>();
    	Task taskChanged;
        
        for (int i=0; i<indices.length; i++) {
            if (lastShownList.size() < indices[i]) {
                model.loadPreviousState();
        		indicateAttemptToExecuteIncorrectCommand();
                return (Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX 
                		+ " for " + status + " command");
            }

            taskChanged = new Task(lastShownList.get(indices[i] - 1));
            int index = fullList.indexOf(taskChanged);
            taskChanged.setStatus(new Status(status));
            tasksList.add(taskChanged);
        	
            try {
                model.editTask(index, taskChanged);
            } catch (TaskNotFoundException pnfe) {
                model.loadPreviousState();
                assert false : "The target task cannot be missing";
            }
        }
        String successMessage = "";
        if(status.equals("done")) {
            successMessage = String.format(MESSAGE_DONE_TASK_SUCCESS, tasksList);
        } else if(status.equals("pending")) {
            successMessage =  String.format(MESSAGE_NOT_DONE_TASK_SUCCESS, tasksList);
        }
        
        model.checkForOverdueTasks();
        
        return successMessage;
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (positive integer) ['NEW_NAME'] [from hh::mm to hh:mm | by hh: mm] [dd-mm-yy] [done| not-done] \n"
            + "Example: " + COMMAND_WORD + " 1 'chill for the day'";
 
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "Edit will result in duplicate tasks in task manager";


    public final int targetIndex;
    private final Optional<Name> newName;
    private final Optional<LocalDateTime> newStartDateTime;
    private final Optional<LocalDateTime> newEndDateTime;

    /**
     * For editing name of task
     * @throws IllegalValueException 
     */
    public EditCommand(int targetIndex, String name, LocalDateTime startDateTime, LocalDateTime endDateTime)
    		throws IllegalValueException {
        this.targetIndex = targetIndex;
        if(name.equals("")) {
        	this.newName = Optional.empty();
        } else {
        	this.newName = Optional.ofNullable(new Name(name));
        }
        this.newStartDateTime = Optional.ofNullable(startDateTime);
        this.newEndDateTime = Optional.ofNullable(endDateTime);
    }


    @Override
    public CommandResult execute() {
        model.saveState();
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        UnmodifiableObservableList<ReadOnlyTask> fullList = model.getUnfilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            model.loadPreviousState();
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);

        try {
            Task postEdit = new Task(taskToEdit);
            int index = fullList.indexOf(postEdit);
            if(newName.isPresent()) {
        	    postEdit.setName(newName.get());
            }
        	
            if(newStartDateTime.isPresent()) {
                postEdit.setStartDate(newStartDateTime.get());
            }
        	
            if(newEndDateTime.isPresent()) {
                postEdit.setEndDate(newEndDateTime.get());
            }
        	
            if(lastShownList.contains(postEdit)) {
                model.loadPreviousState();
                return new CommandResult(MESSAGE_DUPLICATE_TASK);
            }
        	
            model.editTask(index, postEdit);
            
        } catch (UnsupportedOperationException uoe) {
            model.loadPreviousState();
            return new CommandResult(uoe.getMessage());
        } catch (TaskNotFoundException tnfe) {
            model.loadPreviousState();
            assert false : "The target task cannot be missing";
        }
        
        model.checkForOverdueTasks();
        
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

}
```
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
    private Optional<String> taskType = Optional.empty();
    private Optional<String> doneStatus = Optional.empty();
    
    public ListCommand() {}
    
    public ListCommand(String taskType, String doneStatus) {
    	this.taskType = Optional.ofNullable(taskType);
    	this.doneStatus = Optional.ofNullable(doneStatus);
    }

    @Override
    public CommandResult execute() {
    	Predicate <ReadOnlyTask> taskTypePredicate = null;
    	Predicate <ReadOnlyTask> donePredicate = null;
    	
    	if(taskType.isPresent()) {
    		assert taskType.get().equals("someday") || taskType.get().equals("sd") ||
    				taskType.get().equals("deadline") || taskType.get().equals("dl") ||
    				taskType.get().equals("event") || taskType.get().equals("ev"); 
    		switch(taskType.get()) {
    		case "someday":
    		case "sd":
    			taskTypePredicate = ReadOnlyTaskFilter.isSomedayTask();
    			break;
    		case "deadline":
    		case "dl":
    			taskTypePredicate = ReadOnlyTaskFilter.isDeadlineTask();
    			break;
    		case "event":
    		case "ev":
    			taskTypePredicate = ReadOnlyTaskFilter.isEventTask();
    			break;
    		}
    	}
    	if(doneStatus.isPresent()) {
    		switch(doneStatus.get()) {
    		case "done":
    			donePredicate = ReadOnlyTaskFilter.isDone();
    			break;
    		case "not-done":
    			donePredicate = ReadOnlyTaskFilter.isNotDone();
    			break;
    		case "overdue":
    			donePredicate = ReadOnlyTaskFilter.isOverdue();
    		}
    	}
    	
    	if(doneStatus.isPresent() && taskType.isPresent()) {
    		model.updateFilteredTaskList(taskTypePredicate.and(donePredicate));
    	} else if(!doneStatus.isPresent() && taskType.isPresent()) {
    		model.updateFilteredTaskList(taskTypePredicate);
    	} else if(doneStatus.isPresent() && !taskType.isPresent()) {
    		model.updateFilteredTaskList(donePredicate);
    	} else if(!doneStatus.isPresent() && !taskType.isPresent()) {
    		model.updateFilteredListToShowAll();
    	}
    	
    	model.checkForOverdueTasks();
    	
        return new CommandResult(MESSAGE_SUCCESS);
    }
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * parse the argument based on first occurrence of keyword "not"
	 * indices before not are for tasks to be marked done
	 * indices after not are for tasks to be marked not done
	 * missing keyword "not" means all indices are for tasks to be marked done
	 */
	private Command prepareDone(String arguments) {
		String[] args = arguments.split("not");
		int[] doneIndices = new int[0];
		int[] notDoneIndices = new int[0];
		try {
			if(!args[0].equals("")) {
			    doneIndices = prepareIndexList(args[0]);
			}
			if(args.length > 1) {
				notDoneIndices = prepareIndexList(args[1].trim());
			}
		} catch (IncorrectCommandException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DoneCommand.MESSAGE_USAGE));
		}

		return new DoneCommand(doneIndices, notDoneIndices);
	}


	private int[] prepareIndexList(String arguments) throws IncorrectCommandException{
		ArrayList<Optional<Integer>> indexOptionals = parseIndices(arguments);

		int[] indices = new int[indexOptionals.size()];
		int i = 0;
		for (Optional<Integer> index : indexOptionals) {
			if (!index.isPresent()) {
				throw new IncorrectCommandException("Incorrect Command");
			}
			indices[i] = index.get();
			i++;
		}

		System.out.println("indices: " + Arrays.toString(indices));
		return indices;
	}

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Parses arguments in the context of the edit task command.
	 * Supports editing of task name, start date and time, end date and time.
	 *
	 * @param args
	 *            full command args string
	 *            at least one of the three values are to be edited
	 * @return the prepared EditCommand
	 */
	private Command prepareEdit(String arguments) {
		String index = "";
		String newName = "";
		String newStartDate = "";
		String newEndDate = "";
		
		String[] args = arguments.split(" ");
		System.out.println(arguments);
				
		//if the args[0] is not the index, return IncorrectCommand
		if(!StringUtil.isUnsignedInteger(args[0])) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
		
		index = args[0];

		for(int i=1; i<args.length; i++) {
			System.out.println("args[i]: " + args[i]);
			if(args[i].startsWith("'") && newName.equals("")) {			//only takes the first pair of ' '
				do {
					newName += (args[i] + " ");
				} while(i+1<args.length && !args[i++].endsWith("'"));	//continue adding until the next '
				i--;													//to undo i++ in while loop when while condition fails
				System.out.println("newName: " + newName);
				
			} else if(args[i].equals("from") && newStartDate.equals("")) {	//only takes the first from
				while(++i<args.length &&
						!(args[i].equals("to") ||
						args[i].equals("by") ||
						args[i].equals("from") ||
						args[i].startsWith("'"))) {
					
					newStartDate += (args[i] + " ");
					System.out.println("i is: " + args[i]);
				}
				i--;
				System.out.println("newStartDate: " + newStartDate);
			
			} else if((args[i].equals("to") || args[i].equals("by")) && newEndDate.equals("")) {
				while(++i<args.length &&
						!(args[i].equals("from") ||
						args[i].equals("by") ||
						args[i].equals("to") ||
						args[i].startsWith("'"))) {
					
					newEndDate += (args[i] + " ");
					System.out.println("i is: " + args[i]);
				}
				i--;
				System.out.println("newEndDate: " + newEndDate);
			}
					
		}
		
		// newName while loop might have end at end of array and not '
		newName = newName.trim();
		if(!newName.endsWith("'")) {
			newName = "";
		} else {
			newName = newName.substring(1, newName.length()-1);		//remove the ' '
			newName = newName.trim();
		}
		
		// No values are to be edited
		if(newName.equals("") && newStartDate.equals("") && newEndDate.equals("")) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
		
		
		System.out.println("newName post trim: " + newName);
		LocalDateTime startDateTime = null;
		LocalDateTime endDateTime = null;
		
		
		if(!newStartDate.equals("")) {
			try {
				startDateTime = DateParser.parse(newStartDate);
			} catch (ParseException e) {
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
			}
		}
		
		if(!newEndDate.equals("")) {
			try {
				endDateTime = DateParser.parse(newEndDate);
			} catch (ParseException e) {
				return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
			}
		}
		

		try {
			return new EditCommand(Integer.parseInt(index), newName, startDateTime, endDateTime);
		} catch (NumberFormatException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
	}
	
```
###### \java\seedu\address\model\Model.java
``` java
    /** Returns the unfiltered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getUnfilteredTaskList();
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Predicate<ReadOnlyTask> taskFilter) {
    	filteredTasks.setPredicate(taskFilter);
    }
```
