# A0139339W
###### \java\seedu\address\logic\commands\ChangeStatusCommand.java
``` java
/**
 * Set the tasks identified as done using it's last displayed index from the task manager.
 */
public class ChangeStatusCommand extends Command {

    public static final String COMMAND_WORD_DONE = "done";
    public static final String COMMAND_WORD_PENDING = "pending";

    public static final String MESSAGE_USAGE = COMMAND_WORD_DONE + " or " + COMMAND_WORD_PENDING
            + ": Set the task identified by the index number used in the last task listing as done or pending.\n"
            + "Parameters: INDEX [MORE_INDICES] ... \n"
            + "Example: " + COMMAND_WORD_PENDING + " 1 3";
 
    public static final String MESSAGE_TASK_SUCCESS_DONE = "Task(s) marked as " + COMMAND_WORD_DONE + ": %1$s";
    public static final String MESSAGE_TASK_SUCCESS_PENDING = "Task(s) marked as " + COMMAND_WORD_PENDING + ": %1$s";
    
    private final int[] indices;
    private final String newStatus;

    
    public ChangeStatusCommand(int[] indices, String newStatus) {
        this.indices = indices;
        this.newStatus = newStatus;
    }


    @Override
	public CommandResult execute() {
		UnmodifiableObservableList<ReadOnlyTask> fullList = model.getUnfilteredTaskList();

		model.saveState();
		ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();
		try {
			tasksList = getStatusChangedTasks();
		} catch (IndexOutOfBoundsException iobe) {
			return new CommandResult(iobe.getMessage());
		}

		for(int i = 0; i < tasksList.size(); i++) {
			Task taskChanged = (Task) tasksList.get(i);
			int index = fullList.indexOf(taskChanged);
			taskChanged.setStatus(new Status(newStatus));
			try {
				model.editTask(index, taskChanged);
			} catch (TaskNotFoundException e) {
				model.undoSaveState();
				// TODO create variable of string. compare message to delete command
				return new CommandResult("The task with index " + indices[i] + " cannot be found. Please refresh the list.");
			}
		}

		model.checkForOverdueTasks();
		
		if (newStatus.trim().toLowerCase().equals("done")) {
			return new CommandResult(String.format(MESSAGE_TASK_SUCCESS_DONE, tasksList));
		}
		else {
			return new CommandResult(String.format(MESSAGE_TASK_SUCCESS_PENDING, tasksList));
		}
	}
    
    public ArrayList<ReadOnlyTask> getStatusChangedTasks () 
    		throws IndexOutOfBoundsException {
    	UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
    	ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();
    	for (int i = 0; i < indices.length; i++) {
			if (lastShownList.size() < indices[i]) {
				// TODO avoid save state/loadPrevious in case of incorrect command, 
				// since redo stack will have an element. possibly create model.undoSaveState()
				model.undoSaveState();
				indicateAttemptToExecuteIncorrectCommand();
				throw new IndexOutOfBoundsException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
			}

			Task taskChanged = new Task(lastShownList.get(indices[i] - 1));
			tasksList.add(taskChanged);
		}
    	return tasksList;
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (positive integer) ['NEW_NAME'] [from TIME DATE] [by TIME DATE]\n"
            + "Example: " + COMMAND_WORD + " 1 'chill for the day' from 12am today by 11pm today";
 
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "Edit will result in duplicate tasks in task manager";   
    
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java

    public final int targetIndex;
    private final Optional<Name> newName;
    private final Optional<LocalDateTime> newStartDateTime;
    private final Optional<LocalDateTime> newEndDateTime;
    private final boolean isRemoveStartDateTime;
    private final boolean isRemoveEndDateTime;

    /**
     * For editing name of task
     * @throws IllegalValueException 
     */
    public EditCommand(int targetIndex, Optional<String> name, 
    		Optional<LocalDateTime> newStartDate, Optional<LocalDateTime> newEndDate,
    		boolean isRemoveStartDateTime, boolean isRemoveEndDateTime)
    		throws IllegalValueException {
        this.targetIndex = targetIndex;
        if (name.isPresent()) {
        	newName = Optional.of(new Name(name.get()));
        } else {
        	newName = Optional.empty();
        }
        this.newStartDateTime = newStartDate;
        this.newEndDateTime = newEndDate;
        this.isRemoveStartDateTime = isRemoveStartDateTime;
        this.isRemoveEndDateTime = isRemoveEndDateTime;
    }
    
    @Override
    public CommandResult execute() {
    	
    	EventsCenter.getInstance().post(new DisplayTaskListEvent(model.getFilteredTaskList()));

        model.saveState();
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        UnmodifiableObservableList<ReadOnlyTask> fullList = model.getUnfilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            model.undoSaveState();
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);

        try {
            Task postEdit = new Task(taskToEdit);
            int index = fullList.indexOf(postEdit);
            if (newName.isPresent()) {
        	    postEdit.setName(newName.get());
            }
            
            if (newStartDateTime.isPresent() && !newEndDateTime.isPresent()){
            	LocalDateTime startDateTime = newStartDateTime.get();
            	
            	if (taskToEdit.getEndDate().isPresent()){
            		LocalDateTime endDateTime = taskToEdit.getEndDate().get();
            		
                	if (startDateTime.isAfter(endDateTime)){
                    	return new CommandResult(MESSAGE_START_DATE_TIME_AFTER_END_DATE_TIME);
                	}  
            	}
            }
            
            if (!newStartDateTime.isPresent() && newEndDateTime.isPresent()){
            	LocalDateTime endDateTime = newEndDateTime.get();
            	
            	if (taskToEdit.getStartDate().isPresent()){
            		LocalDateTime startDateTime = taskToEdit.getStartDate().get();
            		
                	if (!endDateTime.isAfter(startDateTime)){
                		return new CommandResult(MESSAGE_START_DATE_TIME_AFTER_END_DATE_TIME);
                	}      
            	}
            }
            
            if (newEndDateTime.isPresent()) {
            	postEdit.setEndDate(newEndDateTime.get());
            }
            
            if (newStartDateTime.isPresent()) {
                postEdit.setStartDate(newStartDateTime.get());
            }
            
            if (isRemoveStartDateTime) {
            	postEdit.removeStartDate();
            }
            
            if (isRemoveEndDateTime) {
            	postEdit.removeEndDate();
            }
        	
            if (lastShownList.contains(postEdit)) {
                model.undoSaveState();
                return new CommandResult(MESSAGE_DUPLICATE_TASK);
            }
        	
            model.editTask(index, postEdit);
            
           
            raiseJumpToTaskEvent(postEdit);

            
        } catch (UnsupportedOperationException uoe) {
            model.undoSaveState();
            return new CommandResult(uoe.getMessage());
        } catch (TaskNotFoundException tnfe) {
            model.undoSaveState();
            assert false : "The target task cannot be missing";
        }
        
        
        model.checkForOverdueTasks();
        
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }
    
```
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
    private Optional<String> taskType = Optional.empty();
    private Optional<String> doneStatus = Optional.empty();
    
    public ListCommand() {}
    
    public ListCommand(String taskType, String doneStatus) {
    	this.taskType = Optional.ofNullable(taskType);
    	this.doneStatus = Optional.ofNullable(doneStatus);
    }

    @Override
    public CommandResult execute() {
    	EventsCenter.getInstance().post(new DisplayTaskListEvent(model.getFilteredTaskList()));
    	
    	Predicate <ReadOnlyTask> taskTypePredicate = null;
    	Predicate <ReadOnlyTask> donePredicate = null;
    	
    	if (taskType.isPresent()) {
    		assert taskType.get().equals("someday") || taskType.get().equals("sd") ||
    				taskType.get().equals("deadline") || taskType.get().equals("dl") ||
    				taskType.get().equals("event") || taskType.get().equals("ev"); 
    		switch(taskType.get()) {
    		case "someday":
    		case "sd":
    			taskTypePredicate = ReadOnlyTaskFilter.isSomedayTask();
    			break;
    		case "deadline":
    		case "dl":
    			taskTypePredicate = ReadOnlyTaskFilter.isDeadlineTask();
    			break;
    		case "event":
    		case "ev":
    			taskTypePredicate = ReadOnlyTaskFilter.isEventTask();
    			break;
    		}
    	}
    	if (doneStatus.isPresent()) {
    		switch(doneStatus.get()) {
    		case "done":
    			donePredicate = ReadOnlyTaskFilter.isDone();
    			break;
    		case "pending":
    			donePredicate = ReadOnlyTaskFilter.isPending();
    			break;
    		case "overdue":
    			donePredicate = ReadOnlyTaskFilter.isOverdue();
    		}
    	}
    	
    	if (doneStatus.isPresent() && taskType.isPresent()) {
    		model.updateFilteredTaskList(taskTypePredicate.and(donePredicate));
    	} else if (!doneStatus.isPresent() && taskType.isPresent()) {
    		model.updateFilteredTaskList(taskTypePredicate);
    	} else if (doneStatus.isPresent() && !taskType.isPresent()) {
    		model.updateFilteredTaskList(donePredicate);
    	} else if (!doneStatus.isPresent() && !taskType.isPresent()) {
    		model.updateFilteredListToShowAll();
    	}
    	
    	model.checkForOverdueTasks();
    	
        return new CommandResult(MESSAGE_SUCCESS);
    }
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private static final Pattern EDIT_ARGS_FORMAT = Pattern.compile(
			"(?<index>\\d+)\\s+(?<editTaskArgs>.+)"); 
	private static final Pattern ADD_ALIAS_COMMAND_FORMAT = Pattern
			.compile("\\s*'(?<alias>(\\s*\\S+)+)\\s*'\\s*=\\s*'(?<originalPhrase>(\\s*\\S+)+)\\s*'\\s*");
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Parses arguments in the context of the edit task command.
	 * Supports editing of task name, start date and time, end date and time.
	 *
	 * @param args
	 *            full command args string
	 *            at least one of the three values are to be edited
	 * @return the prepared EditCommand
	 */
	private Command prepareEdit(String arguments) {
		Matcher matcher = EDIT_ARGS_FORMAT.matcher(arguments);
		if (!matcher.matches()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
		
		int index = Integer.parseInt(matcher.group("index"));
		String editTaskArgs = matcher.group("editTaskArgs");
		
		Optional<String> taskName;
		String args;
		if (editTaskArgs.contains("\'")) {
			Pair<String,String> nameAndArgs = separateNameAndArgs(editTaskArgs);
			taskName = Optional.of(nameAndArgs.getKey());
			args = nameAndArgs.getValue();
		} else {
			taskName = Optional.empty();
			args = editTaskArgs;
		}
		String argsLowerCase = args.toLowerCase();
		
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(
				startDateTimePrefix, endDateTimePrefix, dlEndDateTimePrefix, tagsPrefix);
		
		argsTokenizer.tokenize(argsLowerCase);
		Optional<String> startDateTimeString = argsTokenizer.getValue(startDateTimePrefix);
		Optional<String> endDateTimeString = argsTokenizer.getValue(endDateTimePrefix);
		if (!endDateTimeString.isPresent()) {
			endDateTimeString = argsTokenizer.getValue(dlEndDateTimePrefix);
		}
		Optional<List<String>> tagSet = argsTokenizer.getAllValues(tagsPrefix);
		
		boolean isRemoveStartDateTime = isToRemoveDateTime(startDateTimeString);
		boolean isRemoveEndDateTime = isToRemoveDateTime(endDateTimeString);
		
		Optional<LocalDateTime> startDateTime;
		Optional<LocalDateTime> endDateTime;
		
		try {
			startDateTime = isRemoveStartDateTime ? Optional.empty() : 
				convertToLocalDateTime(startDateTimeString);
			endDateTime = isRemoveEndDateTime ? Optional.empty() : 
				convertToLocalDateTime(endDateTimeString);
		} catch (ParseException e) {
			return new IncorrectCommand(e.getMessage());
		}
		
		try {
			return new EditCommand(index, taskName, startDateTime, endDateTime,
					isRemoveStartDateTime, isRemoveEndDateTime);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * parse the argument based on first occurrence of keyword "not" indices
	 * before not are for tasks to be marked done indices after not are for
	 * tasks to be marked not done missing keyword "not" means all indices are
	 * for tasks to be marked done
	 */
	private Command prepareChangeStatus(String arguments, String newStatus) {
		int[] doneIndices;

		try {
			doneIndices = parseIndices(arguments);
		} catch (IllegalArgumentException e) {
			return new IncorrectCommand(e.getMessage());
		}

		return new ChangeStatusCommand(doneIndices, newStatus);
	}
	
```
###### \java\seedu\address\model\Model.java
``` java
    /** Returns the unfiltered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getUnfilteredTaskList();
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Predicate<ReadOnlyTask> taskFilter) {
    	filteredTasks.setPredicate(taskFilter);
    }
```
###### \java\seedu\address\model\task\Task.java
``` java
    public void removeStartDate() {
    	this.startDate = Optional.empty();
    	this.taskType = new TaskType(Type.DEADLINE);
    }
    
    public void removeEndDate() {
    	if (startDate.isPresent()) {
    		this.endDate = this.startDate;
    		this.startDate = Optional.empty();
    		this.taskType = new TaskType(Type.DEADLINE);
    	} else {
    		this.endDate = Optional.empty();
        	this.taskType = new TaskType(Type.SOMEDAY);
    	}
    	
    }
```
