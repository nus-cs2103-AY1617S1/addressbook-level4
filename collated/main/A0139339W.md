# A0139339W
###### \java\seedu\address\logic\commands\ChangeStatusCommand.java
``` java
/**
 * Set the tasks identified as done using it's last displayed index from the task manager.
 */
public class ChangeStatusCommand extends Command {

    public static final String COMMAND_WORD_DONE = "done";
    public static final String COMMAND_WORD_PENDING = "pending";

    public static final String MESSAGE_USAGE = COMMAND_WORD_DONE + " or " + COMMAND_WORD_PENDING
            + ": Set the task identified by the index number used in the last task listing as done or pending.\n"
            + "Parameters: INDEX [MORE_INDICES]... \n"
            + "Example: " + COMMAND_WORD_PENDING + " 1 3";
 
    public static final String MESSAGE_TASK_SUCCESS_DONE = "Task(s) marked as " + COMMAND_WORD_DONE + ": %1$s";
    public static final String MESSAGE_TASK_SUCCESS_PENDING = "Task(s) marked as " + COMMAND_WORD_PENDING + ": %1$s";
    
    private final int[] indices;
    private final String newStatus;

    
    public ChangeStatusCommand(int[] indices, String newStatus) {
        this.indices = indices;
        this.newStatus = newStatus;
    }


    @Override
	public CommandResult execute() {
    	EventsCenter.getInstance().post(new DisplayTaskListEvent(model.getFilteredTaskList()));

		model.saveState();
		ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();
		try {
			tasksList = getStatusChangedTasks();
			updateStatusChangedTasks(tasksList);
		} catch (IndexOutOfBoundsException iobe) {
			return new CommandResult(iobe.getMessage());
		}
		
		model.checkForOverdueTasks();
		
		if (newStatus.trim().toLowerCase().equals("done")) {
			return new CommandResult(String.format(MESSAGE_TASK_SUCCESS_DONE, tasksList));
		}
		else {
			return new CommandResult(String.format(MESSAGE_TASK_SUCCESS_PENDING, tasksList));
		}
	}
    
    /**
     * Get all the tasks which status will be changed based on int[] indices
     * @return the list of tasks with changed status
     * @throws IndexOutOfBoundsException
     */
    public ArrayList<ReadOnlyTask> getStatusChangedTasks () 
    		throws IndexOutOfBoundsException {
    	UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
    	ArrayList<ReadOnlyTask> tasksList = new ArrayList<ReadOnlyTask>();
    	for (int i = 0; i < indices.length; i++) {
			if (lastShownList.size() < indices[i]) {
				model.undoSaveState();
				indicateAttemptToExecuteIncorrectCommand();
				throw new IndexOutOfBoundsException(Messages.MESSAGE_INVALID_DISPLAYED_INDEX);
			}

			Task taskChanged = new Task(lastShownList.get(indices[i] - 1));
			tasksList.add(taskChanged);
		}
    	return tasksList;
    }
    
    /**
     * Updates the status of all the tasks in @param tasksList
     * @throws IndexOutOfBoundsException
     */
    public void updateStatusChangedTasks (ArrayList<ReadOnlyTask> tasksList) 
    		throws IndexOutOfBoundsException {
    	
    	UnmodifiableObservableList<ReadOnlyTask> fullList = model.getUnfilteredTaskList();
    	for (int i = 0; i < tasksList.size(); i++) {
			Task taskChanged = (Task) tasksList.get(i);
			int index = fullList.indexOf(taskChanged);
			taskChanged.setStatus(new Status(newStatus));
			try {
				model.editTask(index, taskChanged);
			} catch (TaskNotFoundException tnfe) {
				throw new IndexOutOfBoundsException ("The task with index " + indices[i] 
						+ " cannot be found. Please refresh the list.");
			}
		}
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
/**
 * Edits a task identified using it's last displayed index from the task manager.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (positive integer) ['NEW_TASK_NAME'] [from TIME [DATE]] [to | by TIME [DATE]]\n"
            + "Example: " + COMMAND_WORD + " 1 'chill for the day' from 12am today to 11pm today";
 
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "Edit will result in duplicate tasks in task manager";  

    private Task taskToEdit;
    private int internalListIndex;
    
    private final int inputIndex;
    private final Optional<String> name;
    private final Optional<LocalDateTime> newStartDateTime;
    private final Optional<LocalDateTime> newEndDateTime;
    private final Set<String> tags;
    private final boolean isRemoveStartDateTime;
    private final boolean isRemoveEndDateTime;

    /**
     * For editing task corresponding to the internalListIndex
     * @throws IllegalValueException when name or tagName contain illegal values
     */
    public EditCommand(int inputIndex, Optional<String> name, Optional<LocalDateTime> newStartDate, 
                       Optional<LocalDateTime> newEndDate, Set<String> tags, boolean isRemoveStartDateTime, 
                       boolean isRemoveEndDateTime) throws IllegalValueException {
    	
    	this.inputIndex = inputIndex;
    	this.name = name;
    	this.newStartDateTime = newStartDate;
    	this.newEndDateTime = newEndDate;
    	this.tags = tags;
    	this.isRemoveStartDateTime = isRemoveStartDateTime;
    	this.isRemoveEndDateTime = isRemoveEndDateTime;
    }
    
    @Override
    public CommandResult execute() {
    	
    	doExecuteSetUp();
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
		
    	try {
			checkValidIndex(lastShownList);
			this.taskToEdit = getTaskToEdit(lastShownList);
			validateEndDateTimeAfterStartDateTime();
			
			this.internalListIndex = getIndexInInternalList(taskToEdit);
			this.setTaskToEditName();
			this.setTaskToEditDates();
			this.setTaskToEditTags();
			
			this.checkNotDuplicateTask(lastShownList);
			model.editTask(internalListIndex, taskToEdit);
		} catch (IllegalValueException ive) {
			model.undoSaveState();
			return new CommandResult(ive.getMessage());
		} catch (TaskNotFoundException tnfe) {
			model.undoSaveState();
			return new CommandResult(tnfe.getMessage());
		}
            
        raiseJumpToTaskEvent(taskToEdit);

        model.checkForOverdueTasks();
        
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }
    
    /**
     * Set up for the execute
     */
    private void doExecuteSetUp() {
    	EventsCenter.getInstance().post(new DisplayTaskListEvent(model.getFilteredTaskList()));
        model.saveState();
    }
    /**
     * Checks that the taskToEdit is not a duplicate task after updating all the edits
     * @throws IllegalValueException if it is a duplicate
     */
    private void checkNotDuplicateTask(UnmodifiableObservableList<ReadOnlyTask> lastShownList) 
    		throws IllegalValueException{
    	if (lastShownList.contains(taskToEdit)) {
            throw new IllegalValueException(MESSAGE_DUPLICATE_TASK);
        }
    }
    
    /**
     * Checks that the inputIndex is within boundary of lastShownList 
     * @throws IllegalValueException when inputIndex is out of bound
     */
    private void checkValidIndex(UnmodifiableObservableList<ReadOnlyTask> lastShownList) 
    	throws IllegalValueException {
    	if (lastShownList.size() < inputIndex) {
            model.undoSaveState();
            indicateAttemptToExecuteIncorrectCommand();
            throw new IllegalValueException(Messages.MESSAGE_INVALID_DISPLAYED_INDEX);
        }
    }
    
    /**
     * Get the index of @param task in the TaskManager internalList
     */
    private int getIndexInInternalList (Task task) {
    	UnmodifiableObservableList<ReadOnlyTask> fullList = model.getUnfilteredTaskList();
    	return fullList.indexOf(task);
    }
    
    /**
     * Get the targeted Task to be edited
     */
    private Task getTaskToEdit(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
    	return new Task(lastShownList.get(inputIndex - 1));
    }
    
    /**
     * Update taskToEdit with the new name
     * @throws IllegalValueException if name content is of illegal value
     */
    private void setTaskToEditName() throws IllegalValueException {
    	if (name.isPresent()) {
    	    Name newName = new Name(name.get());
    		taskToEdit.setName(newName);
        }
    }
    
    /**
     * Updates taskToEdit with the new start date and end date
     */
    private void setTaskToEditDates() {
    	if (newEndDateTime.isPresent()) {
        	taskToEdit.setEndDate(newEndDateTime.get());
        }
        
        if (newStartDateTime.isPresent()) {
            taskToEdit.setStartDate(newStartDateTime.get());
        }
        
        if (isRemoveStartDateTime) {
        	taskToEdit.removeStartDate();
        }
        
        if (isRemoveEndDateTime) {
        	taskToEdit.removeEndDate();
        }
    }
    
    /**
     * Update taskToEdit with the new tags
     * @throws IllegalValueException 
     */
    private void setTaskToEditTags () throws IllegalValueException {
    	final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
        	tagSet.add(new Tag(tagName));
        }
        
        UniqueTagList tagList = new UniqueTagList(tagSet);
        UniqueTagList newTags = this.taskToEdit.getTags();
        newTags.mergeFrom(tagList);
        this.taskToEdit.setTags(newTags);
    }
```
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
/**
 * Lists tasks in the task manager to the user according to the specified filter.
 */
public class ListCommand extends Command {

	private static final Logger logger = LogsCenter.getLogger(ListCommand.class.getName());
	public static final String COMMAND_WORD = "list";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists all tasks filtered by specified parameters\n"
            + "Event Parameters: [TASK_TYPE] [STATUS] [DAY]\n"
            + "Event Example: " + COMMAND_WORD
            + " someday pending 08-11-16\n";  
    
    public static final String MESSAGE_SUCCESS = "Listed all tasks.\n";

    private Optional<String> taskType = Optional.empty();
    private Optional<String> doneStatus = Optional.of("default");
    private Optional<LocalDateTime> day = Optional.empty();
    
    private Predicate<ReadOnlyTask> listPredicate = null;
    private boolean isFirstPredicate = true;
    
    public ListCommand() {}
    
    public ListCommand(String taskType, String doneStatus, LocalDateTime day) {
    	this.taskType = Optional.ofNullable(taskType);
    	this.doneStatus = Optional.ofNullable(doneStatus);
    	this.day = Optional.ofNullable(day);
    }

    @Override
    public CommandResult execute() {
    	EventsCenter.getInstance().post(new DisplayTaskListEvent(model.getFilteredTaskList()));
    	
    	listPredicateUpdateTaskType();
    	listPredicateUpdateStatus();
    	listPredicateUpdateDay();
    	logger.log(Level.INFO, "Updating filteredTaskList with listPredicate");
    	model.updateFilteredTaskList(listPredicate);
    	model.checkForOverdueTasks();
    	
        return new CommandResult(MESSAGE_SUCCESS);
    }

    
    /**
     * update the global listPredicate for the day to be listed
     */
    private void listPredicateUpdateDay() {
    	Predicate<ReadOnlyTask> dayPredicate = null;
    	if(day.isPresent()) {
    		dayPredicate = ReadOnlyTaskFilter.isThisDate(day.get().toLocalDate());
    		logger.log(Level.FINE, "dayPredicate is set");
    		listPredicate = isFirstPredicate ?
    				dayPredicate : listPredicate.and(dayPredicate);
    		isFirstPredicate = false;
    	}
    }

	/**
	 * update the global listPredicate based on the specified status to be listed if any
	 */
    private void listPredicateUpdateStatus() {
    	Predicate<ReadOnlyTask> statusPredicate = null;
    	if(doneStatus.isPresent()) {
			assert doneStatus.get().equals("done") || doneStatus.get().equals("pending") || 
				doneStatus.get().equals("overdue") || doneStatus.get().equals("default");
    		switch(doneStatus.get()) {
    		case "done":
    			statusPredicate = ReadOnlyTaskFilter.isDone();
    			break;
    		case "pending":
    			statusPredicate = ReadOnlyTaskFilter.isPending();
    			break;
    		case "overdue":
    			statusPredicate = ReadOnlyTaskFilter.isOverdue();
    			break;
    		case "default":
    			statusPredicate = ReadOnlyTaskFilter.isDone().negate();
    		}
    		logger.log(Level.FINE, "statusPredicate is set");
    		listPredicate = isFirstPredicate ? 
    				statusPredicate : listPredicate.and(statusPredicate);
    		isFirstPredicate = false;
    	}
	}

	/**
	 * Update the global listPredicate for what kind of task list should display 
	 */
    private void listPredicateUpdateTaskType() {
		Predicate<ReadOnlyTask> taskTypePredicate = null;
    	if(taskType.isPresent()) {
    		assert taskType.get().equals("someday") || taskType.get().equals("sd") ||
    				taskType.get().equals("deadline") || taskType.get().equals("dl") ||
    				taskType.get().equals("event") || taskType.get().equals("ev"); 
    		switch(taskType.get()) {
    		case "someday":
    		case "sd":
    			taskTypePredicate = ReadOnlyTaskFilter.isSomedayTask();
    			break;
    		case "deadline":
    		case "dl":
    			taskTypePredicate = ReadOnlyTaskFilter.isDeadlineTask();
    			break;
    		case "event":
    		case "ev":
    			taskTypePredicate = ReadOnlyTaskFilter.isEventTask();
    			break;
    		}
    		logger.log(Level.FINE, "taskTypePredicate is set");
        	listPredicate = isFirstPredicate ? 
    				taskTypePredicate : listPredicate.and(taskTypePredicate);
    		isFirstPredicate = false;

    	}
	}
}

```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    /**
     * Parse the arguments into taskType, status and date
     */
    private Command prepareList(String arguments) {
		// Empty arguments return ListCommand without parameters
    	if (arguments.trim().equals("")) {
			return new ListCommand();
		}
		// Check if input arguments is valid for ListCommand
		String[] args = arguments.split(" ");
		if(!isValidListArguments(args)) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
					ListCommand.MESSAGE_USAGE));
		}

		String taskType;
		String status;
		String dateString;
		LocalDateTime date;

		try {
			taskType = getTaskTypeForPrepareList(args);
			status = getStatusForPrepareList(args);
			dateString = getDateForPrepareList(args);
			date = convertOptionalToLocalDateTime(
					Optional.ofNullable(dateString)).orElse(null);
		} catch(IllegalArgumentException iae) {
			return new IncorrectCommand(iae.getMessage());
		} catch (ParseException pe) {
			return new IncorrectCommand(pe.getMessage());
		}
		
		return new ListCommand(taskType, status, date);
	}
    /**
     * To check if the list argument is valid
     * @return true if valid, false otherwise
     */
    private boolean isValidListArguments(String[] args) {
    	for(int i = 0; i < args.length; i++) {
    		if(!DateParser.containsDate(args[i] + " 00:00")) {
    			switch(args[i].trim()) {
    			case "event":
    			case "ev":
    			case "deadline":
    			case "dl":
    			case "someday":
    			case "sd":
    			case "done":
    			case "pending":
    			case "overdue":
    			case "all":
    				break;
    			default:
    				return false;
    			}
    		}
    	}
    	return true;
    }
	/**
	 * Get the string for the dates for prepareList
	 * @throws IllegalArgumentException when multiple dates declared
	 */
	private String getDateForPrepareList(String[] args) throws IllegalArgumentException {
		int numDates = 0;
		String date = null;
		for(int i = 0; i < args.length; i++) {
			if(DateParser.containsDate(args[i] + " 00:00")) {
				date = args[i] + " 00:00";
				numDates++;
			}
		}
		if(numDates > 1) {
			throw new IllegalArgumentException("More than one date entered");
		}
		return date;
	}
	/**
	 * Get the string for the task type for prepareList
	 * @throws IllegalArgumentException when multiple task type declared
	 */
	private String getTaskTypeForPrepareList(String[] args) throws IllegalArgumentException {
		int numTaskType = 0;
		String taskType = null;
		for(int i = 0; i < args.length; i++) {
			switch (args[i].trim()) {
			case "event":
			case "ev":
			case "deadline":
			case "dl":
			case "someday":
			case "sd":
				taskType = args[i];
				numTaskType++;
			}
		}
		if(numTaskType > 1)
			throw new IllegalArgumentException("More than one task type entered");
		return taskType;
	}
	/**
	 * Get the string for the status of the task for prepareList
	 * @throws IllegalArgumentException when multiple status declared
	 */
	private String getStatusForPrepareList(String[] args) throws IllegalArgumentException {
		int numStatus = 0;
		String status = null;
		for(int i = 0; i < args.length; i++) {
			switch (args[i].trim()) {
			case "done":
			case "pending":
			case "overdue":
				status = args[i];
				numStatus++;
			}
		}
		if(numStatus > 1)
			throw new IllegalArgumentException("More than one status entered");
		return status;
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	/**
	 * Parses arguments in the context of the edit task command.
	 * Supports editing of task name, start date and time, end date and time, tags.
	 *
	 * @param arguments
	 *            full command arguments string
	 *            at least one of the four values are to be edited
	 * @return the prepared EditCommand
	 */
	private Command prepareEdit(String arguments) {
		int index;
		try{
		    index = getIndex(arguments);
		} catch (IllegalArgumentException e) {
			return new IncorrectCommand(e.getMessage());
		}
		
		Optional<String> taskNameWithoutQuotes = Optional.ofNullable(getTaskName(arguments));
		// To exclude the quoted name from the arguments
		String editArgs = StringUtil.getNonQuotedText(arguments);
		List<String> datesAndTags = getDatesAndTags(editArgs);
		
		// To get the tagSet to be added to the task
		Set<String> tagSet = getTagSetFromDatesAndTags(datesAndTags);
		
		Optional<LocalDateTime> startDateTime;
		Optional<LocalDateTime> endDateTime;
		
		Optional<String> startDateTimeString = Optional.ofNullable(datesAndTags.get(0));
		Optional<String> endDateTimeString = Optional.ofNullable(datesAndTags.get(1));
		// To obtain whether start date or end date is to be removed
		boolean isRemoveStartDateTime = isToRemoveDateTime(startDateTimeString);
		boolean isRemoveEndDateTime = isToRemoveDateTime(endDateTimeString);
		// To obtain the Optional<LocalDateTime> startDateTime and endDateTime
		try {
			startDateTime = isRemoveStartDateTime ? Optional.empty() : 
				convertOptionalToLocalDateTime(startDateTimeString);
			endDateTime = isRemoveEndDateTime ? Optional.empty() : 
				convertOptionalToLocalDateTime(endDateTimeString);
		} catch (ParseException e) {
			return new IncorrectCommand(e.getMessage());
		}
		
		try {
			return new EditCommand(index, taskNameWithoutQuotes, startDateTime, endDateTime, tagSet,
					isRemoveStartDateTime, isRemoveEndDateTime);
		} catch (IllegalValueException e) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
	}
	
	/**
	 * Get the list of tags in datesAndTags
	 * @param datesAndTags contains tags from index 2 onwards
	 * @return
	 */
	private Set<String> getTagSetFromDatesAndTags(List<String> datesAndTags) {
		List<String> tagList = datesAndTags.subList(2, datesAndTags.size());
		Set<String> tagSet = toSet(Optional.ofNullable(tagList));
		return tagSet;
	}
	
	/**
	 * To get the index of the arguments
	 * @param arguments should contain index at the head
	 * @return only the first index retrieved is returned
	 * @throws IllegalArgumentException when index in the arguments is not unsigned integer
	 */
	private int getIndex(String arguments) throws IllegalArgumentException {
		String indexString = arguments.split(" ", 2)[0];
		int index = parseIndices(indexString)[0];
		return index;
	}
	
	/**
	 * To get the task name in the arguments using the ' '
	 * @return the task name without the ' ' if it exists and null otherwise
	 */
	private String getTaskName(String arguments) {
		String nameInQuotes = StringUtil.getQuotedText(arguments);
		String nameInNoQuotes = nameInQuotes.equals("") ? null :
			StringUtil.removeFirstAndLastChars(nameInQuotes);
		return nameInNoQuotes;
	}
	
	/**
	 * Parse the arguments into start date, end date and tags
	 * @return a list of strings with
	 *     index 0 as the start date
	 *     index 1 as the end date
	 *     the rest of the list as the tags
	 */
	private List<String> getDatesAndTags(String arguments) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(
				startDateTimePrefix, endDateTimePrefix, dlEndDateTimePrefix, tagsPrefix);
		argsTokenizer.tokenize(arguments);
		Optional<String> startDateTimeString = argsTokenizer.getValue(startDateTimePrefix);
		Optional<String> endDateTimeString = argsTokenizer.getValue(endDateTimePrefix);
		if (!endDateTimeString.isPresent()) {
			endDateTimeString = argsTokenizer.getValue(dlEndDateTimePrefix);
		}
		Optional<List<String>> tagSet = argsTokenizer.getAllValues(tagsPrefix);
		List<String> datesAndTags = new ArrayList<String>();
		datesAndTags.add(startDateTimeString.orElse(null));
		datesAndTags.add(endDateTimeString.orElse(null));
		datesAndTags.addAll(tagSet.orElse(Collections.emptyList()));
		return datesAndTags;
	}
	
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
	private Optional<LocalDateTime> convertOptionalToLocalDateTime(Optional<String> dateTimeString) 
		throws ParseException {
		Optional<LocalDateTime> dateTime = Optional.empty();
		if (dateTimeString.isPresent()) {
			dateTime = Optional.of(DateParser.parse(dateTimeString.get()));
		} 
		return dateTime;
	}
	
	private boolean isToRemoveDateTime (Optional<String> dateTimeString) {
		if (dateTimeString.isPresent()) {
			if (dateTimeString.get().equals("-")) {
				return true;
			}
		}
		return false;
	}

	/**
	 * parse the arguments into indices for ChangeStatusCommand
	 */
	private Command prepareChangeStatus(String arguments, String newStatus) {
		int[] doneIndices;

		try {
			doneIndices = parseIndices(arguments);
		} catch (IllegalArgumentException e) {
			return new IncorrectCommand(e.getMessage());
		}

		return new ChangeStatusCommand(doneIndices, newStatus);
	}
	
```
###### \java\seedu\address\model\Model.java
``` java
    /** Returns the unfiltered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getUnfilteredTaskList();
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Predicate<ReadOnlyTask> taskFilter) {
    	filteredTasks.setPredicate(taskFilter);
    }
```
###### \java\seedu\address\model\task\ReadOnlyTaskFilter.java
``` java
	public static Predicate<ReadOnlyTask> isThisDate(LocalDate date) {
		return p -> p.getTaskType().isEventTask() &&
				    p.getStartDate().get().toLocalDate().equals(date) ||
				    !p.getTaskType().isSomedayTask() &&
				    p.getEndDate().get().toLocalDate().equals(date);
	}
```
###### \java\seedu\address\model\task\Task.java
``` java
    public void removeStartDate() {
    	this.startDate = Optional.empty();
    	this.taskType = new TaskType(Type.DEADLINE);
    }
    
    public void removeEndDate() {
    	if (startDate.isPresent()) {
    		this.endDate = this.startDate;
    		this.startDate = Optional.empty();
    		this.taskType = new TaskType(Type.DEADLINE);
    	} else {
    		this.endDate = Optional.empty();
        	this.taskType = new TaskType(Type.SOMEDAY);
    	}
    	
    }
    
```
