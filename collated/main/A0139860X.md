# A0139860X
###### \java\seedu\task\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the list task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareList(String args) {
        final Matcher matcher = TASK_LIST_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ListCommand.MESSAGE_USAGE));
        }

        return new ListCommand(matcher.group("Modifier"));
    }

}
```
###### \java\seedu\task\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(String operand, Set<String> keywords) throws IllegalValueException{
        switch (operand) {
        case "pr/":
            updateFilteredTaskList(new PredicateExpression(new PriorityQualifier(keywords)));
            break;
        case "t/":
            updateFilteredTaskList(new PredicateExpression(new TagQualifier(keywords)));
            break;
        case "st/":
            updateFilteredTaskList(new PredicateExpression(new TimeQualifier("start", keywords)));
            break;
        case "ed/":
            updateFilteredTaskList(new PredicateExpression(new TimeQualifier("end", keywords)));
            break;
        default:
            updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
        }
    }

    //@@ author
    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getDescription().fullDescription, keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### \java\seedu\task\model\ModelManager.java
``` java
    private class TagQualifier implements Qualifier {
        private final Set<Tag> tags = new HashSet<>();

        TagQualifier(Set<String> tags) throws IllegalValueException {
            for(String tag : tags) {
                this.tags.add(new Tag(tag));
            };
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            final Set<Tag> taskTags = new HashSet<>();
            for(Tag tag : task.getTags()) {
                taskTags.add(tag);
            }
            return !Collections.disjoint(taskTags, tags);
        }

        @Override
        public String toString() {
            final StringBuffer buffer = new StringBuffer("tag=");
            final String separator = ", ";
            tags.forEach(tag -> buffer.append(tag).append(separator));
            if (buffer.length() == 0) {
                return "";
            } else {
                return buffer.substring(0, buffer.length() - separator.length());
            }
        }
    }

    private class PriorityQualifier implements Qualifier {
        private Set<Priority> priorities = new HashSet<Priority>();

        PriorityQualifier(Set<String> priorities) throws IllegalValueException {
            for (String priority: priorities) {
                this.priorities.add(new Priority(priority));
            }
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return priorities.contains(task.getPriority());
        }

        @Override
        public String toString() {
            final StringBuffer buffer = new StringBuffer("priority=");
            final String separator = ", ";
            priorities.forEach(tag -> buffer.append(tag).append(separator));
            if (buffer.length() == 0) {
                return "";
            } else {
                return buffer.substring(0, buffer.length() - separator.length());
            }
        }
    }

    private class TimeQualifier implements Qualifier {
        private Time time;
        private String arg;

        TimeQualifier(String arg, Set<String> time) throws IllegalValueException {
            StringBuilder input = new StringBuilder();
            for (String argIn: time) {
                input.append(argIn);
            }
            this.time = new Time(input.toString());
            this.arg = arg;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            // TODO: Implement floating task search
            switch (arg) {
            case "start":
                return time.isBefore(task.getTimeStart());
            case "end":
                return task.getTimeEnd().isBefore(time);
            default:
                return false;
            }
        }

        @Override
        public String toString() {
            return "time=" + time.toString();
        }
    }
    
    //=========== Sorted Task List Accessors ===============================================================
  
    @Override
    public void sortFilteredTaskList(String modifier) {
        switch (modifier) {
        case "-st":
            sortedTasks.setComparator(new StTimeComparator());
            break;
        case "-ed":
            sortedTasks.setComparator(new EdTimeComparator());        
            break;
        case "-pr":
            sortedTasks.setComparator(new PrTimeComparator());
            break;
        default:
            sortedTasks.setComparator(null);
            break;
        }
        
    }
 
    //========== Inner classes/interfaces used for filtering =================================================
    
    private class StTimeComparator implements Comparator<Task> {
        
        @Override
        public int compare(Task o1, Task o2) {
            if (o1.getTimeStart().isBefore(o2.getTimeStart())) {
                return -1;
            }
            else if (o2.getTimeStart().isBefore(o1.getTimeStart())) {
                return 1;
            }
            else if (o1.getTimeStart().equals(o2.getTimeEnd())) {
                return 0;
            }
            else if (o1.getTimeStart() == null && o2.getTimeStart()!= null) {
                return 1;
            }
            else if (o1.getTimeStart() != null && o2.getTimeStart() == null) {
                return -1;
            }
            else {
                return 1;
            }
            
        }
        
    }
    
    private class EdTimeComparator implements Comparator<Task> {
        
        @Override
        public int compare(Task o1, Task o2) {
            if (o1.getTimeEnd().isBefore(o2.getTimeEnd())) {
                return -1;
            }
            else if (o2.getTimeEnd().isBefore(o1.getTimeEnd())) {
                return 1;
            }
            else if (o1.getTimeEnd().equals(o2.getTimeEnd())) {
                return 0;
            }
            else if (o1.getTimeEnd() == null && o2.getTimeEnd()!= null) {
                return 1;
            }
            else if (o1.getTimeEnd() != null && o2.getTimeEnd() == null) {
                return -1;
            }
            else {
                return 1;
            }
            
        }
        
    }

    private class PrTimeComparator implements Comparator<Task> {
    
        @Override
        public int compare(Task o1, Task o2) {
            if (o1.hasHigherPriorityThan(o2)) {
                return -1;
            }
            else if (o1.hasLowerPriorityThan(o2)) {
                return 1;
            }
            else {
                return 0;
            }
            
        }
    
    }
    
}
```
###### \java\seedu\task\model\task\Priority.java
``` java
    public static final String MESSAGE_PRIORITY_CONSTRAINTS =
            "Default priority is normal, otherwise it should be high or low";

    private final Integer value;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given task priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        if(priority.equals(""))
        	priority = "normal";
        else if (!isValidPriority(priority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
        switch (priority) {
        case "high":
            value = 3;
            break;
        case "low":
            value = 1;
            break;
        default:
            value = 2;
            break;
        }
    }

    /**
     * Returns if a given string is a valid priority.
     * Priority only has high or low
     */
    public static boolean isValidPriority(String test) {
        return test.equals("high")
               || test.equals("low")
               || test.equals("normal")
               || test.equals("NOUPDATE");
    }
    
    public boolean isRankedHigher(Priority priority) {
        return value > priority.value;
    }
    
    public boolean isRankedLower(Priority priority) {
        return value < priority.value;
    }

    @Override
    public String toString() {
        switch (value) {
        case 1:
            return "low";
        case 3:
            return "high";
        default:
            return "normal";
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                && this.value.equals(((Priority) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\task\model\task\Time.java
``` java
    public static final String MESSAGE_TIME_CONSTRAINTS =
            "Time parameters should be in the given order: \"DayOfWeek, Date, Time\"\n"
          + "Parameter formats:\n"
          + "\tDayOfWeek: thursday, Thursday, THURSDAY, thu, Thur, THURS\n"
          + "\t\t    Date: 01.01.2011, 1.1.2011\n"
          + "\t\t    Time: 9:11, 09:11\n"
          + "You need at least one parameter to specify the time.\n"
          + "DayOfWeek is ignored if Date is specified.";
    public static final String TIME_VALIDATION_REGEX = "^\\s*$" // Empty String
            + "|^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$" // 24H Time
            // Day Of Week and Optional 24H Time
            + "|^(?i)(mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?|sun)(day)?"
            + "(,? ([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])?$"
            // Day of Week (Opt), Date and 24H Time (Opt)
            + "|^((?i)(mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?|sun)(day)?,? )?"
            + "([1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]).([1-9]|0[1-9]|1[0-2]).2\\d{3}"
            + "(,? ([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9])?$";


    private LocalDateTime value;

    //public String value;

    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given time is invalid.
     */
    public Time(String time) throws IllegalValueException {
        assert time != null;
        time = time.trim();
        if (!isValidTime(time)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }

        final Pattern DATETIME24H_FORMAT = Pattern.compile("^((?i)(mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?|sun)(day)?,? )?"
                                                            + "(?<Day>[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]).(?<Month>[1-9]|0[1-9]|1[0-2]).(?<Year>2\\d{3})"
                                                            + ",? (?<Hour>[0-9]|0[0-9]|1[0-9]|2[0-3]):(?<Minute>[0-5][0-9])$");
        final Pattern DAYTIME24H_FORMAT = Pattern.compile("(?i)((?<Day>(mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?|sun)(day)?)),? "
                                                        + "(?<Hour>([0-9]|0[0-9]|1[0-9]|2[0-3])):(?<Minute>[0-5][0-9])");
        final Pattern TIME24H_FORMAT = Pattern.compile("(?<Hour>[0-9]|0[0-9]|1[0-9]|2[0-3]):(?<Minute>[0-5][0-9])");
        final Pattern DAY_FORMAT = Pattern.compile("(?i)(?<Day>(mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?|sun)(day)?)");
        final Pattern DATE_FORMAT = Pattern.compile("^((?i)(mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?|sun)(day)?,? )?"
                                                  + "(?<Day>([1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])).(?<Month>([1-9]|0[1-9]|1[0-2])).(?<Year>2\\d{3})$");

        final Matcher matcher_DATETIME24H = DATETIME24H_FORMAT.matcher(time);
        final Matcher matcher_DAYTIME24H = DAYTIME24H_FORMAT.matcher(time);
        final Matcher matcher_TIME24H = TIME24H_FORMAT.matcher(time);
        final Matcher matcher_DAY = DAY_FORMAT.matcher(time);
        final Matcher matcher_DATE = DATE_FORMAT.matcher(time);

        
        if (matcher_DATETIME24H.matches()) {
            Integer day = Integer.parseInt(matcher_DATETIME24H.group("Day"));
            Integer month = Integer.parseInt(matcher_DATETIME24H.group("Month"));
            Integer year = Integer.parseInt(matcher_DATETIME24H.group("Year"));
            Integer hour = Integer.parseInt(matcher_DATETIME24H.group("Hour"));
            Integer minute = Integer.parseInt(matcher_DATETIME24H.group("Minute"));
            this.value = LocalDateTime.of(year, month, day, hour, minute);
        }
        
        if (matcher_DATE.matches()) {
            Integer day = Integer.parseInt(matcher_DATE.group("Day"));
            Integer month = Integer.parseInt(matcher_DATE.group("Month"));
            Integer year = Integer.parseInt(matcher_DATE.group("Year"));
            this.value = LocalDateTime.of(year, month, day, 0, 0);
        }

        else if (matcher_DAYTIME24H.matches()) {
            DayOfWeek dayEnum = convertToDayEnum(matcher_DAYTIME24H.group("Day"));
            Integer hour = Integer.parseInt(matcher_DAYTIME24H.group("Hour"));
            Integer minute = Integer.parseInt(matcher_DAYTIME24H.group("Minute"));
            LocalDateTime input = LocalDateTime.of(LocalDate.now(), LocalTime.of(hour, minute));
            this.value = input.with((input.isBefore(LocalDateTime.now())) ? TemporalAdjusters.next(dayEnum)
                                                                          : TemporalAdjusters.nextOrSame(dayEnum));
        }

        else if (matcher_DAY.matches()) {
            DayOfWeek dayEnum = convertToDayEnum(matcher_DAY.group("Day"));
            this.value = LocalDateTime.now().with(TemporalAdjusters.next(dayEnum));
        }

        else if (matcher_TIME24H.matches()) {

    	   Integer hour = Integer.parseInt(matcher_TIME24H.group("Hour"));
    	   Integer minute = Integer.parseInt(matcher_TIME24H.group("Minute"));
    	   this.value = LocalDateTime.of(LocalDate.now(), LocalTime.of(hour, minute));
       }


    }

    public boolean isBefore(Time other) {
    	if (this.value == null || other.value == null)
    		return false;

    	if (this.value.isBefore(other.value))
    		return true;

		return false;
    }

    /**
     * Returns if a given string is a valid task time.
     */
    public static boolean isValidTime(String test) {
        return test.matches(TIME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return (value != null) ? value.getDayOfWeek().toString() 
                + ", " + value.toLocalDate().format(DateTimeFormatter.ofPattern("dd.MM.YYYY"))
                + " " + value.toLocalTime().format(DateTimeFormatter.ofPattern("HH:mm"))
        		: "";
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Time // instanceof handles nulls
                && (this.value != null) ? this.value.equals(((Time) other).value) // state check
                        : ((Time) other).value == null);
    }

    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    
    private DayOfWeek convertToDayEnum(String day) {
    	assert day != null;
    	switch (day.toLowerCase().substring(0, Math.min(day.length(), 3))) {
		case "sun":
			return DayOfWeek.SUNDAY;
		case "mon":
			return DayOfWeek.MONDAY;
		case "tue":
			return DayOfWeek.TUESDAY;
		case "wed":
			return DayOfWeek.WEDNESDAY;
		case "thu":
			return DayOfWeek.THURSDAY;
		case "fri":
			return DayOfWeek.FRIDAY;
		case "sat":
			return DayOfWeek.SATURDAY;
		}
		return null;

    }

}
```
