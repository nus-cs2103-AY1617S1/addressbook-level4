# A0138993L
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
 * Adds a task to the task book.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a to-do task to Simply. "
            + "Parameters: Task details #tag #...."
            + "                                                "
            + " Example: " + COMMAND_WORD
            + " go swimming #IMPT\n" + COMMAND_WORD + ": Adds a deadline task to Simply. "
            + "Parameters: Task details; date; end time #tag #...."
            + "                   "
            + "Example: " + COMMAND_WORD
            + " report; 120516; 1200 #LIFE\n" + COMMAND_WORD + ": Adds a event task to Simply. "
            + "Parameters: [Task details; date; start time; end time] #tag #..."
            + "      "
            + "Example: " + COMMAND_WORD
            + " [siloso beach party; 120716; 1600; 2200] #YOLO #party";

    public static final String EVENT_SUCCESS = "New event added: %1$s";
    public static final String DEADLINE_SUCCESS = "New deadline added: %1$s";
    public static final String TODO_SUCCESS = "New todo added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Simply";
    public static final String END_TIME_BEFORE_START_TIME_MESSAGE = "The end time cannot be earlier or equal to the start time!";
    public static final String START_TIME_BEFORE_END_TIME_MESSAGE = "The start time cannot be later or equal to the end time!";
    
    private final Task toAdd;
    private static int overdue=0;

    /**
     * Convenience constructor using raw values.
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String date, String start, String end, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(date),
                new Start(start),
                new End(end),
                1,
                0,
                false,
                new UniqueTagList(tagSet)
        );
        if (!startBeforeEnd(toAdd.getStart().toString(), toAdd.getEnd().toString())) {
        	throw new IllegalValueException(END_TIME_BEFORE_START_TIME_MESSAGE);
        }
        if (this.toAdd.getOverdue()==1) {
        	overdue =1;
        }
    }   
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
    public AddCommand(String name, String date, String end, Set<String> tags) //deadline
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(date),
                new Start("no start"),
                new End(end),
                2,
                0,
                false,
                new UniqueTagList(tagSet)
        );
        if (this.toAdd.getOverdue()==1) {
        	overdue =1;
        }
    }
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
    public AddCommand(String name, Set<String> tags) //todos
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date("no date"),
                new Start("no start"),
                new End("no end"),
                3,
                0,
                false,
                new UniqueTagList(tagSet)
        );
    }
    
    public static int getOverdue() {
    	return overdue;
    }
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
    private boolean startBeforeEnd(String start, String end) {
		LocalTime start_time = LocalTime.of(Integer.parseInt(start.substring(0,2)), Integer.parseInt(start.substring(2, 4)));
		LocalTime end_time = LocalTime.of(Integer.parseInt(end.substring(0,2)), Integer.parseInt(end.substring(2, 4)));
		if (start_time.isBefore(end_time)) {
			return true;
		} else {
			return false;
		}
	}

    @Override
    public CommandResult execute() {
        assert model != null;
        model.addToUndoStack();
        
        dumpRedoStack();
        model.getCommandHistory().add("add");
        
        try {
            model.addTask(toAdd);
            return addAndSelectTaskToCorrectLIst(toAdd);

        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }
    /**
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
     * Adds and selects the Task when added into Simply
     * @param toAdd the tasks added
     * @return the command Result whether it is a event, deadline or todo
     */
    private CommandResult addAndSelectTaskToCorrectLIst(Task toAdd) {
        if (toAdd.getTaskCategory() == 1){
            selectEvent(toAdd);
            return new CommandResult(String.format(EVENT_SUCCESS, toAdd));
        } else if (toAdd.getTaskCategory() == 2){
        	selectDeadline(toAdd);
            return new CommandResult(String.format(DEADLINE_SUCCESS, toAdd));
        } else{
            selectTodo(toAdd);
            return new CommandResult(String.format(TODO_SUCCESS, toAdd));
        }
    }
    /**
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
     * selects the added task in the todolist
     * @param toAdd the added task
     */
    private void selectTodo(Task toAdd) {
        char category = 'T';
        int index = model.getFilteredTodoList().indexOf(toAdd);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index, category));
    }
    /**
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
     * selects the added task in the deadline list
     * @param toAdd  the added task
     */
    private void selectDeadline(Task toAdd) {
        char category = 'D';
        int index = model.getFilteredDeadlineList().indexOf(toAdd);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index, category));
    }
    /**
```
###### \java\seedu\simply\logic\commands\AddCommand.java
``` java
     * selects the added task in the events list
     * @param toAdd the added task
     */
    private void selectEvent(Task toAdd) {
        char category = 'E';
        int index = model.getFilteredEventList().indexOf(toAdd);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index, category));
    }
    
```
###### \java\seedu\simply\logic\parser\Parser.java
``` java
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern ARGS_FORMAT_TASK_INDEX = Pattern.compile("(?<targetIndex>.+)");

    private static final Pattern ARGS_FORMAT_KEYWORDS =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

    private static final Pattern ARGS_FORMAT_EVENT_DATA = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("\\[(?<name>[^;]+)"
                    + "(; (?<date>[^;]+))?"
                    + "(; (?<start>[^;]+))?"
                    + "(; (?<end>[^#]+))?"
                    + "\\]"
                    + "(?<tagArguments>(?: #[^#]+)*)"); // variable number of tags

    private static final Pattern ARGS_FORMAT_DEADLINE_DATA = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>[^;]+)"
                    + "; (?<date>[^;#]+)"
                    + "(; (?<end>[^#]+))?"
                    + "(?<tagArguments>(?: #[^#]+)*)"); // variable number of tags


    private static final Pattern ARGS_FORMAT_TODO_DATA = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<name>[^#]+)"
                    + "(?<tagArguments>(?: #[^#]+)*)"); // variable number of tags

    private static final Pattern ARGS_FORMAT_EDIT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("[E|D|T]\\d+ "
                    + "(des|date|start|end|tag) "
                    + ".+");

    private static final Pattern ARGS_FORMAT_ADD_TAGS = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("[E|D|T]\\d+"
                    + " #[^#]+"
                    + "(?<tagArguments>(?: #[^#]+)*)");// variable number of tags

    private static final Pattern ARGS_FORMAT_DELETE = 
            Pattern.compile("(([E|D|T]\\d+, )*([E|D|T]\\d+))|"
                    + "([E|D|T]\\d+-[E|D|T]\\d+)");

    private static final Pattern ARGS_FORMAT_COMPLETE =
            Pattern.compile("(([E|D|T]\\d+, )*([E|D|T]\\d+))|"
                    + "([E|D|T]\\d+-[E|D|T]\\d+)");

    private static final Pattern ARGS_FORMAT_SELECT = 
            Pattern.compile("[E|D|T]\\d+");

    public Parser() {}

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        switch (commandWord) {

        case AddCommand.COMMAND_WORD : 
            return prepareAdd(userInput, arguments);

        case SelectCommand.COMMAND_WORD :
            return prepareSelect(arguments);

        case DeleteCommand.COMMAND_WORD :
            return prepareDelete(arguments);

        case EditCommand.COMMAND_WORD :
            return prepareEdit(arguments);

        case DoneCommand.COMMAND_WORD :
            return prepareComplete(arguments);

        case SpecifyStorageCommand.COMMAND_WORD :
            return prepareSpecifyStorage(arguments);

        case UndoCommand.COMMAND_WORD :
            return prepareUndo(arguments);

        case RedoCommand.COMMAND_WORD :
            return prepareRedo(arguments);

        case ClearCommand.COMMAND_WORD :
            return new ClearCommand();

        case FindCommand.COMMAND_WORD :
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD :
            return new ListCommand(arguments);

        case ExitCommand.COMMAND_WORD :
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD :
            return new HelpCommand();

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
    /**
```
###### \java\seedu\simply\logic\parser\Parser.java
``` java
     * Chooses which kind of task to create and prepare
     * @param userInput takes in the user input from the command line interface
     * @param arguments full commands argument string
     * @return the prepared command
     */
    private Command prepareAdd(String userInput, final String arguments) {
        if (ARGS_FORMAT_EVENT_DATA.matcher(userInput).find()) {
            return prepareEvent(arguments);
        } else if (ARGS_FORMAT_DEADLINE_DATA.matcher(userInput).find()) {
            return prepareDeadline(arguments);
        } else if (ARGS_FORMAT_ADD_TAGS.matcher(userInput).find()) {
            return prepareAddTags(arguments);
        } else if (ARGS_FORMAT_TODO_DATA.matcher(userInput).find()) {
            return prepareToDo(arguments);
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }
```
###### \java\seedu\simply\logic\parser\Parser.java
``` java
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareToDo(String args) {
        final Matcher matcher = ARGS_FORMAT_TODO_DATA.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group("name"),
                    getTagsFromArgs(matcher.group("tagArguments"))
                    );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the add task command.
```
###### \java\seedu\simply\logic\parser\Parser.java
``` java
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDeadline(String args){
        final Matcher matcher = ARGS_FORMAT_DEADLINE_DATA.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group("name"),
                    matcher.group("date"),
                    matcher.group("end"),
                    getTagsFromArgs(matcher.group("tagArguments"))
                    );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }


    /**
     * Parses arguments in the context of the add task command.
```
###### \java\seedu\simply\logic\parser\Parser.java
``` java
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareEvent(String args){
        final Matcher matcher = ARGS_FORMAT_EVENT_DATA.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group("name"),
                    matcher.group("date"),
                    matcher.group("start"),
                    matcher.group("end"),
                    getTagsFromArgs(matcher.group("tagArguments"))
                    );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Extracts the new task's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    /**
     * @param tagArguments
     * @return
     * @throws IllegalValueException
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst(" #", "").split(" #"));
        return new HashSet<>(tagStrings);
    }
    
```
###### \java\seedu\simply\logic\parser\Parser.java
``` java
     * Parses arguments in the context of the select task command.
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSelect(String args) {
        final Matcher matcher = ARGS_FORMAT_SELECT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        args = args.trim();

        char category = args.charAt(0);
        Optional<Integer> index = parseIndex(args.substring(1));
        args = args.substring(args.indexOf(' ') + 1);

        if(!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        Integer pass = index.get();
        return new SelectCommand(pass, args, category);

    }

    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = ARGS_FORMAT_TASK_INDEX.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }
    
```
###### \java\seedu\simply\model\ModelManager.java
``` java
    @Override
    public synchronized void overdueTask() {
        final Runnable overdue = new Runnable() {
            public void run() {
                taskBook.overdueTask();
                indicateTaskOverdueChanged();
                indicateTaskBookChanged();
            };
        };
        scheduler.scheduleAtFixedRate(overdue, 0, 1, TimeUnit.SECONDS); 
    }

```
###### \java\seedu\simply\model\task\Date.java
``` java
 * Represents a Task date in Simply.
 * Guarantees: immutable; is valid as declared in {@link #isValidDate(String)}
 */
public class Date implements Comparable<Date> {

    public static final String MESSAGE_DATE_CONSTRAINTS = "Dates should be entered in the format DDMMYY, DD.MM.YY, DD/MM/YY, DD-MM-YY";
    public static final String DATE_VALIDATION_REGEX = "([3][01][1][012]\\d{2})|([3][01][0]\\d{3})|([012]\\d{1}[1][012]\\d{2})|" 
            + "([012]\\d{1}[0]\\d{3})|" //DDMMYY
            + "([3][01]-[1][012]-\\d{2})|([3][01]-[0]\\d{1}-\\d{2})|([12]\\d{1}-[1][012]-\\d{2})|" //DD-MM-YY
            + "([12]\\d{1}-[0]\\d{1}-\\d{2})|([0]\\d{1}-[1][012]-\\d{2})|([0]\\d{1}-[0]\\d{1}-\\d{2})|"
            + "([3][01]\\.[1][012]\\.\\d{2})|([3][01]\\.[0]\\d{1}\\.\\d{2})|([12]\\d{1}\\.[1][012]\\.\\d{2})|" //DD.MM.YY
            + "([12]\\d{1}\\.[0]\\d{1}\\.\\d{2})|([0]\\d{1}\\.[1][012]\\.\\d{2})|([0]\\d{1}\\.[0]\\d{1}\\.\\d{2})|"
            + "([3][01]/[1][012]/\\d{2})|([3][01]/[0]\\d{1}/\\d{2})|([12]\\d{1}/[1][012]/\\d{2})|" //DD/MM/YY
            + "([12]\\d{1}/[0]\\d{1}/\\d{2})|([0]\\d{1}/[1][012]/\\d{2})|([0]\\d{1}/[0]\\d{1}/\\d{2})|"
            + "(no date)";
    public static final String MESSAGE_PAST_DATE = "Cannot enter a date that have already past!";

    public final String value;
    private int beforeCurrentDate;

    /**
```
###### \java\seedu\simply\model\task\Date.java
``` java
     * Validates given date.
     * @throws IllegalValueException if given date string is invalid.
     */
    public Date(String date) throws IllegalValueException {
        if (date == null) {
    		date = "default";
        }
        date = date.trim();
        if (!isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        date = standardFormatDate(date);
        beforeCurrentDate = isAfterCurrentDate(date);
        this.value = date;
    }
    /**
```
###### \java\seedu\simply\model\task\Date.java
``` java
     * checks if the current date have been past
     * @param date
     * @return int value of 1 if date have past 2 if current date 0 if date is in the future
     */
	public int isAfterCurrentDate(String date) {
    	if (date.contains("-")) {
			String[] date_cat = date.split("-");
			String date_year = "20" + date_cat[2];
			LocalDate test = LocalDate.of(Integer.parseInt(date_year), Integer.parseInt(date_cat[1]), Integer.parseInt(date_cat[0]));
            LocalDate now = LocalDate.now();
			return currentDateStatus(now, test);
    	} else//accounting for no date
    		return 1;
	}
	/**
```
###### \java\seedu\simply\model\task\Date.java
``` java
	 * @param now  current local date
	 * @param test the date entered by the user
	 * @return the status of the date with 1 being past and 2 being equal and 0 being in the future
	 */
	private int currentDateStatus(LocalDate now, LocalDate test) {
	    if (test.isAfter(now)) {
	        return 1;
	    } else if (test.isEqual(now)) {
	        return 2;
	    } else {
	        return 0;
	    }
	}
	
	/**
```
###### \java\seedu\simply\model\task\Date.java
``` java
	 * standardize the date format to DD-MM-YY
	 * @param date
	 * @return the date format of DD-MM-YY
	 */
	private String standardFormatDate(String date) {
	    if (date.equals("default")) {
	        return local_date();
	    } else if (date.equals("no date")) {
	        return date;
	    } else if (date.contains(".")) {
	        return date.replaceAll("\\.", "-");
	    } else if (date.contains("-")) {
	        return date;
	    } else if (date.contains("/")) {
	        return date.replaceAll("/",  "-");
	    } else {
	        return date.substring(0, 2) + "-" + date.substring(2, 4) + "-" + date.substring(4, 6);
	    }
	}
```
###### \java\seedu\simply\model\task\Date.java
``` java
	public String local_date(){
    	LocalDate now = LocalDate.now();
    	String date = now.toString();
    	String[] date_cat = date.split("-");
    	String shortened_year = new String(date_cat[0].substring(2));
    	return date_cat[2] + "-" + date_cat[1] + "-" + shortened_year;
    }
    /**
     * Returns true if a given string is a valid task date.
     */
	public static boolean isValidDate(String test) {
	    if (test.matches(DATE_VALIDATION_REGEX) || test.equals("default")) {
	        return true;
	    } else {
	        return false;
	    }
	}
    public int getBeforeCurrentDate() {
    	return beforeCurrentDate;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Date // instanceof handles nulls
                && this.value.equals(((Date) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
    
```
###### \java\seedu\simply\model\task\End.java
``` java
 * Represents a task's end time in Simply
 * Guarantees: immutable; is valid as declared in {@link #isValidEnd(String)}
 */
public class End implements Comparable<End> {
    
    public static final String MESSAGE_END_CONSTRAINTS = "Task end time can be entered in 24hour or 12hour format.";
    public static final String END_VALIDATION_REGEX = "([01]\\d{1}[0-5]\\d{1})|"
            + "([2][0-3][0-5]\\d{1})|"
            + "([1-9](?:pm|am|PM|AM))|" 
            + "(1[0-2](?:pm|am|PM|AM))|"
            + "([1-9]\\.[0-5]{1}\\d{1}(?:pm|am))|"
            + "(1[0-2]\\.[0-5]{1}\\d{1}(?:pm|am))|"
            + "(no end)";
    public static final String DEFAULT_END_TIME = "2359";
    public final String value;
    private int pastEndTime =0;

    /**
     *
     * Validates given end time.
```
###### \java\seedu\simply\model\task\End.java
``` java
     * @throws IllegalValueException if given task string is invalid.
     */
    public End(String end) throws IllegalValueException {
        if (end == null) {
            end = "default";
        }
        if (!isValidEnd(end)) {
            throw new IllegalValueException(MESSAGE_END_CONSTRAINTS);
        }
        if (end.equals("default")) {
            this.value = DEFAULT_END_TIME;
        } else if (end.equals("no end")) {
            this.value = "no end";
        } else {
            this.value = changeTo24HourFormat(end);
            if (isPastEndTime(value)) {
                pastEndTime =1;
            }
        }
    }
    /**
```
###### \java\seedu\simply\model\task\End.java
``` java
     * checks if the end time have past
     * @param end the user input end time
     * @return true is it has past and false if it has not past
     */
    public boolean isPastEndTime(String end) {
    	String localTime = new String("");
    	String new_min = formatLocalTimeMinutes();
        String new_hr = formatLocalTimeHours();
		localTime = new_hr +""+ new_min;
		if (Integer.parseInt(end) - Integer.parseInt(localTime) < 0) {
			return true;
		} else {
			return false;
		}
	}
    /**
```
###### \java\seedu\simply\model\task\End.java
``` java
     * formatting the local time class hours to the desired format
     * @return the formatted hours
     */
    private String formatLocalTimeHours() {
        String new_hr = new String(LocalTime.now().getHour() + "");
		if (new_hr.length() ==1) {
			new_hr = "0" + new_hr;
		}
        return new_hr;
    }
    /**
```
###### \java\seedu\simply\model\task\End.java
``` java
     * formatting the local time class minutes to the desired format
     * @return the formatted minutes
     */
    private String formatLocalTimeMinutes() {
        String new_min = new String(LocalTime.now().getMinute() + "");
    	if (new_min.length() ==1 ) {
            new_min = "0" + new_min;
    	}
        return new_min;
    }
    /**
```
###### \java\seedu\simply\model\task\End.java
``` java
     * changing the end time to 24 hour format for easier sorting and display
     * @param end the user input end time
     * @return the standardize format of the user end time
     */
    private String changeTo24HourFormat(String end) {
        if (Character.isDigit(end.charAt(end.length()-1))) {
            return end;
        } else if (end.length() == 3) {
            if (end.substring(1).equalsIgnoreCase("pm")) {
                return (Integer.parseInt(end.substring(0,1))+12) + "00";
            } else {
                return "0" + end.substring(0, 1) + "00";
            }
        } else if (end.length() == 4) {
            if (end.substring(2).equalsIgnoreCase("pm")) {
                return (Integer.parseInt(end.substring(0,2))+12) + "00";
            } else {
                return end.substring(0, 2) + "00";
            }
        } else {
            String[] time_cat = end.split("\\.");
            if (time_cat[0].length() ==1) {
                time_cat[0] = "0" + time_cat[0];
            }
            if (time_cat[1].substring(2).equalsIgnoreCase("pm")) {
                time_cat[0] = "" + (Integer.parseInt(time_cat[0]) + 12);
            }
            return time_cat[0] + time_cat[1].substring(0, 2);
        }

    }

	public int getPastEndTime() {
		return pastEndTime;
	}

    /**
     * Returns true if a given string is a valid task end time.
     */
	public static boolean isValidEnd(String test) {
	    if (test.matches(END_VALIDATION_REGEX) || test.equals("default")) {
	        return true;
	    } else {
	        return false;
	    }
	}

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof End // instanceof handles nulls
                && this.value.equals(((End) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
    
```
###### \java\seedu\simply\model\task\Start.java
``` java
 * Represents a task's start time in Simply.
 * Guarantees: immutable; is valid as declared in {@link #isValidStart(String)}
 */
public class Start implements Comparable<Start> {

    public static final String MESSAGE_START_CONSTRAINTS = "Task start time can be entered in 24hour or 12hour format.";
    public static final String START_VALIDATION_REGEX = "([01]\\d{1}[0-5]\\d{1})|"
            + "([2][0-3][0-5]\\d{1})|"
            + "([1-9](?:pm|am|PM|AM))|" 
            + "(1[0-2](?:pm|am|PM|AM))|"
            + "([1-9]\\.[0-5]{1}\\d{1}(?:pm|am|AM|PM))|"
            + "(1[0-2]\\.[0-5]{1}\\d{1}(?:pm|am|AM|PM))|"
            + "(no start)";

    public final String value;

    /**
     * Validates given start time.
```
###### \java\seedu\simply\model\task\Start.java
``` java
     * @throws IllegalValueException if given start time string is invalid.
     */
    public Start(String start) throws IllegalValueException {
    	//assert start != null;
    	if (start == null) {
    		start = "default";
    	}
    	start = start.trim();
    	if (!isValidStart(start)) {
    		throw new IllegalValueException(MESSAGE_START_CONSTRAINTS);
    	}
    	this.value = calculateStartTimeValue(start);
    	
    }
    /**
```
###### \java\seedu\simply\model\task\Start.java
``` java
     * Calculates the start time of the task
     * @param start the start time from the user input in any format
     * @return standardized format of the start time
     */
	private String calculateStartTimeValue(String start) {
	    if (start.equals("default")) {
	        String new_hr = startTimeHour();
	        String new_min = startTimeMin();
	        return new_hr +""+ new_min;
	    } else if (start.equals("no start")) {
	        return "no start";
	    } else {
	        return changeTo24HourFormat(start);
	    }
	}
	/**
```
###### \java\seedu\simply\model\task\Start.java
``` java
	 * calculates the local time minutes
	 * @return the local minutes
	 */
	private String startTimeMin() {
		String new_min = new String(LocalTime.now().getMinute() + "");
		if (new_min.length() ==1 ) {
			new_min = "0" + new_min;
		}
		return new_min;
	}
	/**
```
###### \java\seedu\simply\model\task\Start.java
``` java
	 * calculates the local time hour
	 * @return the local hour
	 */
	private String startTimeHour() {
		String new_hr = new String(LocalTime.now().getHour() + "");
		if (new_hr.length() ==1) {
			new_hr = "0" + new_hr;
		}
		return new_hr;
	}
	
```
###### \java\seedu\simply\model\task\Start.java
``` java
	/**
	 * changes the user input to 24 hour format
	 * @param start
	 * @return 24 hr clock
	 */
	private String changeTo24HourFormat(String start) {
	    if (Character.isDigit(start.charAt(start.length()-1))) {
	        return start;
	    } else if (start.length() == 3) {
	        return format1DigitStartTime(start);
	    } else if (start.length() == 4) {
            return format2DigitStartTime(start);
	    } else {
	        return formatGeneralStartTime(start);
	    }
			
	}
    
    /**
```
###### \java\seedu\simply\model\task\Start.java
``` java
     * formats the general time format of hh.mm to 24 hour format
     * @param start
     * @return 24 hour clock format
     */
	private String formatGeneralStartTime(String start) {
	    String[] time_cat = start.split("\\.");
	    if (time_cat[0].length() ==1) {
	        time_cat[0] = "0" + time_cat[0];
	    }
	    if (time_cat[1].substring(2).equalsIgnoreCase("pm")) {
	        time_cat[0] = "" + (Integer.parseInt(time_cat[0]) + 12);
	    }
	    return time_cat[0] + time_cat[1].substring(0, 2);
	}
    /**
```
###### \java\seedu\simply\model\task\Start.java
``` java
     * formats 2 digit start time to 24 hour clock
     * @param start
     * @return 24 hour clock format
     */
	private String format2DigitStartTime(String start) {
	    if (start.substring(2).equalsIgnoreCase("pm")) {
	        return (Integer.parseInt(start.substring(0,2))+12) + "00";
	    } else {
	        return start.substring(0, 2) + "00";
	    }
	}
	/**
```
###### \java\seedu\simply\model\task\Start.java
``` java
	 * formats 1 digit start time to 24 hour clock
	 * @param start
	 * @return 24 hour clock format
	 */
	private String format1DigitStartTime(String start) {
	    if (start.substring(1).equalsIgnoreCase("pm")) {
	        return (Integer.parseInt(start.substring(0,1))+12) + "00";
	    } else {
	        return "0" + start.substring(0, 1) + "00";
	    }
	}

	/**
     * Returns if a given string is a valid task start time.
     */
	public static boolean isValidStart(String test) {
	    if (test.matches(START_VALIDATION_REGEX) || test.equals("default")) {
	        return true;
	    } else {
	        return false;
	    }
	}

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Start // instanceof handles nulls
                && this.value.equals(((Start) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
    
```
###### \java\seedu\simply\model\task\Task.java
``` java
 * Represents a Task in the end book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask, ModifyTask, Comparable<Task> {

    private Name name;
    private Date date;
    private Start start;
    private End end;
    private int overdue;
    private int taskCategory;
    private boolean isCompleted;

    private UniqueTagList tags;

    /**
```
###### \java\seedu\simply\model\task\Task.java
``` java
     * Every field must be present and not null.
     */
    public Task(Name name, Date date, Start start, End end, int taskCategory, int overdue, boolean isCompleted, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, date, start, end, tags);
        this.name = name;
        this.date = date;
        this.start = start;
        this.end = end;
        this.taskCategory = taskCategory;
        this.isCompleted = isCompleted;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
        if (isOverdue(this.getDate(), this.getEnd())==1) {
            this.overdue =1;
        } else if (isOverdue(this.getDate(), this.getEnd()) ==2) {
            this.overdue =2;
        } else {
            this.overdue =0;
        }
    }

  	/**
```
###### \java\seedu\simply\model\task\Task.java
``` java
     * Copy constructor for deadline.
     */    
    public Task(Name name, Date date, End end, int taskCategory, int overdue, boolean isCompleted, UniqueTagList tags) {
        this.name = name;
        this.date = date;
        this.start = null;
        this.end = end;
        this.taskCategory = taskCategory;
        this.isCompleted = isCompleted;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
        if (isOverdue(this.getDate(), this.getEnd())==1) {
            this.overdue =1;
        } else if (isOverdue(this.getDate(), this.getEnd()) ==2) {
            this.overdue =2;
        } else { 
            this.overdue =0;
        }
    }

    /**
```
###### \java\seedu\simply\model\task\Task.java
``` java
     * Copy constructor for todo.
     */    
    public Task(Name name, int taskCategory, boolean isCompleted, UniqueTagList tags) {
        this.name = name;
        this.date = null;
        this.start = null;
        this.end = null;
        this.taskCategory = taskCategory;
        this.isCompleted = isCompleted;
        this.overdue =0;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
    
    /**
```
###### \java\seedu\simply\model\task\Task.java
``` java
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDate(), source.getStart(), source.getEnd(), source.getTaskCategory(), source.getOverdue(),source.getIsCompleted(), source.getTags());
    }
```
###### \java\seedu\simply\model\task\Task.java
``` java
    public int isOverdue(Date checkDate, End checkEnd) {
    	if (checkDate.isAfterCurrentDate(checkDate.toString()) == 0){
    		return 1;
    	} else if ((checkDate.isAfterCurrentDate(checkDate.toString()) ==2) &&  (checkEnd.isPastEndTime(checkEnd.toString()))){
    		return 1;
    	} else if ((checkDate.isAfterCurrentDate(checkDate.toString()) ==2) &&  (!checkEnd.isPastEndTime(checkEnd.toString()))){
    		return 2;
    	} else {
    		return 0;
    	}
  	}


    @Override
    public int getOverdue() {
    	return overdue;
    }
    @Override
    public Name getName() {
        return name;
    }

    @Override
    public Date getDate() {
        return date;
    }

    @Override
    public Start getStart() {
        return start;
    }

    @Override
    public End getEnd() {
        return end;
    }
    
    @Override
    public int getTaskCategory(){
    	return taskCategory;
    }
    
    @Override
    public boolean getIsCompleted() {
        return isCompleted;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }
    
    /**
     * This section contains the setter methods
     */
    
    @Override 
    public void setName(Name name) {
        this.name = name;
    }
    
    @Override 
    public void setDate(Date date) {
        this.date = date;
    }
    
    @Override
    public void setStart(Start start) {
        this.start = start;
    }
    
    @Override
    public void setEnd(End end) {
        this.end = end;
    }

    @Override
    public void setTaskCategory(int taskCat) {
    	this.taskCategory = taskCat;
    }
    
    @Override
    public void setCompleted(boolean completed) {
        this.isCompleted = completed;
    }
    
    @Override
    public void setOverdue(int overdue) {
    	this.overdue = overdue;
    }
    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }
    /**
     * increase this task's tags with the tags in the argument tag list.
     */
    public void addTags(UniqueTagList addOn) {
        tags.mergeFrom(addOn);
    }
    
    
    /**
     * Replaces the specific tag found in this task's tags with the tags in the argument.
     * @return 
     * @throws IllegalValueException 

     */
```
###### \java\seedu\simply\model\task\UniqueTaskList.java
``` java
     * marks the task as overdue
     * @param key the selected task
     * @return status of the task with 1 being overdue 2 being today and 0 being the default
     */
    public int markOverdue(ReadOnlyTask key) {
        assert key != null;
        int overdueIndex = internalList.indexOf(key);
        Task overduedTask = internalList.get(overdueIndex);
        if (overduedTask.isOverdue(overduedTask.getDate(), overduedTask.getEnd()) == 1) {
            overduedTask.setOverdue(1);
            return overduedTask.getOverdue();
        } else if (overduedTask.isOverdue(overduedTask.getDate(), overduedTask.getEnd()) == 2) {
            overduedTask.setOverdue(2);
            return overduedTask.getOverdue();
        } else {
            overduedTask.setOverdue(0);
            return overduedTask.getOverdue();
        }
    }

```
###### \java\seedu\simply\model\task\UniqueTaskList.java
``` java
    public int getTaskIndex(ReadOnlyTask key) {
        assert key != null;
        return internalList.indexOf(key);
    }

```
###### \java\seedu\simply\model\TaskBook.java
``` java
     * Adds a task to the task book.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task t) throws UniqueTaskList.DuplicateTaskException {
        syncTagsWithMasterList(t);
        if (t.getTaskCategory() == 1) {
            events.add(t);
        } else if (t.getTaskCategory() == 2) {
            deadlines.add(t);
        } else {
            todo.add(t);
        }
    }

    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncTagsWithMasterList(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        for (Tag tag : tags) {
            masterTagObjects.put(tag, tag);
        }

        // Rebuild the list of task tags using references from the master list
        final Set<Tag> commonTagReferences = new HashSet<>();
        for (Tag tag : taskTags) {
            commonTagReferences.add(masterTagObjects.get(tag));
        }
        task.setTags(new UniqueTagList(commonTagReferences));
    }
```
###### \java\seedu\simply\model\TaskBook.java
``` java
    public boolean checkTask(ReadOnlyTask toCheck) {
        int taskCategory = toCheck.getTaskCategory();
        if(taskCategory == 1){
            return events.contains(toCheck);
        } else if(taskCategory == 2){
            return deadlines.contains(toCheck);
        } else if(taskCategory == 3){
            return todo.contains(toCheck);
        }       
        return false;
    }
    
```
###### \java\seedu\simply\model\TaskBook.java
``` java
    public void overdueTask() {
        for (Task task: events) {
            events.markOverdue(task);
           }
        for (Task task: deadlines) {
            deadlines.markOverdue(task);
           }
    }

```
