# A0140133B
###### \java\seedu\jimi\commons\util\CommandUtil.java
``` java
/**
 * Represents a singleton manager for utility methods related to commands.
 */
public class CommandUtil {
    
    private static CommandUtil instance;
    
    private List<Command> cmdStubList;
    
    private List<String> allCmdWords;
    
    // Keys are near matches with an edit distance of two, values are command words.
    private HashMap<String, Set<String>> cmdWordNearMatches; 
    
    private CommandUtil() {
        initCommandStubList();
        initCommandWords();
        initCommandWordsNearMatches();
    }
    
    /** Returns a string of all command words in {@code cmdStubList} joined by a comma. */
    public String commandsToString() {
        return allCmdWords.stream()
                .filter(s -> s != null && !s.isEmpty())
                .collect(Collectors.joining(", "));
    }
    
    public List<Command> getCommandStubList() {
        return cmdStubList;
    }
    
    /** Returns the only instance in the singleton manager. */
    public static CommandUtil getInstance() {
        if (instance == null) {
            instance = new CommandUtil();
        }
        return instance;
    }
    
    /** Returns a list of command words that nearly matches {@code target} */
    public List<String> getCommandWordMatches(String target) {
        assert target != null;
        return cmdStubList.stream()
                .filter(c -> c.isValidCommandWord(target) 
                        || StringUtil.isValidSubstrings(c.getCommandWord(), target)
                        || (cmdWordNearMatches.containsKey(target) // Checking dictionary for potential near match.
                                && cmdWordNearMatches.get(target).contains(c.getCommandWord())))
                .map(c -> c.getCommandWord())
                .collect(Collectors.toList());
    }
    
    /*
     * ==========================================================
     *                  Initialization Methods
     * ==========================================================
     */
    
    /** Creating near match dictionaries up to two edit distances, for command words. */
    private void initCommandWordsNearMatches() {
        assert cmdStubList != null && allCmdWords != null;
        cmdWordNearMatches = new HashMap<String, Set<String>>();
        allCmdWords.forEach(cmdWord -> {
            Set<String> oneEditDistanceDict = DictionaryUtil.generateOneEditDistanceDict(cmdWord);
            
            Set<String> twoEditDistanceDict = new HashSet<String>();
            // Generating a two edit distance dictionary from each word of the one edit distance dictionary.
            oneEditDistanceDict.forEach(w -> twoEditDistanceDict.addAll(DictionaryUtil.generateOneEditDistanceDict(w)));
            
            // Storing the words in the cmdWordNearMatches dictionary.
            // There can be multiple command word matches for the same typo, hence the value of the map is a set.
            for (String twoEditDistanceWord : twoEditDistanceDict) {
                Set<String> cmdWordMatches = cmdWordNearMatches.containsKey(twoEditDistanceWord)
                        ? cmdWordNearMatches.get(twoEditDistanceWord) : new HashSet<String>();
                cmdWordMatches.add(cmdWord);
                cmdWordNearMatches.put(twoEditDistanceWord, cmdWordMatches);
            }
        });
    }
    
    /** Creating a list of commands available in Jimi. */
    private void initCommandStubList() {
        cmdStubList = Arrays.asList(
                new AddCommand(), 
                new EditCommand(), 
                new CompleteCommand(), 
                new ShowCommand(), 
                new DeleteCommand(),
                new ClearCommand(), 
                new FindCommand(), 
                new UndoCommand(),
                new RedoCommand(),
                new ExitCommand(), 
                new HelpCommand(), 
                new SaveAsCommand()
        );
    }

    /** Creating a list of commands words from commands in {@code cmdStubList} */
    private void initCommandWords() {
        assert cmdStubList != null;
        allCmdWords = cmdStubList.stream()
                .map(c -> c.getCommandWord())
                .filter(s -> s != null && !s.isEmpty())
                .collect(Collectors.toList());
    }

}
```
###### \java\seedu\jimi\commons\util\DictionaryUtil.java
``` java
/** Container class for dictionary related methods */
public class DictionaryUtil {
    
    private static final char[] ALPHABET = "abcdefghijklmnopqrstuvwxyz".toCharArray();

    /** Combines multiple dictionaries to one */
    @SafeVarargs
    public static Set<String> join(Set<String>... sets) {
        assert sets != null;
        CollectionUtil.assertNoNullElements(Arrays.asList(sets));
        Set<String> joined = new HashSet<String>();
        Arrays.stream(sets).forEach(s -> joined.addAll(s));
        return joined;
    }
    
    /** Generates a one edit distance dictionary of {@code src}. */
    public static Set<String> generateOneEditDistanceDict(String src) {
        assert src != null;
        return DictionaryUtil.join(generateExtraChar(src), generateMissingChar(src), generateReplacedChar(src),
                generateTransposedChar(src));
    }
    
    /** Generates a dictionary of strings that have two transposed characters from {@code src}. */
    public static Set<String> generateTransposedChar(String src) {
        assert src != null;
        Set<String> dictionary = new HashSet<String>();
        StringBuilder sb = new StringBuilder(src);
        for (int i = 0; i < src.length() - 1; i++) {
            char c = sb.charAt(i); // Transposing two characters.
            sb.setCharAt(i, sb.charAt(i + 1));
            sb.setCharAt(i + 1, c);
            dictionary.add(sb.toString());
            c = sb.charAt(i); // Reverting the transposition.
            sb.setCharAt(i, sb.charAt(i + 1));
            sb.setCharAt(i + 1, c);
        }
        return dictionary;
    }
    
    /** Generates a dictionary of strings that differ by one character from {@code src}. */
    public static Set<String> generateReplacedChar(String src) {
        assert src != null;
        Set<String> dictionary = new HashSet<String>();
        StringBuilder sb = new StringBuilder(src);
        for (int i = 0; i < src.length(); i++) {
            for (Character c : ALPHABET) {
                char old = sb.charAt(i);
                sb.setCharAt(i, c); // Replacing the char at idx i. with character c.
                dictionary.add(sb.toString());
                sb.setCharAt(i, old); // Placing back the char after adding to dictionary.
            }
        }
        return dictionary;
    }

    /** Generates a dictionary of strings that are missing a letter from {@code src}. */
    public static Set<String> generateMissingChar(String src) {
        assert src != null;
        return IntStream.range(0, src.length()) 
                .mapToObj(i -> src.substring(0, i) + src.substring(i + 1)) // Removing character at idx i.
                .collect(Collectors.toSet());
    }
    
    /** Generates a dictionary of strings that have one extra character from {@code src}. */
    public static Set<String> generateExtraChar(String src) {
        assert src != null;
        Set<String> dictionary = new HashSet<String>();
        StringBuilder sb = new StringBuilder(src);
        for (int i = 0; i <= src.length(); i++) {
            for (Character c : ALPHABET) {
                dictionary.add(sb.insert(i, c.toString()).toString()); // Inserting character c at idx i.
                sb.deleteCharAt(i); // Deleting inserted character.
            }
        }
        return dictionary;
    }
}
```
###### \java\seedu\jimi\commons\util\FileUtil.java
``` java
    /** 
     * Checks if a given string {@code path} is a valid file path
     */
    public static boolean isValidPath(String path) {
        try {
            Paths.get(path);
        } catch (InvalidPathException | NullPointerException ex) {
            return false;
        }
        
        return true;
    }
```
###### \java\seedu\jimi\commons\util\StringUtil.java
``` java
/**
 * Helper functions for handling strings.
 */
public class StringUtil {
    
    private static final int DEFAULT_EDIT_DISTANCE = 2; // Edit distance to quantify string similarity.
    
    // Percentage of containing string for the contained string to be a valid substring.
    private static final double SUBSTRING_ALLOWANCE = 1.0 / 3.0; // = a third 
    
    /** Returns true if any of the strings in {@code keywords} nearly matches {@code query}. */
    public static boolean isAnyNearMatch(String query, List<String> keywords) {
        if (query == null || keywords == null) {
            return false;
        }
        CollectionUtil.assertNoNullElements(keywords);
        return keywords.stream()
                .filter(kw -> isNearMatch(kw, query))
                .findAny()
                .isPresent();
    }

    /** 
     * Returns true if {@code query} is a near match of {@code source} or are valid substrings of each other. <br>
     * This is also a recursive driver method.
     */
    public static boolean isNearMatch(String source, String query) {
        if (source == null || query == null) {
            return false;
        }
        return isValidSubstrings(source, query) || isNearMatch(source, query, DEFAULT_EDIT_DISTANCE);
    }
    
    /**
     * Returns true if {@code query} is a near match of {@code source} <br>
     * <br>
     * Edit distance is a way of quantifying string similarity. It is simply the minimum number of operations <br>
     * to transform a string to another. These operations include: deleting a character, inserting a character, <br>
     * replacing a character and transposing two characters. This method approximates string similarity to an <br>
     * edit distance of {@code editDistance}. <br>
     * <br>
     * For an edit distance of 1:
     * <ul>
     * <li> {@code query} is the same as {@code source} but missing a character.
     * <li> {@code query} is the same as {@code source} but differing by a character.
     * <li> {@code query} is the same as {@code source} but have two transposed characters.
     * <li> {@code query} is the same as {@code source} but has an extra character.
     * </ul>
     * 
     * All matches are case-insensitive and have all spaces removed in both strings prior to comparison. <br>
     * Conditions are also short-circuited for performance and memory. <br>
     * This is a recursive method that executes {@code editDistance} times.
     * 
     * @param source String to match against
     * @param query String to match with
     * @return true if {@code query} nearly matches {@code source}.
     */
    private static boolean isNearMatch(String source, String query, int editDistance) {
        assert source != null && query != null;
        // Removing all spaces and converting both strings to lower case.
        String sourceNoSpaces = source.toLowerCase().replaceAll("\\s+", "");
        String queryNoSpaces = query.toLowerCase().replaceAll("\\s+", "");
        
        Set<String> transposedDict = DictionaryUtil.generateTransposedChar(sourceNoSpaces);
        if (transposedDict.contains(queryNoSpaces)) {
            return true; // Similar by two transposed characters.
        }
        Set<String> missingCharDict = DictionaryUtil.generateMissingChar(sourceNoSpaces);
        if (missingCharDict.contains(queryNoSpaces)) {
            return true; // Similar by a missing character.
        }
        Set<String> oneCharDiffDict = DictionaryUtil.generateReplacedChar(sourceNoSpaces);
        if (oneCharDiffDict.contains(queryNoSpaces)) {
            return true; // Similar by a differing character.
        }
        Set<String> oneExtraCharDict = DictionaryUtil.generateExtraChar(sourceNoSpaces);
        if (oneExtraCharDict.contains(queryNoSpaces)) {
            return true; // Similar by an extra character.
        }
        if (editDistance <= 1) {
            return false; // Recursion base case.
        }
        
        // Combining all dictionaries.
        Set<String> combined = DictionaryUtil.join(transposedDict, missingCharDict, oneCharDiffDict, oneExtraCharDict);
        
        // Perform string approximation methods again.
        return combined.stream()
                .filter(kw -> isNearMatch(kw, queryNoSpaces, editDistance - 1))
                .findAny()
                .isPresent();
    }

    /**
     * Returns a detailed message of the t, including the stack trace.
     */
    public static String getDetails(Throwable t) {
        assert t != null;
        StringWriter sw = new StringWriter();
        t.printStackTrace(new PrintWriter(sw));
        return t.getMessage() + "\n" + sw.toString();
    }
    
    /**
     * Returns true if s represents an unsigned integer e.g. 1, 2, 3, ... <br>
     *   Will return false for null, empty string, "-1", "0", "+1", and " 2 " (untrimmed) "3 0" (contains whitespace).
     * @param s Should be trimmed.
     */
    public static boolean isUnsignedInteger(String s) {
        return s != null && s.matches("^0*[1-9]\\d*$");
    }
    
    /** 
     * Returns the first word separated by spaces in {@code text}. 
     * Adapted from StackOverflow because I'm too lazy to create my own 
     * method that extracts the first word of a string.
     */
    public static String getFirstWord(String text) {
        assert text != null;
        String trimmed = new String(text.trim());
        if (trimmed.indexOf(' ') > -1) { // Check if there is more than one word.
            return trimmed.substring(0, trimmed.indexOf(' ')); // Extract first word.
        } else {
            return trimmed; // Text is the first word itself.
        }
    }
    
    /** 
     * Returns true if {@code src} and {@code query} are valid substrings of each other. 
     * Validity is checked by {@code SUBSTRING_ALLOWANCE} where the substring length 
     * is a substantial percentage of the source string. 
     */
    public static boolean isValidSubstrings(String src, String query) {
        if (src == null || query == null) {
            return false;
        }
        if (!(src.contains(query) || query.contains(src))) {
            return false;
        }
        // Validating substring length percentage, returns true if above given allowance.
        return (double) Math.min(src.length(), query.length())
                / (double) Math.max(src.length(), query.length()) >= SUBSTRING_ALLOWANCE;
    }
}
```
###### \java\seedu\jimi\logic\commands\AddCommand.java
``` java
 */
public class AddCommand extends Command implements TaskBookEditor {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = 
            COMMAND_WORD + ": Adds a task or event to Jimi with one optional tag.\n"
            + "\n"
            + "To add a task:\n"
            + "Parameters: \"TASK_DETAILS\" [due DATE_TIME] [t/TAG]\n"
            + "Example: " + COMMAND_WORD + " \"do dishes\" t/important\n"
            + "\n"
            + "To add an event:\n"
            + "Parameters: \"TASK_DETAILS\" on|from START_DATE_TIME [to END_DATE_TIME] [t/TAG]\n"
            + "Example: " + COMMAND_WORD + " \"linkin park concert\" on sunday 2pm t/fun\n"
            + "\n"
            + "> Tip: Typing 'a' or 'ad' instead of 'add' works too.\n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Jimi";

    private final ReadOnlyTask toAdd;
    
    public AddCommand() {
        toAdd = null;
    }
    
    /**
     * Convenience constructor using raw values to add tasks.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, List<Date> dates, Set<String> tags, String priority) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        if (dates.size() == 0) {
            this.toAdd = new FloatingTask(new Name(name), new UniqueTagList(tagSet), new Priority(priority));
        } else {
            this.toAdd = new DeadlineTask(new Name(name), new DateTime(dates.get(0)), new UniqueTagList(tagSet), new Priority(priority));
        }
    }
    
    /**
     * Convenience constructor using raw values to add events.
     * 
     * @throws IllegalValueException
     */
    public AddCommand(String name, List<Date> startDateTime, List<Date> endDateTime, Set<String> tags, String priority)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        
        // events do not always have an end date 
        DateTime endDateTimeToAdd = endDateTime.isEmpty() ? null : new DateTime(endDateTime.get(0));
                
        if (endDateTimeToAdd != null
                && startDateTime.get(0).compareTo(endDateTime.get(0)) <= 0) {
            this.toAdd = new Event(new Name(name), new DateTime(startDateTime.get(0)), endDateTimeToAdd,
                    new UniqueTagList(tagSet), new Priority(priority));
        } else if (endDateTimeToAdd == null) { // event with no end date
            DateTime start = new DateTime(startDateTime.get(0));
            this.toAdd = new Event(new Name(name), start, new DateTime(start.getDate().concat(" 23:59")), // default midnight
                    new UniqueTagList(tagSet), new Priority(priority));
        } else {
            throw new IllegalValueException(Messages.MESSAGE_START_END_CONSTRAINT);
        }
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
        
    }
    
    @Override
    public boolean isValidCommandWord(String commandWord) {
        for (int i = 1; i <= COMMAND_WORD.length(); i++) {
            if (commandWord.equalsIgnoreCase(COMMAND_WORD.substring(0, i))) {
                return true;
            }
        }
        return false;
    }

    @Override
    public String getMessageUsage() {
        return MESSAGE_USAGE;
    }

    @Override
    public String getCommandWord() {
        return COMMAND_WORD;
    }
}
```
###### \java\seedu\jimi\logic\commands\ClearCommand.java
``` java
    @Override
    public boolean isValidCommandWord(String commandWord) {
        return commandWord.equalsIgnoreCase(COMMAND_WORD);
    }
```
###### \java\seedu\jimi\logic\commands\Command.java
``` java
    /** 
     * Checks if a given string is a command word of this command.
     * Critical commands like "Exit" and "Clear" should have the user type the full command word for it to be valid.
     * 
     * @return true if given string is a valid command word of this command.
     */
    public abstract boolean isValidCommandWord(String commandWord);
```
###### \java\seedu\jimi\logic\commands\Command.java
``` java
    /** Determines the list type according to the index prefix. */
    protected Optional<UnmodifiableObservableList<ReadOnlyTask>> determineListFromIndexPrefix(String idx) {
        if (idx.trim().toLowerCase().startsWith(INDEX_TASK_LIST_PREFIX)) {
            return Optional.of(model.getFilteredAgendaTaskList());
        } else if (idx.trim().toLowerCase().startsWith(INDEX_EVENT_LIST_PREFIX)) {
            return Optional.of(model.getFilteredAgendaEventList());
        }
        return Optional.empty();
    }
    
    /** Returns the message for usage of the command */
    public abstract String getMessageUsage();
    
    /** Returns the command word for the command. */
    public abstract String getCommandWord();
```
###### \java\seedu\jimi\logic\commands\CompleteCommand.java
``` java
    @Override
    public boolean isValidCommandWord(String commandWord) {
        for (int i = 1; i <= COMMAND_WORD.length(); i++) {
            if (commandWord.equalsIgnoreCase(COMMAND_WORD.substring(0, i))) {
                return true;
            }
        }
        return false;
    }
```
###### \java\seedu\jimi\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task or a range of tasks identified using it's last displayed index from Jimi.
 */
public class DeleteCommand extends Command implements TaskBookEditor {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the specified task/event from Jimi.\n"
            + "You can specify the task/event by entering its index number given in the last listing. \n"
            + "Parameters: INDEX (must be t<positive integer> or e<positive integer>)\n"
            + "Example: " + COMMAND_WORD + " t1\n"
            + "\n"
            + "You can also delete a range of tasks. \n"
            + "Example: " + COMMAND_WORD + " t1 to t3";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = 
            "Jimi has deleted the following: \n"
            + "%1$s";

    private String startIdx;
    private String endIdx;
    
    public DeleteCommand() {}
    
    
    public DeleteCommand(String startIdx, String endIdx) throws IllegalValueException {
        this.startIdx = startIdx.trim().toLowerCase();
        // If end index is not specified, default it to startIdx.
        this.endIdx = endIdx == null ? startIdx : endIdx.trim().toLowerCase(); 
    }
    
    @Override
    public CommandResult execute() {
        if (!isIndicesReferringToSameLists()) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        /* At this point, both indices refer to the same list as asserted by above condition.
         * So {@code optionalList} refers to the list specified by both indices.
         */
        Optional<UnmodifiableObservableList<ReadOnlyTask>> optionalList = determineListFromIndexPrefix(startIdx);
        
        // actual integer index is everything after the first character prefix.
        int actualStartIdx = Integer.parseInt(startIdx.substring(1));
        int actualEndIdx = Integer.parseInt(endIdx.substring(1));
        if (!isValidIndices(optionalList, actualStartIdx, actualEndIdx)) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = optionalList.get();
        // endIdx can exceed list size, but apply a ceiling of lastShownList.size().
        actualEndIdx = Math.min(actualEndIdx, lastShownList.size());
        
        List<ReadOnlyTask> toDelete = lastShownList.subList(actualStartIdx - 1, actualEndIdx);
        String deletedFeedback = getListOfTasksAsText(toDelete);
        deleteListOfTasks(toDelete);
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, deletedFeedback));
    }

    @Override
    public boolean isValidCommandWord(String commandWord) {
        for (int i = 1; i <= COMMAND_WORD.length(); i++) {
            if (commandWord.equalsIgnoreCase(COMMAND_WORD.substring(0, i))) {
                return true;
            }
        }
        return false;
    }
    
    @Override
    public String getMessageUsage() {
        return MESSAGE_USAGE;
    }
    
    @Override
    public String getCommandWord() {
        return COMMAND_WORD;
    }
    
    /*
     * ===============================================================
     *                          Helper Methods
     * ===============================================================
     */
    
    /** Returns true if indices are valid i.e. not end before start, start more than list size. */
    private boolean isValidIndices(Optional<UnmodifiableObservableList<ReadOnlyTask>> optionalList, int start,
            int end) {
        return !(!optionalList.isPresent() || optionalList.get().size() < start || end < start);
    }
    
    /** Returns true if prefixes of both indices are the same. */
    private boolean isIndicesReferringToSameLists() {
        return startIdx.toLowerCase().charAt(0) == endIdx.toLowerCase().charAt(0);
    }
    
    /** Converts {@code list} to a string with each task on an indexed newline. */
    private String getListOfTasksAsText(List<ReadOnlyTask> list) {
        return IntStream.range(0, list.size())
                .mapToObj(i -> (i + 1) + ". " + list.get(i).toString())
                .collect(Collectors.joining("\n"));
    }

    /** Deletes everything in {@code toDelete} from {@code model}. */
    private void deleteListOfTasks(List<ReadOnlyTask> toDelete) {
        for (int i = toDelete.size(); i > 0; i--) {
            try {
                model.deleteTask(toDelete.get(0)); // List contracts toward idx 0. when deleting
            } catch (TaskNotFoundException e) {
                assert false : "The target task cannot be missing";
            }
        }
    }
    
}
```
###### \java\seedu\jimi\logic\commands\EditCommand.java
``` java
/**
 * Edits an existing task/event in Jimi.
 */
public class EditCommand extends Command implements TaskBookEditor {
    
    public static final String COMMAND_WORD = "edit";
    public static final String COMMAND_REMOVE_DATES = "dateless";
    public static final String COMMAND_REMOVE_TAGS = "tagless";
    
    public static final String INDEX_TASK_PREFIX = "t";
    public static final String INDEX_EVENT_PREFIX = "e";
    
    public static final String MESSAGE_EDIT_EVENT_CONSTRAINTS = 
            "You tried to convert a task to an event but failed to specify an event start date.\n"
            + "Remember, edits must follow adding contraints! \n"
            + "\n"
            + AddCommand.MESSAGE_USAGE;
    
    public static final String MESSAGE_USAGE = 
            COMMAND_WORD + ": Edits an existing task/event in Jimi following add constraints. \n"
            + "Parameters: INDEX(must be t<positive integer> or e<positive integer>) EDITS_TO_MAKE\n" 
            + "You can edit everything from the task name to its tags. \n"
            + "You can leave out fields that you do not wish to edit too. \n"
            + "\n"
            + "For instance, if t2. already has a deadline but you only wish to edit its name: \n"
            + "Example: " + COMMAND_WORD + " t2 \"clear trash\"\n"
            + "\n"
            + "If you wish to remove all dates/tags from an existing task: \n"
            + "Example: " + COMMAND_WORD + " e1 dateless or " + COMMAND_WORD + " e1 tagless\n"
            + "\n"
            + "> Tip: Typing 'e', 'ed', 'edi' instead of 'edit' works too.";
    
    public static final String MESSAGE_EDIT_SUCCESS = "Updated details: %1$s";
    private static final String MESSAGE_DUPLICATE_TASK = 
            "Your new edits seem to overlap with an already existing task. Please check and try again!";
    
    private final String taskIndex; //index of task/event to be edited
    private UniqueTagList newTagList;
    private Name newName;
    private Priority newPriority;
    
    private DateTime deadline;
    private DateTime eventStart;
    private DateTime eventEnd;
    
    public enum EditType {
        REMOVE_DATES,
        REMOVE_TAGS,
        TO_SAME_TYPE,
        TO_EVENT,
        TO_DEADLINE
    }
    
    private EditType editType;
    
    /** Empty constructor for stub usage */
    public EditCommand() {
        this.taskIndex = null;
    }
    
    /** Constructor for removal of tags/dates at {@code taskIndex}. */
    public EditCommand(String taskIndex, EditType removeType) {
        assert removeType == EditType.REMOVE_DATES || removeType == EditType.REMOVE_TAGS;
        this.taskIndex = taskIndex.toLowerCase().trim();
        if (removeType == EditType.REMOVE_TAGS) {
            newTagList = new UniqueTagList();
        }
        editType = removeType;
    }
    
    public EditCommand(String name, Set<String> tags, List<Date> deadline, List<Date> eventStart, List<Date> eventEnd,
            String taskIndex, String priority) throws IllegalValueException {
        
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        
        this.taskIndex = taskIndex.toLowerCase().trim();
        
        if (name != null) {
            this.newName = new Name(name);
        }
        
        if (!tagSet.isEmpty()) {
            this.newTagList = new UniqueTagList(tagSet);
        }
        
        if (priority != null && !priority.isEmpty())   {
            this.newPriority = new Priority(priority);
        }
        
        this.deadline = (deadline.size() != 0) ? new DateTime(deadline.get(0)) : null;
        this.eventStart = (eventStart.size() != 0) ? new DateTime(eventStart.get(0)) : null;
        this.eventEnd = (eventEnd.size() != 0) ? new DateTime(eventEnd.get(0)) : null;
        
        determineEditType();
    }
    
    @Override
    public CommandResult execute() {
        Optional<UnmodifiableObservableList<ReadOnlyTask>> optionalList = 
                determineListFromIndexPrefix(taskIndex);
        
        // actual index is everything after the 1 character prefix.
        int actualIdx = Integer.parseInt(taskIndex.substring(1).trim());
        if (!optionalList.isPresent() || optionalList.get().size() < actualIdx) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = optionalList.get();
        
        ReadOnlyTask oldTask = lastShownList.get(actualIdx - 1);        
        Optional<ReadOnlyTask> newTask;
        try {
            newTask = determineNewTask(oldTask);
            if (!newTask.isPresent()) {
                new CommandResult(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
            }
            model.replaceTask(oldTask, newTask.get());
            return new CommandResult(String.format(MESSAGE_EDIT_SUCCESS, newTask.get()));
        } catch (DuplicateTaskException dte) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (IllegalValueException e) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(e.getMessage());
        }
    }
    
    @Override
    public boolean isValidCommandWord(String commandWord) {
        for (int i = 1; i <= COMMAND_WORD.length(); i++) {
            if (commandWord.equalsIgnoreCase(COMMAND_WORD.substring(0, i))) {
                return true;
            }
        }
        return false;
    }
    
    @Override
    public String getMessageUsage() {
        return MESSAGE_USAGE;
    }
    
    @Override
    public String getCommandWord() {
        return COMMAND_WORD;
    }
    
    /*
     * ====================================================================
     *                          Helper Methods
     * ====================================================================
     */
    
    /** Determines the type of edit based on user input. */
    private void determineEditType() {
        if ((newName != null || newTagList != null || newPriority != null) && deadline == null && eventStart == null
                && eventEnd == null) {
            this.editType = EditType.TO_SAME_TYPE;
        } else if (eventStart == null && eventEnd == null && deadline != null) {
            this.editType = EditType.TO_DEADLINE;
        } else if (deadline == null && (eventStart != null || eventEnd != null)) {
            this.editType = EditType.TO_EVENT;
        } else {
            this.editType = EditType.REMOVE_DATES;
        }
    }
    
    /** Generates the new task to replace the current task 
     * @throws IllegalValueException */
    private Optional<ReadOnlyTask> determineNewTask(ReadOnlyTask oldTask) throws IllegalValueException {
        assert oldTask != null;
        switch (editType) {
        case REMOVE_DATES :
            return Optional.of(toFloatingTypeWithChanges(oldTask));
        case REMOVE_TAGS :
        case TO_SAME_TYPE :
            return Optional.of(toSameTaskTypeWithChanges(oldTask));
        case TO_EVENT :
            return Optional.of(toEventTypeWithChanges(oldTask));
        case TO_DEADLINE :
            return Optional.of(toDeadlineTaskTypeWithChanges(oldTask));
        default :
            return Optional.empty();
        }
    }

    /** Converts ReadOnlyTask {@code t} to a floating task with changes */
    private ReadOnlyTask toFloatingTypeWithChanges(ReadOnlyTask t) {
        return generateFloatingTaskWithChanges(t);
    }

    /** Converts ReadOnlyTask {@code t} to a deadline task with changes. */
    private ReadOnlyTask toDeadlineTaskTypeWithChanges(ReadOnlyTask t) {
        return generateDeadlineTaskWithChanges(t);
    }

    /** Converts ReadOnlyTask {@code t} to an Event with changes. 
     * @throws IllegalValueException */
    private ReadOnlyTask toEventTypeWithChanges(ReadOnlyTask t) throws IllegalValueException {
        assert t != null;
        DateTime newStart = null;
        DateTime newEnd = null;
        
        if (!(t instanceof Event)) {
            if (eventStart == null) {
                throw new IllegalValueException(MESSAGE_EDIT_EVENT_CONSTRAINTS);
            }
            newStart = eventStart;
            newEnd = eventEnd == null ? new DateTime(eventStart.getDate().concat(" 23:59")) : eventEnd;
        } else { 
            newStart = determineNewEventStartForExistingEvent(t);
            newEnd = determineNewEventEndForExistingEvent(t);
        }
        
        if (newStart.compareTo(newEnd) <= 0) {
            return generateEventWithChanges(t, newStart, newEnd);
        } else {
            throw new IllegalValueException(Messages.MESSAGE_START_END_CONSTRAINT);
        }
    }

    /** Converts ReadOnlyTask {@code t} to its same task type, but with changes. 
     * @throws IllegalValueException */
    private ReadOnlyTask toSameTaskTypeWithChanges(ReadOnlyTask t) throws IllegalValueException {
        assert t != null;
        if (t instanceof Event) {
            DateTime newStart = determineNewEventStartForExistingEvent(t);
            DateTime newEnd = determineNewEventEndForExistingEvent(t);
            if (newStart.compareTo(newEnd) <= 0) {
                return generateEventWithChanges(t, newStart, newEnd);
            } else {
                throw new IllegalValueException(Messages.MESSAGE_START_END_CONSTRAINT);
            }
        } else if (t instanceof DeadlineTask) {
            return generateDeadlineTaskWithChanges(t);
        } else { // floating task
            return generateFloatingTaskWithChanges(t);
        }
    }

    /*
     * ==================================================================
     *                  Instantiation/Generation Methods
     * ==================================================================
     */
    
    /** Generates an event with changes */
    private Event generateEventWithChanges(ReadOnlyTask t, DateTime newStart, DateTime newEnd) {
        assert t != null;
        return new Event(newName == null ? t.getName() : newName, newStart, newEnd,
                newTagList == null ? t.getTags() : newTagList, t.isCompleted(), 
        		newPriority == null ? t.getPriority() : newPriority);
    }
    
    /** Generates a deadline task with changes */
    private DeadlineTask generateDeadlineTaskWithChanges(ReadOnlyTask t) {
        assert t != null;
        return new DeadlineTask(
                newName == null ? t.getName() : newName, 
                t instanceof DeadlineTask && deadline == null ? ((DeadlineTask) t).getDeadline() : deadline, 
                newTagList == null ? t.getTags() : newTagList, 
                newPriority == null ? t.getPriority() : newPriority);
    }
    
    /** Generates a floating task with changes */
    private FloatingTask generateFloatingTaskWithChanges(ReadOnlyTask t) {
        assert t != null;
        return new FloatingTask(
                newName == null ? t.getName() : newName, 
                newTagList == null ? t.getTags() : newTagList, 
                t.isCompleted(),
                newPriority == null ? t.getPriority() : newPriority);
    }
    
    private DateTime determineNewEventEndForExistingEvent(ReadOnlyTask t) {
        assert t != null;
        return eventEnd == null ? ((Event) t).getEnd() : eventEnd; // Checking for changes to be made
    }

    private DateTime determineNewEventStartForExistingEvent(ReadOnlyTask t) {
        assert t != null;
        return eventStart == null ? ((Event) t).getStart() : eventStart; // Checking for changes to be made
    }
}
```
###### \java\seedu\jimi\logic\commands\ExitCommand.java
``` java
    @Override
    public boolean isValidCommandWord(String commandWord) {
        return commandWord.equalsIgnoreCase(COMMAND_WORD);
    }
```
###### \java\seedu\jimi\logic\commands\HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {
    
    public static final String COMMAND_WORD = "help";
    
    public static final String MESSAGE_USAGE = 
            COMMAND_WORD + ": Shows program usage instructions.\n"
            + "You can also get specific help for commands.\n"
            + "For example, getting help for add command: " + COMMAND_WORD + " add \n"
            + Messages.MESSAGE_ALL_AVAIL_CMD;

    public static final String SHOWING_HELP_MESSAGE = 
            "Opened help window.\n" 
            + "\n"
            + MESSAGE_USAGE;
    
    private Command toHelp;
    
    public HelpCommand() {}
    
    public HelpCommand(String cmdToShow) throws IllegalValueException {
        List<Command> cmdStubList = CommandUtil.getInstance().getCommandStubList();
        
        // Tries to find a match with all command words.
        Optional<Command> match = cmdStubList.stream()
                .filter(c -> c.isValidCommandWord(cmdToShow))
                .findFirst();
        
        if (match.isPresent()) {
            toHelp = match.get();
        } else { // User specified an unknown command.
            throw new IllegalValueException(String.format(Messages.MESSAGE_UNKNOWN_COMMAND, cmdToShow));
        }
    }
    
    @Override
    public CommandResult execute() {
        if (toHelp == null) {
            EventsCenter.getInstance().post(new ShowHelpRequestEvent());
            return new CommandResult(SHOWING_HELP_MESSAGE);
        } else { // User specified a command for help.
            return new CommandResult(toHelp.getMessageUsage());
        }
    }
    
    @Override
    public boolean isValidCommandWord(String commandWord) {
        for (int i = 1; i <= COMMAND_WORD.length(); i++) {
            if (commandWord.equalsIgnoreCase(COMMAND_WORD.substring(0, i))) {
                return true;
            }
        }
        return false;
    }
    
    @Override
    public String getMessageUsage() {
        return MESSAGE_USAGE;
    }
    
    @Override
    public String getCommandWord() {
        return COMMAND_WORD;
    }
}
```
###### \java\seedu\jimi\logic\commands\ShowCommand.java
``` java
    @Override
    public boolean isValidCommandWord(String commandWord) {
        for (int i = 1; i <= COMMAND_WORD.length(); i++) {
            if (commandWord.equalsIgnoreCase(COMMAND_WORD.substring(0, i))) {
                return true;
            }
        }
        return false;
    }
    
    @Override
    public String getMessageUsage() {
        return MESSAGE_USAGE;
    }
    
    @Override
    public String getCommandWord() {
        return COMMAND_WORD;
    }
    
    /*
     * =========================================================
     *                      Helper Methods
     * =========================================================
     */
    
    /** Checks if {@code test} is a valid keyword as shown in {@code VALID_KEYWORDS}. */
    private boolean isValidSectionToShow(String test) {
        return ShowCommand.VALID_KEYWORDS.stream()
                .filter(w -> w.toLowerCase().equals(test.toLowerCase()))
                .findAny()
                .isPresent();
    }
```
###### \java\seedu\jimi\logic\parser\JimiParser.java
``` java
    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("[te](?<targetIndex>.+)", Pattern.CASE_INSENSITIVE);

    private static final Pattern KEYWORDS_WITH_DATES_ARGS_FORMAT =
            Pattern.compile("((\"(?<keywords>\\S+(?:\\s+\\S+)*)\")?(((on|from) (?<specificDateTime>.+))?)|(from (?<startDateTime>((?!to ).)*))?(to (?<endDateTime>.+))?)");
    
    private static final Pattern ADD_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("(?<ArgsDetails>[^/]+)(?<tagArguments>(?: t/[^/]+)?)(?<priorityArguments>(?: p/[^/]+)?)"); // zero or one tag only, zero or one priority    
    
    private static final Pattern EDIT_DATA_ARGS_FORMAT = // accepts index at beginning, follows task/event patterns after
            Pattern.compile("(?<targetIndex>[^\\s/]+) (?<editDetails>.+)");
    
    private static final Pattern DELETE_DATA_ARGS_FORMAT = 
            Pattern.compile("(?<startIdx>((?!to).)*)(to (?<endIdx>.+))?");
    
    // all fields optional
    private static final Pattern EDIT_DETAILS_FORMAT = Pattern.compile(
            "(\"(?<taskDetails>.+)\"\\s*)?((due (?<deadline>[^/]+))|((on|from) (?<startDateTime>((?!to )[^/])*))?(to (?<endDateTime>[^/]+))?)?"
            + "(?<tagArguments>(?:\\s*t/[^/]+)?)(?<priorityArguments>(?:\\s*p/[^/]+)?)");
    
    private static final Pattern ADD_TASK_DATA_ARGS_FORMAT = 
            Pattern.compile("(\"(?<taskDetails>.+)\")( due (?<dateTime>.+))?");
    
    private static final Pattern ADD_EVENT_DATA_ARGS_FORMAT =
            Pattern.compile("(\"(?<taskDetails>.+)\") (on|from) (?<startDateTime>((?! to ).)*)( to (?<endDateTime>.+))?");
    
    private static final Pattern SHOW_COMMAND_ARGS_FORMAT = Pattern.compile("(?<sectionToShow>.+)");
    
    private static final Pattern SAVE_DIRECTORY_ARGS_FORMAT = Pattern.compile("(?<filePath>.+).xml");
    
    private static final Pattern SAVE_RESET_DIRECTORY_ARGS_FORMAT = Pattern.compile(SaveAsCommand.COMMAND_WORD_RESET);
    
    private static final String XML_FILE_EXTENSION = ".xml";
    
    private static final List<Command> COMMAND_STUB_LIST = CommandUtil.getInstance().getCommandStubList();

    public JimiParser() {}

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }
        
        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments").trim();
        
        return prepareCommand(commandWord, arguments);
    }

    /**
     * Identifies which command to prepare according to raw command word.
     * 
     * @param commandWord command word from raw input
     * @param arguments arguments from raw input
     * @return correct Command corresponding to the command word if valid, else returns incorrect command.
     */
    private Command prepareCommand(String commandWord, String arguments) {
        Optional<Command> prepared = 
                COMMAND_STUB_LIST.stream().filter(c -> c.isValidCommandWord(commandWord)).map(c -> {
            if (c instanceof AddCommand) {
                return prepareAdd(arguments);
            } else if (c instanceof HelpCommand) {
                return prepareHelp(arguments);
            } else if (c instanceof EditCommand) {
                return prepareEdit(arguments);
            } else if (c instanceof CompleteCommand) {
                return prepareComplete(arguments);
            } else if (c instanceof ShowCommand) {
                return prepareShow(arguments);
            } else if (c instanceof DeleteCommand) {
                return prepareDelete(arguments);
            } else if (c instanceof FindCommand) {
                return prepareFind(arguments);
            } else if (c instanceof SaveAsCommand) {
                return prepareSaveAs(arguments);
            } else { // commands that do not require arguments e.g. exit
                return c;
            }
        }).findFirst();
        
        if (!prepared.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_UNKNOWN_COMMAND, commandWord));
        }
        
        return prepared.get();
    }
    
    private Command prepareHelp(String args) {
        if (args.trim().isEmpty()) {
            return new HelpCommand();
        }
        
        try {
            return new HelpCommand(args.trim());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher detailsAndTagsMatcher = ADD_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate entire args string format
        if (!detailsAndTagsMatcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        
        final Matcher taskDetailsMatcher =
                ADD_TASK_DATA_ARGS_FORMAT.matcher(detailsAndTagsMatcher.group("ArgsDetails").trim());
        final Matcher eventDetailsMatcher =
                ADD_EVENT_DATA_ARGS_FORMAT.matcher(detailsAndTagsMatcher.group("ArgsDetails").trim());
        
        if (taskDetailsMatcher.matches()) { // if user trying to add task 
            return generateAddCommandForTask(detailsAndTagsMatcher, taskDetailsMatcher);
        } else if (eventDetailsMatcher.matches()) { // if user trying to add event
            return generateAddCommandForEvent(detailsAndTagsMatcher, eventDetailsMatcher);
        }
        
        /* default return IncorrectCommand */
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
    }
    
    /**
     * Creates an AddCommand in the context of adding an event.
     * 
     * @return an AddCommand if raw args is valid, else IncorrectCommand
     */
    private Command generateAddCommandForEvent(final Matcher detailsAndTagsMatcher, final Matcher eventDetailsMatcher) {
        try {
            List<Date> startDates = parseStringToDate(eventDetailsMatcher.group("startDateTime"));
            List<Date> endDates = parseStringToDate(eventDetailsMatcher.group("endDateTime"));
            
            String priority = getPriorityFromArgs(detailsAndTagsMatcher.group("priorityArguments"));
            if (priority == null) {
                priority = Priority.PRIO_NONE;
            }
            
            return new AddCommand(
                    eventDetailsMatcher.group("taskDetails"),
                    startDates,
                    endDates,
                    getTagsFromArgs(detailsAndTagsMatcher.group("tagArguments")),
                    priority
            );
        } catch (DateNotParsableException e) {
            return new IncorrectCommand(e.getMessage());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Creates an AddCommand in the context of adding an task.
     * 
     * @return an AddCommand if raw args is valid, else IncorrectCommand
     */
    private Command generateAddCommandForTask(final Matcher detailsAndTagsMatcher, final Matcher taskDetailsMatcher) {
        try {
            List<Date> dates = parseStringToDate(taskDetailsMatcher.group("dateTime"));
            
            String priority = getPriorityFromArgs(detailsAndTagsMatcher.group("priorityArguments"));
            if (priority == null) {
                priority = Priority.PRIO_NONE;
            }
            
            return new AddCommand(
                    taskDetailsMatcher.group("taskDetails"),
                    dates,
                    getTagsFromArgs(detailsAndTagsMatcher.group("tagArguments")),
                    priority
            );
        } catch (DateNotParsableException e) {
            return new IncorrectCommand(e.getMessage());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### \java\seedu\jimi\logic\parser\JimiParser.java
``` java
    /**
     * Parses arguments in context of the edit task command.
     * 
     * @param args Full user command input args
     * @return the prepared edit command
     */
    private Command prepareEdit(String args) {
        // Validate args in terms of <idx><details>
        final Matcher editArgsMatcher = EDIT_DATA_ARGS_FORMAT.matcher(args.trim());
        if (!editArgsMatcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        // User wishes to remove dates
        if (editArgsMatcher.group("editDetails").trim().equals(EditCommand.COMMAND_REMOVE_DATES)) {
            return new EditCommand(editArgsMatcher.group("targetIndex"), EditType.REMOVE_DATES);
        }
        
        // User wishes to remove tags
        if (editArgsMatcher.group("editDetails").trim().equals(EditCommand.COMMAND_REMOVE_TAGS)) {
            return new EditCommand(editArgsMatcher.group("targetIndex"), EditType.REMOVE_TAGS);
        }
        
        // Validate details format
        final Matcher editDetailsMatcher = EDIT_DETAILS_FORMAT.matcher(editArgsMatcher.group("editDetails").trim());
        if (!editDetailsMatcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        try {
            return generateEditCommand(editArgsMatcher, editDetailsMatcher);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    
    /** Generates an edit command */
    private Command generateEditCommand(Matcher editArgsMatcher, Matcher editDetailsMatcher)
            throws IllegalValueException {
        
        List<Date> deadline = parseStringToDate(editDetailsMatcher.group("deadline"));
        List<Date> eventStart = parseStringToDate(editDetailsMatcher.group("startDateTime"));
        List<Date> eventEnd = parseStringToDate(editDetailsMatcher.group("endDateTime"));
        
        /* validating integer index */
        Optional<Integer> index = parseIndex(editArgsMatcher.group("targetIndex"));
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        return new EditCommand(
                editDetailsMatcher.group("taskDetails"),
                getTagsFromArgs(editDetailsMatcher.group("tagArguments")),
                deadline,
                eventStart,
                eventEnd,
                editArgsMatcher.group("targetIndex"),
                getPriorityFromArgs(editDetailsMatcher.group("priorityArguments"))
        );
    }
```
###### \java\seedu\jimi\logic\parser\JimiParser.java
``` java
    /**
     * Parses arguments in the context of the save as command.
     * 
     * @param full command args string
     * @return the prepared command
     */
    private Command prepareSaveAs(String args) {
        try {
            final Matcher resetMatcher = SAVE_RESET_DIRECTORY_ARGS_FORMAT.matcher(args.trim());
            if (resetMatcher.matches()) {
                return new SaveAsCommand(Config.DEFAULT_XML_FILE_PATH);
            }
            
            final Matcher matcher = SAVE_DIRECTORY_ARGS_FORMAT.matcher(args.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveAsCommand.MESSAGE_USAGE));
            }
            
            return new SaveAsCommand(matcher.group("filePath") + XML_FILE_EXTENSION);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ive.getMessage()));
        }
    }

```
###### \java\seedu\jimi\model\FilteredListManager.java
``` java
/**
 * Represents a manager for filtered lists used in the UI component.
 * Respective UI components should already be listeners to each of the lists in {@code listMap}.
 */
public class FilteredListManager {
    private static final Logger logger = LogsCenter.getLogger(FilteredListManager.class);
    
    public enum ListId {
        DAY_AHEAD_0, 
        DAY_AHEAD_1, 
        DAY_AHEAD_2, 
        DAY_AHEAD_3, 
        DAY_AHEAD_4, 
        DAY_AHEAD_5, 
        DAY_AHEAD_6, 
        FLOATING_TASKS, 
        COMPLETED, 
        INCOMPLETE, 
        TASKS_AGENDA, 
        EVENTS_AGENDA,
        OVERDUE
    }
    
    private final HashMap<ListId, FilteredList<ReadOnlyTask>> listMap =
            new HashMap<ListId, FilteredList<ReadOnlyTask>>();
    
    private final HashMap<ListId, SortedList<ReadOnlyTask>> sortedListMap =
            new HashMap<ListId, SortedList<ReadOnlyTask>>();
    
    private final HashMap<ListId, Expression> defaultExpressions = new HashMap<ListId, Expression>();
    
    
    public FilteredListManager(TaskBook taskBook) {
        initDefaultExpressions();
        initFilteredLists(taskBook);
        initSortedLists();
    }
    /*
     *  1. Initializing each list with taskBook's own internal list.
     *  2. Setting default filters for each list.
     *  
     *  Adds in CompletedQualifiers when initializing agenda lists.
     */
    private void initFilteredLists(TaskBook taskBook) {
        for (ListId id : ListId.values()) {
            listMap.put(id, new FilteredList<ReadOnlyTask>(taskBook.getTasks()));
            
            if (id.equals(ListId.TASKS_AGENDA)) {
                listMap.get(id).setPredicate(
                        new LogicalAndPredicate(new TaskQualifier(true), new CompletedQualifier(false))::satisfies);
            } else if (id.equals(ListId.EVENTS_AGENDA)) {
                listMap.get(id).setPredicate(
                        new LogicalAndPredicate(new EventQualifier(true), new CompletedQualifier(false))::satisfies);
            } else {
                listMap.get(id).setPredicate(defaultExpressions.get(id)::satisfies);
            }
        }
    }
    
    /**
```
###### \java\seedu\jimi\model\FilteredListManager.java
``` java
    /**
     * Initializes default expressions used by all the filtered lists in {@code listMap}.
     */
    private void initDefaultExpressions() {
        // Expression matches if it's an incomplete floating task.
        defaultExpressions.put(ListId.FLOATING_TASKS,
                new LogicalAndPredicate(new FloatingTaskQualifier(true), new CompletedQualifier(false)));
        
        // Expression matches if it's a completed non-event.
        defaultExpressions.put(ListId.COMPLETED,
                new LogicalAndPredicate(new EventQualifier(false), new CompletedQualifier(true)));
        // Expression matches if it's an incomplete non-event.
        defaultExpressions.put(ListId.INCOMPLETE,
                new LogicalAndPredicate(new EventQualifier(false), new CompletedQualifier(false)));
        
        // Expressions match if they match the current relative day and are incomplete.
        defaultExpressions.put(ListId.DAY_AHEAD_0,
                new LogicalAndPredicate(new WeekQualifier(ListId.DAY_AHEAD_0), new CompletedQualifier(false)));
        defaultExpressions.put(ListId.DAY_AHEAD_1,
                new LogicalAndPredicate(new WeekQualifier(ListId.DAY_AHEAD_1), new CompletedQualifier(false)));
        defaultExpressions.put(ListId.DAY_AHEAD_2,
                new LogicalAndPredicate(new WeekQualifier(ListId.DAY_AHEAD_2), new CompletedQualifier(false)));
        defaultExpressions.put(ListId.DAY_AHEAD_3,
                new LogicalAndPredicate(new WeekQualifier(ListId.DAY_AHEAD_3), new CompletedQualifier(false)));
        defaultExpressions.put(ListId.DAY_AHEAD_4,
                new LogicalAndPredicate(new WeekQualifier(ListId.DAY_AHEAD_4), new CompletedQualifier(false)));
        defaultExpressions.put(ListId.DAY_AHEAD_5,
                new LogicalAndPredicate(new WeekQualifier(ListId.DAY_AHEAD_5), new CompletedQualifier(false)));
        defaultExpressions.put(ListId.DAY_AHEAD_6,
                new LogicalAndPredicate(new WeekQualifier(ListId.DAY_AHEAD_6), new CompletedQualifier(false)));
        
        // Expression matches if it's a task.
        defaultExpressions.put(ListId.TASKS_AGENDA,
                new LogicalAndPredicate(new TaskQualifier(true)));
        // Expression matches if it's an event.
        defaultExpressions.put(ListId.EVENTS_AGENDA,
                new LogicalAndPredicate(new EventQualifier(true)));
        
        // Expression matches if task is overdue.
        defaultExpressions.put(ListId.OVERDUE,
                new LogicalAndPredicate(new TaskQualifier(true), new OverdueQualifier()));
    }
```
###### \java\seedu\jimi\model\FilteredListManager.java
``` java
    /** 
     * Updates filtered list identified by {@code id} with the filter in {@code other}, along with the original 
     * default filter of list identified by {@code id}.  
     */
    public void updateFilteredList(ListId id, ListId other) {
        updateFilteredList(id, defaultExpressions.get(id), defaultExpressions.get(other));
        
    }
    
    /** 
     * Updates filtered list identified by {@code id} with a filter that matches all filters in {@code expressions}.
     */
    private void updateFilteredList(ListId id, Expression... expressions) {
        listMap.get(id).setPredicate(t -> Arrays.stream(expressions).allMatch(e -> e.satisfies(t)));
    }
```
###### \java\seedu\jimi\model\FilteredListManager.java
``` java
    /**
     * Represents a predicate expression that allows for multiple {@code Qualifier} instances.
     * 
     * For this PredicateExpression to satisfy, all qualifiers must pass.
     */
    private class LogicalAndPredicate implements Expression {
        
        private final List<Qualifier> qualifiers;
        
        LogicalAndPredicate(Qualifier... qualifiers) {
            this.qualifiers = Arrays.asList(qualifiers);
        }
        
        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifiers.stream().allMatch(q -> q.run(task));
        }
        
        @Override
        public String toString() {
            return qualifiers.toString();
        }
    }
    
    /**
     * Represents a predicate expression that allows for multiple {@code Qualifier} instances.
     * 
     * For this PredicateExpression to satisfy, a qualifier must pass.
     */
    private class LogicalOrPredicate implements Expression {
        
        private final List<Qualifier> qualifiers;
        
        LogicalOrPredicate(Qualifier... qualifiers) {
            this.qualifiers = Arrays.asList(qualifiers);
        }
        
        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifiers.stream().anyMatch(q -> q.run(task));
        }
        
        @Override
        public String toString() {
            return qualifiers.toString();
        }
    }
    
    interface Qualifier {
        
        boolean run(ReadOnlyTask task);
        
        String toString();
    }
    
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        
        public NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            List<String> splitTaskName = Arrays.asList(task.getName().fullName.split("\\s+"));
            return nameKeyWords.stream()
                    .filter(kw -> StringUtil.isAnyNearMatch(kw, splitTaskName))
                    .findAny()
                    .isPresent();
        }
        
        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }
    
    private class PriorityQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        
        public PriorityQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            String priority = task.getPriority().tagName.toLowerCase();
            return nameKeyWords.stream()
                    .filter(kw -> !priority.equals(Priority.PRIO_NONE) && kw.toLowerCase().equals(priority))
                    .findAny()
                    .isPresent();
        }
        
        @Override
        public String toString() {
            return "prio=" + String.join(", ", nameKeyWords);
        }
    }
    
    private class TagNameQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        
        public TagNameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            List<String> tagNames = task.getTags().getInternalList().stream()
                    .map(t -> t.tagName)
                    .collect(Collectors.toList());
            return nameKeyWords.stream()
                    .filter(kw -> StringUtil.isAnyNearMatch(kw, tagNames))
                    .findAny()
                    .isPresent();
        }
        
        @Override
        public String toString() {
            return "tagName=" + String.join(", ", nameKeyWords);
        }
    }
```
###### \java\seedu\jimi\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the FloatingTask.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String name = "";
    @XmlElement(required = true)
    private String isCompleted = "";
    
    @XmlElement(required = true)
    private String taskDeadline = "";
    @XmlElement(required = true)
    private String eventStartDatetime = "";
    @XmlElement(required = true)
    private String eventEndDatetime = "";
    
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();
    
    @XmlElement(required = true)
    private String priority = "";

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given FloatingTask into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        isCompleted = Boolean.toString(source.isCompleted());
        
        if (source instanceof DeadlineTask) {
            taskDeadline = ((DeadlineTask) source).getDeadline().toString();
        } else if (source instanceof Event) {
            eventStartDatetime = ((Event) source).getStart().toString();
            DateTime endDate = ((Event) source).getEnd();
            if (endDate != null) {
                eventEndDatetime = endDate.toString();
            }
        }
        
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
        
        priority = source.getPriority().tagName;
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's FloatingTask object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public ReadOnlyTask toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        final Name name = new Name(this.name);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        final boolean isCompletedBoolean = Boolean.parseBoolean(isCompleted);
        ReadOnlyTask toConvert;
        final Priority priority = new Priority(this.priority);
        
        if (taskDeadline.isEmpty() && eventStartDatetime.isEmpty()) { // floating
            toConvert = new FloatingTask(name, tags, isCompletedBoolean, priority);
        } else if (!taskDeadline.isEmpty()) { // deadline task
            toConvert = new DeadlineTask(name, new DateTime(taskDeadline), tags, isCompletedBoolean, priority);
        } else {
            toConvert = new Event(
                    name, 
                    new DateTime(eventStartDatetime), 
                    new DateTime(eventEndDatetime), 
                    tags, 
                    isCompletedBoolean,
                    priority);
        }
        
        return toConvert;
    }
}
```
###### \java\seedu\jimi\ui\CommandBox.java
``` java
    @FXML
    private void handleTextFieldKeyReleased(KeyEvent event) {
        switch (event.getCode()) {
        case UP :
            cyclePreviousInput();
            return;
        case DOWN :
            cycleAheadInput();
            return;
        case ENTER :
            return; // Do nothing since handleCommandInputChanged already handles this.
        default :
            handleTextFieldKeyTyped();
            return;
        }
    }
    
    /** Handles event when command input has changed */
    @FXML
    private void handleCommandInputChanged() {
        if (commandTextField.getText().trim().isEmpty()) {
            return; // Do nothing for empty input.
        }
        previousCommandText = commandTextField.getText().trim(); // Take a copy of the command text.
        resetInputHistoryToMostRecent();
        previousInputs.push(previousCommandText); // Updating history of inputs for up/down cycling.
        
        /* We assume the command is correct. If it is incorrect, the command box will be changed accordingly
         * in the event handling code {@link #handleIncorrectCommandAttempted}
         */
        setResultDisplayAndCmdBoxToDefault();
        executeCommand();
    }
    
    /** Parses and executes the command given by {@code previousCommandText} */
    private void executeCommand() {
        mostRecentResult = logic.execute(previousCommandText);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }
    
    /** Handles the event when a key is typed in {@code commandTextField}. */
    private void handleTextFieldKeyTyped() {
        String currentText = commandTextField.getText().trim();
        
        logger.info("Text in text field: " + currentText);
        
        if (currentText.isEmpty()) {
            setResultDisplayAndCmdBoxToDefault();
        } else {
            postCommandSuggestions(currentText.toLowerCase());
        }
    }
    
    /** Posts suggestions for commands according to the first word of {@code currentText} */
    private void postCommandSuggestions(String currentText) {
        /* 
         * Only providing suggestions for first word, so once the full input text length 
         * exceeds the length of the first word, stop providing suggestions. 
         */
        String firstWordOfInput = StringUtil.getFirstWord(currentText);
        if (currentText.length() > firstWordOfInput.length()) { // Short-circuit here to improve performance.
            setResultDisplayToDefault();
            return; 
        }
        
        List<String> commandWordMatches = CommandUtil.getInstance().getCommandWordMatches(firstWordOfInput);
        
        logger.info("Suggestions: " + commandWordMatches);
        
        if (commandWordMatches.isEmpty()) {
            setResultDisplayToDefault();
        } else {
            resultDisplay.postMessage(
                    String.format(MESSAGE_COMMAND_SUGGESTIONS, String.join(", ", commandWordMatches)));
        }
    }
    
    /** Sets {@code commandTextField} and {@code resultDisplay} to their default styles/postings */
    private void setResultDisplayAndCmdBoxToDefault() {
        setCommandBoxtoDefault();
        setResultDisplayToDefault();
    }
    
    /** Sets {@code commandTextField} with input texts cycling forwards in input history. */
    private void cycleAheadInput() {
        if (aheadInputs.isEmpty()) {
            return;
        }
        
        commandTextField.setText(aheadInputs.peek());
        setCaretToRightEnd();
        
        // Last input text does not need to be popped so as to avoid double counting.
        if (aheadInputs.size() > 1) {
            previousInputs.push(aheadInputs.pop());
        }
    }
    
    /** Sets {@code commandTextField} with input texts cycling backwards in input history. */
    private void cyclePreviousInput() {
        if (previousInputs.isEmpty()) {
            return;
        }
        
        commandTextField.setText(previousInputs.peek());
        setCaretToRightEnd();
        
        // Last input text does not need to be popped so as to avoid double counting.
        if (previousInputs.size() > 1) {
            aheadInputs.push(previousInputs.pop());
        }
    }
    
    /** Pushes all input text in {@code aheadInputs} into {@code previousInputs}. */
    private void resetInputHistoryToMostRecent() {
        while (!aheadInputs.isEmpty()) {
            previousInputs.push(aheadInputs.pop());
        }
    }
    
    /** Shifts caret to the right end of {@code commandTextField} */
    private void setCaretToRightEnd() {
        commandTextField.positionCaret(commandTextField.getText().length());
    }
    
    /** Sets {@code resultDisplay} to its default posting */
    private void setResultDisplayToDefault() {
        // If most recent result does not exist, post welcome message instead.
        resultDisplay.postMessage(
                mostRecentResult == null ? Messages.MESSAGE_WELCOME_JIMI : mostRecentResult.feedbackToUser);
    }
```
